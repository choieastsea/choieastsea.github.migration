{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/DS02-LinkedList/",
    "result": {"data":{"cur":{"id":"d2a012e0-3dba-5c82-b90f-2a0682b200c8","html":"<h1 id=\"linkedlist란\" style=\"position:relative;\"><a href=\"#linkedlist%EB%9E%80\" aria-label=\"linkedlist란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList란</h1>\n<p>LinkedList(연결리스트)는 <strong>리스트라는 추상자료형을 구현하는 선형 자료구조</strong> 중 하나로, <code class=\"language-text\">노드</code>끼리 참조를 통하여 연결되어 선형적인 형태를 이루고 있는 자료구조이다. Array는 크기가 정해져 있고 메모리에서 연속적으로 존재하였지만, 링크드 리스트는 각 노드에 데이터가 저장되어 있으며 이웃한 노드의 정보(주소)를 가리키고 있는 형태로 여러 데이터를 저장한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdpaIWP/xAAWEAEBAQAAAAAAAAAAAAAAAAAhACD/2gAIAQEAAQUCZnH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAEBAAIDAAAAAAAAAAAAAAABEQAgIVFx/9oACAEBAAE/IW1jMeAX3A7af//aAAwDAQACAAMAAAAQc8//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCI/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Qqv/EABsQAQADAAMBAAAAAAAAAAAAAAEAETEQIUFx/9oACAEBAAE/EMABos35BcaewZKr5HpTSHHs/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Array와 LinkedList 비교\"\n        title=\"Array와 LinkedList 비교\"\n        src=\"/static/bf210e9da639c1a95f6dc02a0c6135d3/80e3c/Comparing.jpg\"\n        srcset=\"/static/bf210e9da639c1a95f6dc02a0c6135d3/4ec73/Comparing.jpg 180w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/158ba/Comparing.jpg 360w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/80e3c/Comparing.jpg 720w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/47311/Comparing.jpg 1080w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/eea4a/Comparing.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>간단하게 위의 그림으로 Array와 LinkedList를 비교해볼 수 있다. 연결리스트에서는 데이터가 노드에 저장되며, 노드끼리의 연결관계가 존재한다. 또한 head와 tail은 각각 처음과 마지막 노드를 가리키고 있어 모든 노드에 접근할 수 있게 되는 것이다. 따라서 각 노드는 메모리상에서 연속적으로 존재할 필요가 없으며, 데이터의 자료형이 같을 필요도 없을 것이다.</p>\n<h1 id=\"linkedlist-구현-요구-사항\" style=\"position:relative;\"><a href=\"#linkedlist-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"linkedlist 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 구현 요구 사항</h1>\n<p>LinkedList에서는 배열과 다르게 데이터를 <code class=\"language-text\">Node</code>에서 갖고 있도록 한다. 노드는 데이터를 갖고 있으며, 다른 노드에 대한 레퍼런스를 갖고 있는 객체로 만들면 될 것이다. 여기서는 이전 노드와 다음 노드에 대한 주소를 갖고 있는이중연결리스트(<code class=\"language-text\">Doubly LinkedList</code>)로 구현해보도록 한다.</p>\n<h2 id=\"node-객체\" style=\"position:relative;\"><a href=\"#node-%EA%B0%9D%EC%B2%B4\" aria-label=\"node 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node 객체</h2>\n<ul>\n<li>Fields\n<ul>\n<li>data</li>\n<li>prev : 이전 노드의 정보를 갖고 있는 프로퍼티</li>\n<li>next : 다음 노드의 정보를 갖고 있는 프로퍼티</li>\n</ul>\n</li>\n<li>Functions\n<ul>\n<li>setData</li>\n<li>setPrev</li>\n<li>setNext</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"linkedlist-객체\" style=\"position:relative;\"><a href=\"#linkedlist-%EA%B0%9D%EC%B2%B4\" aria-label=\"linkedlist 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 객체</h2>\n<p>연결리스트는 여러개의 노드로 이루어져 있으며, 시작점과 끝점인 head와 tail을 갖고 있는다.</p>\n<ul>\n<li>Properties\n<ul>\n<li>head : 첫 노드를 가리킨다. 만약 노드가 하나도 없다면 head는 <code class=\"language-text\">null</code>일 것이다.</li>\n<li>tail : 가장 마지막 노드를 가리킨다. 만약 노드가 하나도 없다면 tail도 <code class=\"language-text\">null</code>일 것이다.</li>\n<li>size : 처음부터 마지막 노드까지의 갯수</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>\n<p><strong>접근</strong> get(index) → Node</p>\n<p>head가 가리키는 노드부터 next 노드에 접근하여 next노드가 없을때까지 <strong>index번</strong>만큼 접근한다. 만약 없다면 -1을 return한다.</p>\n<p>head를 iterator로 지정해주고 하나씩 다음 노드로 넘어간다. index만큼 넘어가는 loop를 반복해주면 해당 인덱스의 노드를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> iterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>추가</strong> append(Node)</p>\n<p>맨뒤에 새로운 노드를 추가할 때, 나올 수 있는 경우는 두가지 정도로 생각할 수 있다.</p>\n<ol>\n<li>\n<p>빈 연결리스트에서 추가할 때, null을 가리키고 있던 head와 tail 모두 바꿔줘야 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB242EkMP/xAAXEAEAAwAAAAAAAAAAAAAAAAABABEg/9oACAEBAAEFAriuf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAABETEgIWH/2gAIAQEAAT8haKebJFMVYf/aAAwDAQACAAMAAAAQzz//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAn/8QAHBABAQACAgMAAAAAAAAAAAAAAREAIUHwEDFh/9oACAEBAAE/ENputQ46YTQAFY8HTKi+5vIN+5B48f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"append 1st case\"\n        title=\"append 1st case\"\n        src=\"/static/2b062e38bfb37891a8a7242492791caa/80e3c/append_1.jpg\"\n        srcset=\"/static/2b062e38bfb37891a8a7242492791caa/4ec73/append_1.jpg 180w,\n/static/2b062e38bfb37891a8a7242492791caa/158ba/append_1.jpg 360w,\n/static/2b062e38bfb37891a8a7242492791caa/80e3c/append_1.jpg 720w,\n/static/2b062e38bfb37891a8a7242492791caa/47311/append_1.jpg 1080w,\n/static/2b062e38bfb37891a8a7242492791caa/eea4a/append_1.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>그것이 아니라면, tail만 바꿔주면 될 것이다. 기존의 tail이 가리키고 있던 노드는 새 노드를 next로 갖도록 해야하며, new_node는 기존의 tail 노드를 prev로 갖고 있을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABtBAP/8QAFxABAQEBAAAAAAAAAAAAAAAAACEBEf/aAAgBAQABBQKqzr//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAACAwAAAAAAAAAAAAAAAAAAUREhYf/aAAgBAQABPyGyJwMP/9oADAMBAAIAAwAAABB7z//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QmI//xAAXEAEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAEBAAE/EOx2Bua8cgNCrd//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"append 2nd case\"\n        title=\"append 2nd case\"\n        src=\"/static/46caee95d9e0dc0fba2e779487d5cf8a/80e3c/append_2.jpg\"\n        srcset=\"/static/46caee95d9e0dc0fba2e779487d5cf8a/4ec73/append_2.jpg 180w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/158ba/append_2.jpg 360w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/80e3c/append_2.jpg 720w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/47311/append_2.jpg 1080w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/eea4a/append_2.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>코드는 다음과 같을 것이다. 또한 size를 1씩 증가시켜줘야한다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n    new_node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삽입</strong> insert(index, new_node)</p>\n<p>index번째 노드 뒤에 new_node를 삽입하는 경우도 역시 2가지로 나눠볼 수 있다.</p>\n<ol>\n<li>\n<p>index===size-1인 경우에는 append와 같을 것이다.</p>\n</li>\n<li>\n<p>그 외의 경우, 아래의 그림을 참고하여 prev와 next를 조정해주면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtXSIqP//EABYQAQEBAAAAAAAAAAAAAAAAACEAIP/aAAgBAQABBQJnP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAEEAwAAAAAAAAAAAAAAAAABESAxQWGh/9oACAEBAAE/IbV0V2hHzD//2gAMAwEAAgADAAAAELD/AP/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EIf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGRABAAMBAQAAAAAAAAAAAAAAAREhMQAg/9oACAEBAAE/EHYBwJsC6d6tiTNR4//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"insert\"\n        title=\"insert\"\n        src=\"/static/ce604385d982a0ed5ce0e09e8f731642/80e3c/insert.jpg\"\n        srcset=\"/static/ce604385d982a0ed5ce0e09e8f731642/4ec73/insert.jpg 180w,\n/static/ce604385d982a0ed5ce0e09e8f731642/158ba/insert.jpg 360w,\n/static/ce604385d982a0ed5ce0e09e8f731642/80e3c/insert.jpg 720w,\n/static/ce604385d982a0ed5ce0e09e8f731642/47311/insert.jpg 1080w,\n/static/ce604385d982a0ed5ce0e09e8f731642/cdb2b/insert.jpg 1281w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ol>\n<p>주의할 점은 next와 prev를 초기화하는 순서를 혼동하여 노드간의 연결이 끊기지 않도록 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index<span class=\"token punctuation\">,</span> new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//index에 해당하는 node를 찾아서 삽입한다.</span>\n  <span class=\"token keyword\">let</span> nodeToFind <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeToFind <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeToFind <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//맨끝삽입</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>new_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//가운데삽입</span>\n      new_node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> nodeToFind<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      nodeToFind<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n      new_node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> nodeToFind<span class=\"token punctuation\">;</span>\n      nodeToFind<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'index에 해당하는 노드가 없습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>제일 앞에 삽입</strong> unshift(new_node)</p>\n<p>위의 경우들로는 맨 앞에 노드를 추가해줄 수 없다. 따라서,  맨 앞에 노드를 추가해주는 unshift 함수를 정의해주도록 하자. 역시 빈 연결리스트일때와 나머지 경우로 나눠볼 수 있으며, head를 조정해주면 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>new_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n    new_node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삭제</strong> remove(index)</p>\n<p>삭제는 정수형 인덱스를 넘겨 i번째 노드의 <strong>전후 노드를 이어줌으로써</strong> 구현한다. 삭제는 인덱스가 유효한 경우에 맨 앞, 맨 뒤, 나머지의 3가지 경우가 있을 수 있다.</p>\n<ol>\n<li>맨앞 삭제: 기존의 head가 가리키는 노드의 다음노드를 head가 가리키도록 한다. 또한 head가 가리키게 된 노드의 prev는 null로 해준다.</li>\n<li>맨뒤 삭제: 기존의 tail이 가리키는 노드의 이전노드를 tail이 가리키도록 한다. 또한 tail이 가리키게 된 노드의 next는 null로 해준다.</li>\n<li>나머지: i번째 노드에 접근하여 삽입의 역순과 같이 해주면 된다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> index <span class=\"token operator\">>=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Invalid Index'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//head 삭제시</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//tail 삭제시</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  iterator<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n  iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>**탐색 **search(data) → index/-1</p>\n<p>위의 find와 마찬가지로 iterator를 지정해주고, data를 비교하며 탐색한다. 만약 tail까지 탐색했는데 원하는 data가 없는 경우, -1을 return하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span>data <span class=\"token operator\">===</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      count <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>isEmpty</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>출력</p>\n<p>배열과 다르게 직접 구현하여 내장된 출력함수가 없으므로, 출력에 대한 함수를 만들어줘야한다. 각 노드가 담고 있는 데이터를 담도록 하였다. (<code class=\"language-text\">process.stdout.write</code>함수를 사용한 이유는 개행없이 연결리스트를 출력하기 위해서이다)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">printFromHead</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pointer <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'head'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> ↔ </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pointer<span class=\"token punctuation\">.</span>data<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pointer<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      pointer <span class=\"token operator\">=</span> pointer<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> ↔ tail</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<p>링크드리스트의 구현은 헷갈리는 부분이 있을 수 있지만, 한번 그려보면 이해하고 바로 구현하기 어렵지 않다. 과거 tmp를 두고 a와 b를 swap했던 기억을 떠올리며 <strong>prev와 next가 교차되면서 헷갈리지 않도록 주의</strong>하자!</p>\n<p>전체 코드와 예제는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS02_DoublyLinkedList.js\">깃허브</a>에 올려놨으니 참고하면 된다.</p>\n<h1 id=\"linkedlist-성능-분석\" style=\"position:relative;\"><a href=\"#linkedlist-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D\" aria-label=\"linkedlist 성능 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 성능 분석</h1>\n<h2 id=\"시간복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도</h2>\n<ul>\n<li>\n<p>접근</p>\n<p><code class=\"language-text\">get(index)</code> 를 보면 index 번째 노드에 접근하기 위해 head 노드부터 차례로 next node로 iterator가 이동하는 것을 볼 수 있다. 이는 <code class=\"language-text\">O(n)</code>의 시간이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>탐색</p>\n<p>탐색 역시 head node부터 선형탐색을 진행하므로 <code class=\"language-text\">O(n)</code>의 시간이 걸린다.</p>\n</li>\n<li>\n<p>삽입</p>\n<p><code class=\"language-text\">insert(index, new_node)</code>함수를 보면 접근 이후에 실제 삽입을 한다. 삽입 자체는 연결리스트의 크기와 상관없이 상수시간에 해결 가능하지만, 접근이 O(n)만큼 걸리므로 삽입의 시간복잡도는 <code class=\"language-text\">O(n)</code>이라고 볼 수 있다. 하지만, 맨 뒤에 삽입하는 <code class=\"language-text\">append(new_node)</code>나 맨 앞에 삽입하는 <code class=\"language-text\">unshift(new_node)</code>의 경우에는 크기와 상관없이 일정한 시간에 가능하므로<code class=\"language-text\">O(1)</code>이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p><code class=\"language-text\">remove(index)</code>함수와 같이 접근 이후에 실제 삭제를 한다. 따라서 위와 같이 <code class=\"language-text\">O(n)</code>의 시간이 걸린다고 볼 수 있다. 하지만 맨 앞과 끝 노드를 삭제할 경우에는 일정한 시간 <code class=\"language-text\">O(1)</code>에 끝낼 수 있다고 볼 수 있다.</p>\n</li>\n</ul>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>\n<p>새로운 elements를 삽입, 삭제 시 용이하다. **전통적인 배열(js array와 다름)**에서는 원소를 추가하는 경우 resize의 과정이 추가적으로 존재하는데, 연결리스트는 이가 불필요하다. 데이터가 메모리상에 연속적으로 저장된 것이 아니라, 연속적인 데이터를 담고 있는 노드가 메모리 공간에서 서로를 참조하고 있기 때문이다.</p>\n</li>\n<li>\n<p>양 끝에 삽입하거나 삭제하는 경우에 head나 tail을 field로 갖고 있으므로 <code class=\"language-text\">O(1)</code>의 시간복잡도로 해결가능하므로 빠르게 처리할 수 있다. (정적 배열의 경우 꽉차 있으면 resize가 필요하므로 <code class=\"language-text\">O(n)</code>이 걸릴 수도 있음)</p>\n</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>접근시, 배열은 <code class=\"language-text\">O(1)</code>에 바로 접근할 수 있지만, 연결리스트는 head부터 가야하므로 시간이 많이 걸린다.</li>\n<li>같은 데이터를 저장할 때 앞뒤 노드의 참조를 갖고 있으므로 메모리를 비교적 많이 차지하게 된다. (더 큰 공간복잡도)</li>\n</ul>\n<p>데이터의 접근은 배열이 <code class=\"language-text\">O(1)</code>으로 빠르지만, 삽입 삭제는 대체적으로 연결리스트가 빠르다고 볼 수 있을 것 같다.</p>\n<h1 id=\"linkedlist의-종류와-비교\" style=\"position:relative;\"><a href=\"#linkedlist%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%B9%84%EA%B5%90\" aria-label=\"linkedlist의 종류와 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList의 종류와 비교</h1>\n<p><strong>다음 노드만 가리키는</strong> 링크드 리스트를 simple linked list(단순연결리스트)라고 하며 한 노드가 이전노드와 다음노드를 가리키는 것을 double linked list(이중연결리스트)라고 한다. 또한, 모양에 따라 <strong>가장 마지막 노드가 제일 처음 노드를 가리키는 형태</strong>를 circular linked list(원형 연결 리스트)라고 한다. 여기서는 이중연결리스트로 구현했다고 볼 수 있다. 각 연결리스트의 특징은 다음과 같다고 생각해볼 수 있다.</p>\n<ul>\n<li>단일연결리스트</li>\n</ul>\n<p>​\t위의 코드와 다르게 prev없이 next만 존재. 공간복잡도, 코드량이 적은 대신 앞 노드로 접근이 안된다.</p>\n<ul>\n<li>이중연결리스트</li>\n</ul>\n<p>​\t한 노드 기준으로 앞 뒤 노드 모두 접근이 바로 가능하다. 그대신 공간 복잡도와 코드량이 늘어난다.</p>\n<ul>\n<li>원형연결리스트</li>\n</ul>\n<p>​\t보통 next만 갖고 있으며 tail이 head를 바로 가리키므로, head를 굳이 갖고 있지 않아도 된다. 단일연결리스트의 개선안이라고 생각하면 될 것 같다.</p>\n<p>저번 포스트에도 얘기했지만, JavaScript에서는 사실상 연결리스트를 따로 사용할 일이 없다. 왜냐하면 Array에 모든 것이 최적의 시간복잡도로 구현되어 있기 때문이다. 이는 이후에 공부할 스택, 큐 등에도 해당하는 내용이다. 하지만, 배열과 다른 연결리스트의 관점을 파악하는 것이 이번 자료구조의 목적이므로 앞으로도 다양한 자료구조를 공부해볼 것이다.</p>","excerpt":"LinkedList란 LinkedList(연결리스트)는 리스트라는 추상자료형을 구현하는 선형 자료구조 중 하나로, 끼리 참조를 통하여 연결되어 선형적인 형태를 이루고 있는 자료구조이다. Array는 크기가 정해져 있고 메모리에서 연속적으로 존재하였지만, 링크드 리스트는 각 노드에 데이터가 저장되어 있으며 이웃한 노드의 정보(주소)를 가리키고 있는 형태로 여러 데이터를 저장한다.  간단하게 위의 그림으로 Array와 LinkedList를 비교해볼 수 있다. 연결리스트에서는 데이터가 노드에 저장되며, 노드끼리의 연결관계가 존재한다. 또한 head와 tail은 각각 처음과 마지막 노드를 가리키고 있어 모든 노드에 접근할 수 있게 되는 것이다. 따라서 각 노드는 메모리상에서 연속적으로 존재할 필요가 없으며, 데이터의 자료형이 같을 필요도 없을 것이다. LinkedList 구현 요구 사항 LinkedList에서는 배열과 다르게 데이터를 에서 갖고 있도록 한다. 노드는 데이터를 갖고 있으며,…","frontmatter":{"date":"October 04, 2021","title":"(자료구조 JS) LinkedList","categories":"Alg","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/DS02-LinkedList/"}},"next":{"id":"85417fbe-3e19-5b0b-a846-28bfdfe681cb","html":"<h1 id=\"언어마다-다른-자료구조\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%96%B4%EB%A7%88%EB%8B%A4-%EB%8B%A4%EB%A5%B8-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"언어마다 다른 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언어마다 다른 자료구조</h1>\n<p>JavaScript의 Array의 MDN 설명을 보면 다음과 같다.</p>\n<blockquote>\n<p>배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체입니다. JavaScript에서 배열의 길이와 요소의 자료형은 고정되어 있지 않습니다. 배열의 길이가 언제든지 늘어나거나 줄어들 수 있기 때문에 JavaScript 배열들은 밀집도가 보장되지 않습니다.</p>\n</blockquote>\n<p>JS의 Array는 key가 int type index인 <code class=\"language-text\">특수한 Object</code>이다. 배열은 length라는 특별한 프로퍼티를 갖고 있으며, 이와 관련된 함수가 제공된다. 배열의 길이는 정해져 있지 않으며 각 원소의 크기 또한 정해져 있지 않다. 메모리상에서 연속된 형식으로 저장되어 있다고 보장을 못하는 <code class=\"language-text\">sparse array</code>이다.</p>\n<p>C, Java의 Array는 크기와 타입이 정해져 있는 **정적배열(static array)**이다. 따라서 선언시에 메모리 공간이 할당되며 모든 원소의 타입이 고정되어 있다. 크기가 정해져 있으므로 요소의 삽입과 삭제가 불가능하다. 또한 메모리 공간에서 연속적인 공간을 차지하고 있는 <code class=\"language-text\">dense array</code>이다.</p>\n<p>언어마다 자료구조는 다른 방법으로 구현되어 있을 수 있다. 오늘은 자바스크립트 array를 이용하여 ArrayList 자료구조를 직접 구현해보고, 언어의 특수성으로 인한 차이점들을 공부해볼 것이다.</p>\n<h1 id=\"arraylist-구현-요구-사항\" style=\"position:relative;\"><a href=\"#arraylist-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"arraylist 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList 구현 요구 사항</h1>\n<p>ArrayList는 배열이므로 인덱스를 통하여 요소에 접근(access)한다. 각 요소는 연속된 인덱스에 1대1로 할당되어 있다는 자료구조적 특이성을 갖고 있다. JS의 array는 이미 모든 것이 구현되어 있지만, 직접 ArrayList 자료구조의 요구사항을 파악해보며 구현을 해보도록 하자. (자바스크립트에는 타입이 고정되어 있는 <code class=\"language-text\">TypedArray</code>가 별개로 제공되지만, 기능적인 면이 중요하므로 이로 구현하지는 않겠다)</p>\n<p>ArrayList의 class property로는 요소들의 **배열(list)과 길이(length)**를 갖고 있으면 될 것이다. 함수 프로퍼티로는 다음이 있으면 될 것 같다.</p>\n<ol>\n<li>\n<p><strong>접근</strong> get(index) → element</p>\n<p>index번째 요소(element)를 return한다. index가 유효하지 않은 경우에는 -1을 return</p>\n<p>배열에서의 index 접근방법을 사용한다. 이는 대략 <code class=\"language-text\">O(1)</code>이 걸린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> index <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">?</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>set(index, element)</p>\n<p>index번째 요소를 element로 set한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>추가</strong> append(element)</p>\n<p>ArrayList 제일 뒤에 element를 추가해주고 length를 1 늘려준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삽입</strong> insert(index, element)</p>\n<p>index 바로 뒤에 element를 삽입한다. index가 유효하지 않은 경우 -1을 return</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index<span class=\"token punctuation\">,</span> obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> index <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Invalid index'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>unshift(element)</p>\n<p>insert함수로는 맨 앞에 요소를 삽입하지 못하므로 필요하다. element를 맨 앞에 삽입한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삭제</strong> remove(index) → element</p>\n<p>index번째 element를 삽입하고 성공하면 return한다.  index가 유효하지 않은 경우 -1을 return</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> index <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Invalid index'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>탐색</strong> search(element) → index OR -1</p>\n<p>배열에서 element의 위치를 반환한다. 만약에 없다면 -1을 리턴한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">//return this.list.indexOf(obj)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>isEmpty() → boolean</p>\n<p>배열이 비어있다면(length===0) true를 리턴한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<p>이외에도 기본적인 Constructor 함수가 있으면 좋을 것 같다.</p>\n<p>최종 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS01_ArrayList.js\">깃허브</a>에 올려놓았으니 참고하면 된다.</p>\n<h1 id=\"js-배열의-특이성\" style=\"position:relative;\"><a href=\"#js-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8A%B9%EC%9D%B4%EC%84%B1\" aria-label=\"js 배열의 특이성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 배열의 특이성</h1>\n<p>위에서 말했다시피 JS 배열은 참조타입의 Object이고, 이는 <code class=\"language-text\">{\"key\": value}</code>의 쌍으로 이루어져 있고 <code class=\"language-text\">Hash Table</code>로 구현되어 있다. 따라서 search는 <strong>위와 같이 선형적으로 구현할 필요는 없다</strong>. Hash Table에서 탐색은 최대 <code class=\"language-text\">O(1)</code>정도로 해결가능하기 때문이다. 따라서 indexOf 함수를 사용하면 더 빠른 속도로 탐색이 가능할 것이다. JS 배열은 객체이므로 index로 접근할때 원래 배열보다 조금 느릴 수 있다. 하지만, 삽입, 삭제하는 경우에는 배열보다 빠른 성능을 기대할 수 있다.</p>\n<p>또한 JS는 기본적으로 동적배열이므로 요소를 추가(append)할 때 추가적인 연산에 대하여 개발자는 고려하지 않아도 된다. 처음부터 배열의 크기는 일정부분 잡혀있을 것이고, 요소가 추가됨에 따라 배열의 크기가 조절되는 것은 자바스크립트 엔진의 몫이다. 하지만 정적배열이 제공되는 언어에서는 동적배열처럼 배열에 요소를 추가할 때 다음과 같은 요소를 고려할 필요가 있다.</p>\n<h3 id=\"동적배열에서-resize가-필요한-경우\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%A0%81%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-resize%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-label=\"동적배열에서 resize가 필요한 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동적배열에서 resize가 필요한 경우</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVQoz32R207CQBCG+wxCtUcK2AO2BRqWbY1CsAev5JpXEmlJ1ER9T3mA38yWQr2hybcznezO/ju/ZBomembvhNWzBMPBEK7jwrEd9K2+gOq0xzTOtM9SL4kSQzdEQdd0XMsyNFWDqqhQbhRB8y93ZQwsE8WjhwV3sEpc2EMLum6gESZRsyiKMA7HSJ9SfH/9YF/tUZV7bF+32L2VqMoKH++fKHcVYn4Pzjj4nIEzBjabgc0YomlUN6RluVjCv/Ox2Wxw6Tv8HpAun/EQr5AkMZI4+QeNRSKpI28E+9bGnM2xflmLC4o8R57lKPLiFLM0Q+AHCHwfYRAe80DkJEgobN5OkmPOMZ1M4LmemF3nqoNup9uinq+m6sd4huYvTKGF3GtuCoM6kstUbxxuu3yJPzL955Lvnj1oAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"정적배열\"\n        title=\"정적배열\"\n        src=\"/static/b8f9695ab3d3734a0b74d4adc54b0460/37523/StaticArray.png\"\n        srcset=\"/static/b8f9695ab3d3734a0b74d4adc54b0460/e9ff0/StaticArray.png 180w,\n/static/b8f9695ab3d3734a0b74d4adc54b0460/f21e7/StaticArray.png 360w,\n/static/b8f9695ab3d3734a0b74d4adc54b0460/37523/StaticArray.png 720w,\n/static/b8f9695ab3d3734a0b74d4adc54b0460/73fd0/StaticArray.png 793w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>C나 Java에서는 배열을 정의할 때, <code class=\"language-text\">int DynamicArray[4]</code>와 같이 배열의 크기를 미리 선언한다. 이는 컴파일러가 4칸만큼의 정수자료형이 들어올 만큼의 연속공간을 확보하는 계기가 된다. 하지만, 4칸이 다 차게 된다면 더이상 추가할 수 없다. 동적배열에서는 실제 배열의 크기보다 더 많은 공간을 확보함으로써 요소의 추가가 가능해지는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABFUlEQVQY03WQ207CQBRF+wUWHiyxFyxCxJbY+21IhRL5OSNISz+SqPFRW5C6zRkNwRgeVmbmnJk9+2yhq3WhKiqkcwkdqcP3hKZq0C/1fwz6A/T03uFMd+ULGYqsgLQEeti/6mOWzTC/nyObTpFlGSZ3E4zZ+BfGV8YYTMOEbdlwbIfjez4818PweshNCKQcRzGeN69AA9QfW1TEe4397gv7zwZ1tcWuavCyeUOapnAdl0NituUgjhIEfvAjSGOOzBGWiyVWTznyVY51UaLIC5TrkkN7qj0+LBAG4UGQnJFbErNuLT6+YNwYSOKEFygD+kA8E9FutdESW3+gGrk4Bc+QcmAJ46JRGPGMqHEc/DHUOwWN/A2o8NFsrxge6wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"동적배열\"\n        title=\"동적배열\"\n        src=\"/static/e34d66fa67010419195ffc3ba9355dad/37523/DynamicArray.png\"\n        srcset=\"/static/e34d66fa67010419195ffc3ba9355dad/e9ff0/DynamicArray.png 180w,\n/static/e34d66fa67010419195ffc3ba9355dad/f21e7/DynamicArray.png 360w,\n/static/e34d66fa67010419195ffc3ba9355dad/37523/DynamicArray.png 720w,\n/static/e34d66fa67010419195ffc3ba9355dad/fd28b/DynamicArray.png 811w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하지만, 동적배열에서 무조건 많은 공간만을 확보하는 것은 공간의 낭비가 커질 수 있으므로 적당한 공간확보가 공간복잡도, 즉 성능을 결정하게 된다. 또한, 남는 공간이 없을때 추가하고 싶은 경우, <strong>새로운 공간에서 더 커진 배열만큼의 메모리 공간을 확보하고 기존의 데이터를 복사해가는 작업</strong>이 필요하다. 이를 <strong>resize</strong>라고 한다! resize는 <code class=\"language-text\">동적배열에서 남는 공간이 부족할 때</code> 일어나게 된다.</p>\n<p>얼만큼의 더 커진 공간을 확보하느냐는 여러가지 방법이 있는데, 대표적으로 <code class=\"language-text\">doubling strategy</code>가 있다. 두배씩 늘려가며 공간을 확보하는 것이다. 예를 들어 크기가 4인 배열이 다 찼다면, resize가 일어날텐데 이때는 4*2=8만큼의 공간을 확보하여 기존의 데이터를 옮기면 된다. 이러한 전략으로 동적배열에서 추가, 삽입 등이 일어날 수 있다. 이에 대한 시간복잡도는 <code class=\"language-text\">Amortized Analysis</code>를 이용하여 계산하는데 이를 따로 계산하지는 않겠다.</p>\n<p>또한 자바스크립트의 배열은 모든 기능이 이미 구현되어 있다. 또한, 앞으로 배울 다양한 선형자료구조에 대하여 <strong>거의 모든 기능이 구현되어 있으니</strong> 따로 사용할 일은 없을 것이다!</p>\n<h3 id=\"번외-list와-array의-차이점\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8-list%EC%99%80-array%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"번외 list와 array의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외) List와 Array의 차이점</h3>\n<p>자꾸 List와 Array에 대해 얘기하다 보니 헷갈리게 되었다. 언어마다 이를 해석하는 것도 약간 다를 수 있겠지만, 찾아보니 List는 연속적인 요소(element) 여러개를 담을 수 있는 <code class=\"language-text\">추상자료형</code>이고 Array는 인덱스를 통해 메모리상에 연속적으로 저장되어 있는 <code class=\"language-text\">자료구조</code>이다. List는 구현된 것이 아닌 interface만을 명시하고 있으며, 이를 구현한 것이 우리가 알고 있는 <code class=\"language-text\">ArrayList</code>, <code class=\"language-text\">LinkedList</code>등으로 생각하면 될 것같다. 반면에 Array는 자료구조이며 웬만한 언어에 내부적으로 <code class=\"language-text\">[ ]</code> 연산자를 이용하여 이미 구현되어 있다. 다음에는 list를 구현하는 다른 방법인 <code class=\"language-text\">LinkedList</code>를 구현해보고 분석해보자.</p>","frontmatter":{"date":"September 12, 2021","title":"(자료구조 JS) ArrayList","categories":"Alg","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/DS01-ArrayList/"}},"prev":{"id":"1f5b55d1-79b3-570b-83ef-83ed55f01a39","html":"<p>추상자료형에 대하여 공부해보고, stack과 queue에 대하여 알아보자.</p>\n<h1 id=\"abstract-data-typeadt-추상자료형\" style=\"position:relative;\"><a href=\"#abstract-data-typeadt-%EC%B6%94%EC%83%81%EC%9E%90%EB%A3%8C%ED%98%95\" aria-label=\"abstract data typeadt 추상자료형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Abstract Data Type(ADT, 추상자료형)</h1>\n<p>스택은<code class=\"language-text\"> 추상자료형</code>이다. 추상자료형은 자료구조를 추상화한 것으로, 구현보다는 기능에만 초점을 맞춘다. <code class=\"language-text\">OOP</code>를 배울 때 <code class=\"language-text\">추상클래스</code>에 대하여 배운 적이 있을텐데, 이는 실제 구현된 것이 아니고 기능에 대한 메서드만 명시되어 있다. 이를 implement한 클래스가 정해놓은 기능을 구현하는 방식으로 되어있다. <strong>list, set, dictionary, stack, queue는 모두 추상자료형</strong>으로 정해진 기능만을 담고 있으며 다양한 방법으로 구현될 수 있다. 예를 들어 스택은 다양하게 구현할 수 있지만, 우리는 array를 이용하여 직접 구현해볼 것이다.</p>\n<h1 id=\"stack이란\" style=\"position:relative;\"><a href=\"#stack%EC%9D%B4%EB%9E%80\" aria-label=\"stack이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack이란</h1>\n<p>Stack(스택)은 <strong>메모리의 끝에서만 operation이 이루어지는 선형 자료구조</strong>로, 차곡차곡 쌓아올린 형태를 생각하면 이해하기 편하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHcglYAAH//xAAWEAADAAAAAAAAAAAAAAAAAAABECD/2gAIAQEAAQUCZr//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAbEAACAQUAAAAAAAAAAAAAAAABEQAQICFRcf/aAAgBAQABPyEtYhOqdXf/2gAMAwEAAgADAAAAEO/w/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAdEAEAAgICAwAAAAAAAAAAAAABEVEAECFBYXGR/9oACAEBAAE/EGOEXziwcV0GJEHZeV7L3BR81//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"stack\"\n        title=\"stack\"\n        src=\"/static/7531b36b214020cd0a879c6d9da17269/80e3c/stack_1.jpg\"\n        srcset=\"/static/7531b36b214020cd0a879c6d9da17269/4ec73/stack_1.jpg 180w,\n/static/7531b36b214020cd0a879c6d9da17269/158ba/stack_1.jpg 360w,\n/static/7531b36b214020cd0a879c6d9da17269/80e3c/stack_1.jpg 720w,\n/static/7531b36b214020cd0a879c6d9da17269/d6fb3/stack_1.jpg 1073w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>(물론 메모리가 저렇게 생기지는 않았을 것이다. 단지 스택을 그릴때 저렇게 표현한다고 생각하자.)</p>\n<p>그림과 같이 끝부분만 열려있는 배열과 같고, <code class=\"language-text\">LIFO(Last In First Out)</code>방식(후입선출)이라고 알고 있으면 외우기 쉽다. 지금 내가 있는 소방조직에는 티셔츠에 First In Last Out이라고 써있는 것들이 많은데, 이것도 stack이라고 볼 수 있다!! 스택의 이러한 특성은 항상 같이 언급되는 <code class=\"language-text\">Queue</code>(큐)와 대조적인데, 큐는 앞부분만 열려있으며 <code class=\"language-text\">FIFO(First In First Out)</code>의 방식이다.</p>\n<h1 id=\"stack-구현-요구-사항\" style=\"position:relative;\"><a href=\"#stack-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"stack 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 구현 요구 사항</h1>\n<p>JS Array는 stack과 queue의 모든 기능이 이미 구현되어있으므로 여기서는 배열을 이용하여 stack을 구현해보도록 하겠다. 선형구조이므로 <strong>head없이 tail만 있는 linkedlist로도 스택의 기능을 구현할 수 있다</strong>!</p>\n<p>Stack은 데이터의 순서 관계가 항상 유지되므로 배열로 구현할 것이며, (유일하게 신경쓰는)맨 끝의 원소의 인덱스(즉 스택의 높이라고도 볼 수 있다)를 갖는 <strong>top</strong>과 데이터를 담을 공간인 list를 갖고 있는다.</p>\n<ol>\n<li>\n<p>맨 끝에 원소 삽입(push)</p>\n<p>배열의 맨 끝에 원소를 추가하고, top을 1 증가시킨다. 정적배열로 구현하였다면 정해진 크기 이상이 push가 되었을 때, <code class=\"language-text\">stack overflow</code>(우리가 아는 그거 맞다)가 발생한다. 하지만 js array는 내부적으로 배열의 크기를 조정하므로 overflow가 발생할 일은 없다. 하지만 정적배열을 지원하는 C나 Java와 같은 것으로 stack을 구현하였다면, stack overflow에 대한 처리 또한 해줘야 한다. js에서 size_max와 같이 <u>배열 크기의 한계를 둬서 overflow를 보여줄 수도 있을 것 같다</u>. 근데 그러지는 않았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">push</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">element</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>맨 끝의 원소 삭제(pop)</p>\n<p>배열의 맨 끝 원소를 삭제하고 top을 1 감소시킨다. 만약 top이 0이라면(더 이상 삭제할 원소 없음) <code class=\"language-text\">stack underflow</code>오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">pop</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//빈 stack pop한 경우</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Stack Underflow'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//원소 있을때 pop한 경우</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>모든 원소 출력</p>\n<p>현재 스택의 상태를 보기 위하여 print함수를 추가적으로 만들어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">print</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">| </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> |</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">‾‾‾‾‾</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>isEmpty</p>\n<p>top이 0이면 비어있으므로 true를 return한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">isEmpty</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>전체 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS03_Stack.js\">깃허브에</a> 올려놓았으니 참고하도록 하자.</p>\n</li>\n</ol>\n<h1 id=\"stack-성능-분석\" style=\"position:relative;\"><a href=\"#stack-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D\" aria-label=\"stack 성능 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 성능 분석</h1>\n<h2 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h2>\n<ul>\n<li>\n<p>접근</p>\n<p>맨 위의 <strong>top element만 접근이 가능</strong>하다!</p>\n</li>\n<li>\n<p>탐색</p>\n<p>여기서는 배열로 구현하였기에 인덱스로 접근이 가능하고 탐색 또한 가능하지만, stack은 원래 탐색을 하려면 모든 원소를 pop해보면서 확인해야한다. 굳이 시간복잡도를 따지자면 <code class=\"language-text\">O(n)</code>이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>삽입</p>\n<p>맨 뒤에 삽입하는 것만 가능하며, 일반적으로 스택의 크기와 상관없이 <code class=\"language-text\">O(1)</code>로 가능하다. 정적배열로 구현하였을 경우, resize가 일어날 경우에는 <code class=\"language-text\">O(n)</code>이 걸리겠지만 분할상환분석을 하면 <code class=\"language-text\">O(1)</code>이라고 말할 수 있다. 연결리스트로 구현하였을 때도 상수시간에 가능하다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p>맨 뒤를 삭제하는 것만 가능하며 역시 <code class=\"language-text\">O(1)</code>로 가능하다. 연결리스트로 구현하였을 때도 상수시간에 가능하다.</p>\n</li>\n</ul>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<ul>\n<li>장점</li>\n</ul>\n<p>데이터의 삽입과 삭제가 <code class=\"language-text\">O(1)</code>로 빠르며 다른 선형구조(연결리스트 등)에 비해 가벼운 편이다.</p>\n<ul>\n<li>단점</li>\n</ul>\n<p>탐색이 불가능하다. 맨 위의 원소만 접근 가능하다.</p>\n<h1 id=\"stack-응용\" style=\"position:relative;\"><a href=\"#stack-%EC%9D%91%EC%9A%A9\" aria-label=\"stack 응용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 응용</h1>\n<p>스택은 뒤로가기, 실행 취소와 같이 <strong>가장 최근 것만 필요한 상황에서 자주 사용</strong>된다. 또 다른 예시로는 다항식을 계산하기 위한 <code class=\"language-text\">후위표기식</code> (postfix)에도 활용이 된다. 이는 매우 유용한데, 나중에 다룰 기회가 있다면 직접 구현해보도록 하겠다.</p>\n<h1 id=\"queue란\" style=\"position:relative;\"><a href=\"#queue%EB%9E%80\" aria-label=\"queue란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue란</h1>\n<p>Queue(큐)는 <strong>메모리의 끝에서 들어오고 메모리의 시작부분에서 들어오는 선형 자료구조</strong>이다. 양쪽이 열려있는 파이프관을 생각할 수 있겠다. <code class=\"language-text\">Queue</code>는 가장 먼저 들어온 데이터가 가장 먼저 나오는 <code class=\"language-text\">FIFO</code>(First In First Out, 선입선출)방식으로 스택과 대조된다. <u>게임할 때 큐가 잡혔다고 하는데 이게 그 큐가 맞다</u>. 게임사의 알고리즘에 의하여 우선순위가 생기게 되며 대기하게 되는데, 이게 조건이 맞아 게임이 성사될때마다 우선순위 순으로 대기열에서 나가게 되는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAdsSoH//xAAWEAADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCIv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFRMf/aAAgBAQABPyGHpLRcuz//2gAMAwEAAgADAAAAEPw//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRABAQEAAwAAAAAAAAAAAAAAAREAIVHh/9oACAEBAAE/EFlnncmBIVdyb//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"queue\"\n        title=\"queue\"\n        src=\"/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/80e3c/queue_1.jpg\"\n        srcset=\"/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/4ec73/queue_1.jpg 180w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/158ba/queue_1.jpg 360w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/80e3c/queue_1.jpg 720w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/47311/queue_1.jpg 1080w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/eea4a/queue_1.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>큐에서는 맨 뒤에 들어오는 것을 <code class=\"language-text\">enqueue</code>, 맨 앞이 나가는 것을 <code class=\"language-text\">dequeue</code>라고 한다. 통용되는 말이 스택과 약간 다르므로(push, pop) 참고하자.</p>\n<h1 id=\"queue의-기능\" style=\"position:relative;\"><a href=\"#queue%EC%9D%98-%EA%B8%B0%EB%8A%A5\" aria-label=\"queue의 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue의 기능</h1>\n<ol>\n<li>\n<p><code class=\"language-text\">Enqueue</code> : 맨 끝에 원소 삽입</p>\n<p>stack의 push와 비슷하다고 볼 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Dequeue</code> : 맨 앞의 원소 삭제하고 나머지 원소 앞으로 옮기기</p>\n<p>맨 앞 원소를 삭제하며 return하고, 나머지 원소들을 모두 한 칸씩 앞으로 옮겨야 한다. js에서는 <code class=\"language-text\">shift</code>함수를 이용하여 간단하게 구현할 수 있다.</p>\n</li>\n</ol>\n<p>큐는 스택과 마찬가지로 <strong>배열과 링크드리스트로 구현가능</strong>하다.</p>\n<h1 id=\"queue-시간-복잡도\" style=\"position:relative;\"><a href=\"#queue-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"queue 시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue 시간 복잡도</h1>\n<ul>\n<li>\n<p>삽입</p>\n<p>스택의 push와 같은 시간복잡도를 지닌다. 배열, 연결리스트 모두 <code class=\"language-text\">O(1)</code>로 삽입이 가능하다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p>맨 앞 원소를 삭제하고 나머지 원소를 <code class=\"language-text\">shift</code>해야하므로 배열로 구현시 <code class=\"language-text\">O(n)</code>의 시간복잡도를 갖는다. 연결리스트로 구현할 경우 단순히 head의 위치만 조정해주면 되므로 원소의 갯수와 관계없이 <code class=\"language-text\">O(1)</code>로 가능하다.</p>\n</li>\n</ul>\n<h1 id=\"queue의-응용\" style=\"position:relative;\"><a href=\"#queue%EC%9D%98-%EC%9D%91%EC%9A%A9\" aria-label=\"queue의 응용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue의 응용</h1>\n<ul>\n<li>\n<p>대기열 등과 같이 정해진 순서대로 처리해야하는 일에 사용된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Priority Queue</code>(우선순위 큐)는 트리의 구조이며, FIFO가 아니라 정해진 우선순위(예를 들면 숫자 원소의 크기)에 따라 dequeue했을 때 나오게 되는 자료구조가 있다. 이는 나중에 <code class=\"language-text\">tree</code>를 배우며 구현해보도록 하자~</p>\n</li>\n</ul>","frontmatter":{"date":"October 09, 2021","title":"(자료구조 JS)ADT 추상자료형 - Stack & Queue","categories":"Alg","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/DS03-ADT/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/DS02-LinkedList/","nextSlug":"/DS01-ArrayList/","prevSlug":"/DS03-ADT/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}