{"componentChunkName":"component---src-templates-blog-template-js","path":"/OS(1)-computer-architecture/","result":{"data":{"cur":{"id":"84137e27-ee51-5a2b-8271-d1e61c57eda6","html":"<p>운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자!</p>\n<h1 id=\"von-neumann-architecture\" style=\"position:relative;\"><a href=\"#von-neumann-architecture\" aria-label=\"von neumann architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Von Neumann Architecture</h1>\n<blockquote>\n<p>폰 노이만 구조</p>\n</blockquote>\n<p>컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 <code class=\"language-text\">CPU</code>로부터 <strong>fetch, decode, execute, writeback의 과정</strong>을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 <code class=\"language-text\">Memory</code>에 올라가(load)있어야하며, CPU는 <code class=\"language-text\">Program Counter</code> 레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다.</p>\n<p>이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 <code class=\"language-text\">폰 노이만 구조</code>라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 <u>실행하기 위해서는 메모리에 로드가 되어야 한다</u>는 것을 알 필요가 있다.</p>\n<h1 id=\"cpu\" style=\"position:relative;\"><a href=\"#cpu\" aria-label=\"cpu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU</h1>\n<blockquote>\n<p>Central Processing Unit</p>\n<p>중앙 처리 장치</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACCklEQVQoz5XPz2/SYBgH8P1LXjTxNg56NzFedZId8EcwWyjOaKLBZByMB9Q5tBFNxLk0HY65EUfbrGMrIOOXRJK+Rmgrc5SkIO8ovwrPAkUjGo1+8+TJN0/ez+GdgD9n89X7NVJYI4VoKMdRSbOLaeXHg4m/YDEtSXlVyquKqKJU6cN2Qcqr+8XyP2FJkqI70UwyU6/XVeWb/aQ3vi5ijH/F1WoVY6xpGh6mVqsBAPM6OTtJzk6SaeZTqVq+fspHzoVKeqkF7TGsVWryRxVjXPlSl/JqWamY2GEhHRZyL4xeaktzp589vbGeaCRYYMew7bjn6olF17mlO2f8l44t3D774mecDKM3yobDQmbDGYyxALExvECseOy0x04/uDYo/nvhwZ/zhbeh4OYGpxUOuBaPC6newd5vuGcMVjzJAx+DmBGL9/YTAFBTFebrE0ZexkhkmwwuRA4R12g0BnhIBtjI+oxdd9s3w+dskezl5vOZbuy+Ia50U14+NcXz59urN/mcrbN1qxNxdQT3Tu6KkfWNcA8hEJERCAoyJciUEQj2Pxf7RamHkCBTkZTX2I4IMgUiMmfUTdxkOZ0K6BTNsvMsO69TgdY7ppvNtXaF7xfavOsUrVP0FutuM9wIP4ZFAhwEOKfAOt2fJsBJgNMP/rvgsoLVClYCHMPtNOcCXHwED0dY7x/Cf8YkR1CrjNHuddQ8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cpu_architecture\"\n        title=\"cpu_architecture\"\n        src=\"/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png\"\n        srcset=\"/static/c9124f66758e84c155c133f783a2c728/e9ff0/cpu_architecture.png 180w,\n/static/c9124f66758e84c155c133f783a2c728/f21e7/cpu_architecture.png 360w,\n/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png 720w,\n/static/c9124f66758e84c155c133f783a2c728/7527b/cpu_architecture.png 754w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>CPU는 명령어를 해석하고 실행하는 장치이며, 이를 수행하기 위해 많은 Unit들이 존재한다. 주요 구성은 다음과 같다.</p>\n<ul>\n<li>\n<p>Control Unit</p>\n<p>decoder를 통해 binary코드의 명령어를 해석하고, 이에 적절한 제어 신호(메모리에서 레지스터로 가져오기, 연산, 쓰기)를 발생시킨다. 또한, 명령어의 실행 순서를 결정한다.</p>\n</li>\n<li>\n<p>Arithmetic &#x26; Logic Unit(ALU)</p>\n<p>연산 명령에 대하여 연산을 수행한다. 모든 연산은 atomic하며, 산술연산(ex 덧셈)과 논리연산(ex AND)으로 구분되어 수행된다.</p>\n</li>\n<li>\n<p>Register</p>\n<p>CPU가 갖는 <u>임시 저장소</u>. 연산을 수행하거나, 명령어를 fetch하는 것들이 각각의 레지스터에서 일어난다. 다음 명령어의 위치를 가리키고 있는 <code class=\"language-text\">Program Counter</code>(PC), 데이터를 보관하기 위한 <code class=\"language-text\">Data Register</code>와 주소를 저장하기 위한 <code class=\"language-text\">Address Register</code>, 실행 중인 명령어를 가져오는 <code class=\"language-text\">Instruction Register</code>, 메모리에 저장하거나 가져올 때 사용하는 <code class=\"language-text\">Memory Address Register</code>, <code class=\"language-text\">Memory Buffer Register</code> 등이 있다.</p>\n</li>\n</ul>\n<p>CPU가 다른 기기들과 주고 받는 정보는 크게 3가지로 나눌 수 있다.</p>\n<ul>\n<li>Control</li>\n<li>Address</li>\n<li>Data</li>\n</ul>\n<p>따라서 이는 위의 그림처럼 각각의 역할을 수행하는 버스를 통하여 주변 장치와 연결을 한다.</p>\n<p>CPU는 한번에 처리할 수 있는 데이터의 크기에 따라 오늘날 32bit, 64bit 컴퓨터로 나뉜다. 32비트 주소 체계는 2^32개의 주소를 담을 수 있다. 메모리는 한 주소당 1Byte를 갖으므로 2^32Byte = 4GB 정도의 데이터를 가리킬 수 있는 것이다. 따라서 32비트 컴퓨터는 최근에 사용되지 않는다.</p>\n<h2 id=\"interrupt\" style=\"position:relative;\"><a href=\"#interrupt\" aria-label=\"interrupt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt</h2>\n<p>CPU는 매우 빠르다.! 하지만, 주변 장치의 증가로 매우 느린 I/O 작업이 늘어나게 되면서 기존의 polling 방식은 성능이 낮아졌다. 이는 CPU가 IO device의 상태를 주기적으로 검사하여 데이터를 처리하는 방식으로, CPU의 본래 역할(fetch, decode, execute)에 I/O까지 수행하게 되어 매우 느리다. I/O가 수행될때까지 기다려야하기 때문이다.</p>\n<p>Interrupt 방식은 IO작업을  CPU가 기다리지 않고 다른 곳(입출력 관리자)에 위임하고, 완료되면 Interrupt 신호를 발생시키는 것이다. CPU는 I/O가 수행되는 동안 다른 작업들을 수행하면 되고, interrupt가 발생하면 지금 하던 작업을 멈추고 가져와진 데이터로 작업을 이어가면 된다.</p>\n<h3 id=\"direct-memory-accessdma\" style=\"position:relative;\"><a href=\"#direct-memory-accessdma\" aria-label=\"direct memory accessdma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Direct Memory Access(DMA)</h3>\n<p>기본적으로 Memory에 대한 접근 권한은 CPU만 갖고 있다. 따라서 장치들이 interrupt를 발생시켜 CPU가 메모리에 작업을 하도록 전송할 것이지만, 이것은 느리다. 따라서 I/O 수행시 <strong>장치들이 직접 메모리에 접근할 수 있다면 CPU를 더 효율적으로 사용할 수 있을 것</strong>이다. <code class=\"language-text\">DMA Controller</code>에게 CPU가 메모리에 대한 정보를 제공하고, 입출력 장치와 메모리 간의 직접적인 연결을 수행할 수 있도록 한다.</p>\n<p>DMA를 통해 메모리를 관리한다면, 메모리 구조가 복잡해질 수 있다.(CPU가 사용하는 영역과 입출력 장치가 사용하는 영역들의 혼재) 따라서 메모리를 OS 영역, CPU 영역, 입출력 작업 영역 등으로 분리하여 관리하는 방법을 <code class=\"language-text\">MMIO</code> (Memory Mapped I/O) 기법이라고 한다.</p>\n<p>DMA를 통해 메모리에 접근하면 여러 장치들(CPU 포함)이 동시에 메모리에 접근하려는 순간이 생긴다. 이때, CPU의 작업속도가 훨씬 빠르므로 CPU가 메모리 접근 순서를 양보하는데, 이를 <code class=\"language-text\">cycle stealing</code> 이라고 한다.</p>\n<h2 id=\"parallel-processing\" style=\"position:relative;\"><a href=\"#parallel-processing\" aria-label=\"parallel processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Processing</h2>\n<p>CPU의 성능을 향상시키기 위해 CPU의 클럭을 높이거나, 캐시의 크기를 늘리는 방법이 가장 대표적이다. 하지만, 클럭을 높이면 저항이 많아져 발열이 증가하게 되므로 이러한 하드웨어적인 향상에는 비용등의 현실적인 제약이 있다. 따라서, <strong>CPU 코어를 여러개 두어 병렬적으로 처리</strong>하는 기법들이 소프트웨어적으로 고려되고 있다.</p>\n<p>CPU가 명령어를 실행하는 작업은 크게 (Fetch, Decode, Execute, Write)의 4개의 순서대로 별도의 위치에서 이루어진다. 이때, 한 코어에서 작업을 나누어 병렬로 처리하는 <code class=\"language-text\">Pipeline</code>기법이라고 하고, 여러 코어에서 동시에 작업을 수행하는 것을 <code class=\"language-text\">Super-scalar</code>기법이라고 한다.</p>\n<h1 id=\"memory\" style=\"position:relative;\"><a href=\"#memory\" aria-label=\"memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory</h1>\n<blockquote>\n<p>저장 장치</p>\n</blockquote>\n<p>폰노이만 구조에서, CPU는 명령어를 메모리에서부터 가져와서 실행한다. 메모리는 프로그램과 데이터를 저장하는 공간으로, R/W가 모두 가능한 RAM과 Read Only Memory인 ROM으로 구분된다.</p>\n<ul>\n<li>\n<p>RAM (Random Access Memory)</p>\n<p>주소를 통하여 메모리 공간에 접근하므로, 모든 공간에의 접근 시간이 동일하다. 램은 전력이 끊겼을 때 데이터가 지워지냐 여부에 따라, 휘발성과 비휘발성으로 나뉜다.</p>\n<ul>\n<li>\n<p>휘발성</p>\n<p>DRAM(일정 시간이 지나면 데이터가 사라져 주기적 재생 필요. 보통 우리가 <strong>주기억장치로 사용</strong>함. 시금치 램 같은 것들), SRAM(빠르고 안정적이지만 비싸서 <strong>캐시, 레지스터</strong> 등에 사용됨)</p>\n</li>\n<li>\n<p>비휘발성</p>\n<p>전원이 해제되어도 데이터가 사라지지 않지만, 속도가 느리고 비용이 비싸다. flash memory는 usb처럼 주변 장치로 사용되기도 하지만, 어느정도 사용횟수가 제한되어 있다. HDD와 SSD는 보조 기억장치로 많이 활용 된다. <u>보조 기억장치에는 OS를 포함한 프로그램, 각종 파일들을 저장</u>할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ROM (Read Only Memory)</p>\n<p>데이터를 보관할 수 있지만, 한번 저장하면 바꿀 수 없다. (CD-ROM 이라고 하는 이유!) 하지만 전력과 무관하게 데이터가 저장되므로, 메인보드의 BIOS(부팅시 초기화를 담당하는 프로그램) 등이 ROM으로 저장되어 있다. ROM은 보통 제조 과정에서 프로그래밍되어 고정되지만, 지우거나 쓸 수 있는 EPROM등도 존재하긴 하지만 많이 쓰이진 않는다.</p>\n</li>\n</ul>\n<h2 id=\"저장장치-계층-구조\" style=\"position:relative;\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"저장장치 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>저장장치 계층 구조</h2>\n<p>돈이 많다면 모든 저장장치를 속도가 빠른 캐시 메모리나 레지스터로 구성하겠지만, 현실적으로 불가능하다. 이에 컴퓨터는 보통 속도와 용량의 trade-off에 따라 적절하게 계층구조를 두고 구성되어 있다.</p>\n<ul>\n<li>register</li>\n<li>cache</li>\n<li>memory</li>\n<li>ssd/hdd</li>\n</ul>\n<p>계층을 두고 데이터를 관리하면 데이터가 중복되어 저장될텐데, <strong>일관성을 유지하는 것이 핵심</strong> 이라고 볼 수 있다. 따라서, 각 계층 간 데이터 이동에는 전략이 있으므로 참고한다. 보통 memory와 보조기억장치 간의 이동을 제외하고는 개발자가 관여할 수 없을 것이다.</p>\n<h2 id=\"부팅\" style=\"position:relative;\"><a href=\"#%EB%B6%80%ED%8C%85\" aria-label=\"부팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부팅</h2>\n<p>application은 운영체제에 의하여 메모리에 적재되어 실행된다. 운영체제도 프로그램인데, 어떻게 메모리에 올라갈까? 이는 <code class=\"language-text\">부팅</code>의 과정과 관련있다. 컴퓨터의 전원을 켜면 BIOS-ROM에 저장된 BIOS(Basic I/O System)프로그램이 실행된다.</p>\n<p>바이오스는 하드웨어를 점검하고(POST라고 함), 이상이 없다면 미리 설정된 부팅 순서에 따라 부트 장치(flash memory, HDD, SSD 등)를 선택한다.</p>\n<p>해당 부팅 장치에서 MBR(Master Boot Record) 또는 UEFI(Unified Extensible Firmware Interface) 로더가 로드된다. 이를 통하여 부팅 가능한 부트로더의 위치를 찾아서 실행된다.</p>\n<p>부트로더는 운영체제의 위치를 찾아 초기화하여 메모리에 올려서 실행되게 된다! 부팅 끝</p>","excerpt":"운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자! Von Neumann Architecture 폰 노이만 구조 컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 로부터 fetch, decode, execute, writeback의 과정을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 에 올라가(load)있어야하며, CPU는  레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다. 이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 실행하기 위해서는 메모리에 로드가 되어야 한다는 것을 알 필요가 있다. CPU Cent…","frontmatter":{"date":"June 27, 2023","title":"(OS) 운영체제 복습 [1. 컴퓨터 구조 skim]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(1)-computer-architecture/"}},"next":{"id":"2417c2da-54ea-589c-8580-8f3be2b8e4b0","html":"<h1 id=\"운영체제란\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80\" aria-label=\"운영체제란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제란?</h1>\n<blockquote>\n<p>OS</p>\n<p>Operating System</p>\n</blockquote>\n<p>운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..!</p>\n<p><strong>운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어</strong>이다.</p>\n<h3 id=\"운영체제는-자원을-어떻게-관리하고-보호할까\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B3%A0-%EB%B3%B4%ED%98%B8%ED%95%A0%EA%B9%8C\" aria-label=\"운영체제는 자원을 어떻게 관리하고 보호할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제는 자원을 어떻게 관리하고 보호할까?</h3>\n<p>OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 <strong>직접 접근할 수 없도록</strong> 한다. 이러한 자원에 접근할 수 있는 <code class=\"language-text\">interface</code>를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 <code class=\"language-text\">Virtualization</code>(가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다.</p>\n<p>자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 통해 엔진의 상태를 보는 것과 유사하다.</p>\n<p>따라서, 운영체제는 <strong>사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어</strong>라고 정의할 수 있다. OS의 목적이 이것이므로, 이를 위해 자원을 가상화하고, 인터페이스를 통하여 접근하도록 하고… 등으로 구성된 것이라고 보면 될 것 같다.</p>\n<h1 id=\"운영체제의-구성\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"운영체제의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 구성</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 135.55555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEHElEQVRIx42VW0xcVRSGv3MGZoCCtAgVKdIGxLYIQsdSwKHQ4aqUkhYU2oIlXrjaeqEMzB5EKqEasBo11YR4qYnGFxNNTGN8EuOLT76YmBpNfNTEl9YYEVM4y+wzezpTAk13sufszMz59lrrXxe4eaUBI0AvcBJ4ERgFugEFHAf6gWQ2XUrAPxI9J6dvAWaAF8xeMOBzwOvAeWAeSL018EeBMn0xPuBp4BljXQdQA7QBlUATEDaebAr0EVq2OfN7Mu+JvvkBsB4GTgBDYNWCdQjLbsCym7A8Ze57Qz/D0JWoQbFtgEdRMo6SQZRznFXxut/vDKYAfu64B0p6YG8PlJ2C6glYFHhLIHwdIvq5BsqJbpTTTUQ6mPyvnNByFd8IPP+nRuZh2UNM/JtGz1d3MvzrdoZ/yWPsai6fylYuShaTK9uZFg9qLWqhhjMjSYRXg8xKkHlpcPf7EmDoygkaXlvgI6nhggSZlkeYlRaU00b35RF6l07xknS570Zcl+0o8Oxf2cxIOzsbiihsbaX4SBsF9X3kB7rIKa3F8jwBVLlCiBunY0AE2E92SSYz0sCHxjo3js/+kcOr8pBRsd+o+A5wGtCwL4Hn8PjqsJNewfJ8jcd7Go/vKBn5dzMndYxdS4sLM3Y1izk5BOwiIz8Lyw5g2XX4MlPxeDNdgXZ3gmXrZN5mUiYTb3oxEyvasibUWlYcOCXZhK+30n4plkhJ5nkv0GDO9oYpp1VWThMRyYkDlZNDRFpYEGi9mJTw91zj8vqLoqvjY4+JWzPKyb4ZqKSFc7HEZKupVQ9QDGQAO4DOdQVhG0gjSu5KAEoUuHgDeNA0hHeBWeAz4AMjWNx9JZaB1KCkMJrYYsWBF24Ai4w1A0ApUA00a2nWWRgD+lGy15xvAFujN6ytD77fNIyNekAMWIaS8o2BEyv2OlV1DFM2B7puFqOkKhGY7QK1Yt2Xo0p6Uu7HTurFk7IPb/ou7ORGkrcUuL89+YPF+N9WgiiFKKk1Z1t/bENJkwtcE6gYxMRQN1Kd8GeARbet1U7DpYQyi+4dKAkkWOj4UNKJkjxCy7nMSwFdn9fz6BfN9C4F6f++nrFrfpRTypSUoBwtwB4Tu0qUPI6S/XGge5tThnIOu2UUXj3ItPhZkgIqBsbZfewNPpEiQsuVKEe/eADlHDDq3mc0sOJ5GDM/YnZ4FX4T6PtWu54DBKgOwXcC5wVmRbc8eNk85wS3Cz04atSKmIScEpvQPzbz2uxYsaXuwUo66Z5F4grHzgM/WdzGsky1BM2g0hVzBNgHpJtuYyeMUp0ZXnPO2gioa3cYqDAQnS7lZlY3m/GqL3obeNM02wngKWDwVsBuN37RwT8JHDYjNWA6eKMZr8Xmcp1i7RsBtUtngT4DGzVWPXY78foffO+o6MyDxioAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"os\" title=\"os\" src=\"/static/8899fcdb131df900902558feb87eaaf1/37523/os-1.png\" srcset=\"/static/8899fcdb131df900902558feb87eaaf1/e9ff0/os-1.png 180w,\n/static/8899fcdb131df900902558feb87eaaf1/f21e7/os-1.png 360w,\n/static/8899fcdb131df900902558feb87eaaf1/37523/os-1.png 720w,\n/static/8899fcdb131df900902558feb87eaaf1/00d43/os-1.png 1000w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>운영체제에서 자원을 관리하는 핵심은 <code class=\"language-text\">kernel</code>(커널)에서 담당한다. application(응용 프로그램)에서는 resource에 접근하기 위해 kernel을 통해야(커널 모드) 하며, 이는 <code class=\"language-text\">system call</code>을 호출하여 가능한 것이다. 예를 들어, C언어에서 표준 쉘 입출력에 사용되는 <code class=\"language-text\">printf</code>함수는 OS의 입출력을 담당하는 어떠한 시스템 콜을 호출할 것이다.</p>\n<p>커널은 자원(장치)을 driver를 통해 장치를 독점하는 것처럼 가상화하여 접근한다. driver는 하드웨어마다 달라 이미 OS에 구현이 되어있을수도 있고, 추가적으로 설치하거나 업데이트해야할 수도 있다. 또한, 드라이버는 커널 내부에 구현이 되어 있어 커널에서 바로 접근할 수도 있다.</p>\n<h1 id=\"운영체제의-3가지-개념\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-3%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90\" aria-label=\"운영체제의 3가지 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 3가지 개념</h1>\n<p><code class=\"language-text\">OSTEP</code>이라는 책에서는 OS에서 가장 중요한 개념으로 <code class=\"language-text\">Virtualization</code>, <code class=\"language-text\">Concurrency</code>, <code class=\"language-text\">Persistence</code>를 언급한다. 간단하게 의미를 생각해보면서 운영체제 복습을 본격적으로 시작해보자.</p>\n<ol>\n<li>\n<p>Virtualization(가상화)</p>\n<ol>\n<li>\n<p>CPU 가상화</p>\n<p>Processor(CPU)가 하나여도 동시에 여러 프로그램을 실행할 수 있다! CPU는 한번에 한가지 일만 처리한다고 배웠는데, 마치 많은 수의 가상의 CPU가 존재하는 듯한 illusion이 보인다. 이를 CPU 가상화라고 하며, 프로세스를 실행하고 멈추고 어떤 프로세스를 선택할 지 등을 OS가 선택하기 위해서는 많은 규칙들이 존재하며 이것을 배울 필요가 있다.</p>\n</li>\n<li>\n<p>메모리 가상화</p>\n<p>메모리 역시 process가 하나의 독립적인 메모리 주소를 보장받아서 사용하는 것처럼  보이는데, 이는 Memory virtualization이 되어있기 때문이다. 이러한 가상화를 통하여 OS는 목표(편리하고 안전하고 효율적으로 자원을 관리)를 달성할 수 있게 된다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>Concurrency(동시성)</p>\n<p>Process는 동시에 많은 일들을 처리하기 위해 <code class=\"language-text\">Thread</code>를 만들어서 처리한다. 이러한 multi thread환경에서는 공유되는 데이터를 정말 잘 공유하는 것처럼 보여야 동시성이 만족되는 것으로 보인다. 동시성을 활용하여 작업단위를 분할하고 병렬로 처리할 수 있게 된다.</p>\n</li>\n<li>\n<p>Persistence(영속성)</p>\n<p>메모리와 달리 보조 기억 장치는 컴퓨터가 종료되더라도 데이터가 남아있는다. 이는 <code class=\"language-text\">file system</code>으로 디스크 등의 저장장치가 추상화되어 구현되어있기 때문이다. 하지만 저장장치와의 I/O는 별도의 가상화를 거치지 않으며 영속적으로 데이터를 관리할 필요가 있다.</p>\n</li>\n</ol>\n<h2 id=\"운영체제의-목표\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"운영체제의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 목표</h2>\n<p>운영체제의 목표에 대하여 구체적으로 생각해보자. 해당 내용은 OSTEP의 번역본에서 발췌했다.</p>\n<p>가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 <code class=\"language-text\">개념</code>(abstraciton)들을 정의하는 것이다. 해당 추상화로 많은 것들을 직접 구현하고 생각하지 않아도 된다.</p>\n<p>다음으로는 <code class=\"language-text\">성능</code>이다. 성능은 주로 minimize overhead에 초점을 맞춘다. silver bullet은 없으므로, 최대한의 절충안을 찾아서 가야할 것이다.</p>\n<p>또한, OS와 프로그램, 혹은 프로그램들 간의 <code class=\"language-text\">보호</code>이다. 각 프로세스들은 다른 프로세스들로부터 고립(isolation)되어있어야 하며, 이는 보호의 핵심이다.</p>\n<p>그리고, <code class=\"language-text\">신뢰성</code>이다. 운영체제는 컴퓨터의 실행과 동시에 계속 실행중이여야하므로, 높은 신뢰성을 제공해야 한다. 추가적으로 에너지 효율성, 보안, 네트워크에서의 이동성 등이 있다.</p>\n<p>위의 목표를 달성하기 위해 우리는 운영체제가 어떤 기능들이 제공되고, 어떤 고민들을 해서 만들어졌는지 공부해볼 필요가 있다!</p>\n<p>우리는 운영체제 개발자가 아니지만, 보통 운영체제 위에서 돌아가는 프로그램을 만드므로 운영체제를 알아야 할 것이다.</p>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">OSTEP</a></p>\n<p>쉽게 배우는 운영체제 ‘조성호’</p>","frontmatter":{"date":"June 26, 2023","title":"(OS) 운영체제 복습 [0. 운영체제의 개요]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(0)-intro/"}},"prev":{"id":"ef679d0a-8051-5f57-a48b-1868cb4bba1b","html":"<h1 id=\"process\" style=\"position:relative;\"><a href=\"#process\" aria-label=\"process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process</h1>\n<p>Process는 <strong>실행중인 프로그램</strong>(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 <code class=\"language-text\">CPU virtualization</code>을 해서, <strong>여러 프로그램이 동시에 실행되는 illusion을 만들어준다</strong>. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 <code class=\"language-text\">time sharing</code>이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 <code class=\"language-text\">context switching</code>부터, 고수준의 scheduling과 같은 <code class=\"language-text\">policy</code>까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까?</p>\n<h2 id=\"프로세스-표현하기process-abstraction\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0process-abstraction\" aria-label=\"프로세스 표현하기process abstraction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 표현하기(Process Abstraction)</h2>\n<p>프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태(<code class=\"language-text\">machine state</code>)를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다.</p>\n<ul>\n<li>\n<p>PID (프로세스를 구분하기 위해 프로세스마다 갖는 identifier)</p>\n</li>\n<li>\n<p>memory image(address space, 주소공간)</p>\n<ul>\n<li>code &#x26; static data(상수)</li>\n<li>stack(변수) and heap(동적할당된 변수)</li>\n</ul>\n</li>\n<li>\n<p>레지스터 (CPU context)</p>\n<ul>\n<li>PC(=Instruction Pointer, 현재 실행중임 명령어의 위치를 파악하는데 쓰임)</li>\n<li>stack pointer, frame pointer (함수의 변수와 리턴주소를 저장하는 스택을 관리할 때 쓰임)</li>\n<li>레지스터는 해당 프로세스의 명령어나 데이터가 위치한 어떤 영역을 가리키고 있을 것이다. 하지만, CPU는 담당하는 프로세스를 수시로 바꾸므로(context switching) <strong>실행에 필요한 CPU 레지스터가 가져야할 값을 process에서도 가져야 할 것</strong>이다.</li>\n<li>예를 들어, 100번 명령어까지 A 프로세스가 진행되고 101번이 진행될 차례에서 CPU가 B 프로세스로 넘어갔다고 가정하자. 다시 A 프로세스로 돌아와서 1번 명령어부터 시작하면 안될 것이다. 따라서, 레지스터의 값을 어떠한 형태로 저장해놔야 한다.</li>\n</ul>\n</li>\n<li>\n<p>입출력 정보</p>\n<ul>\n<li>프로세스에서 사용하는 입출력 정보(파일)를 갖고 있어야 한다. 여기에는 표준 입출력(STDIO/Error)과 관련된 파일들도 포함된다.</li>\n</ul>\n</li>\n</ul>\n<p>이렇게 실행중인 프로그램이 갖고 있어야하는 값들을 저장해놓은 자료구조가 <code class=\"language-text\">PCB</code>(Process Control Block)이다. 위에 다룬 내용 이외에도 실행을 위한 프로세스의 정보들이 포함되어 있다.</p>\n<p>즉, Program을 PCB로 추상화하여 관리가 되는 것을 Process라고 볼 수 있다. PCB는 실행중에만 유효하므로, 프로세스를 <strong>실행중인 프로그램</strong>이라고 봐도 무방할 것 같다.</p>\n<h2 id=\"프로그램이-프로세스가-되는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%90%98%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로그램이 프로세스가 되는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로그램이 프로세스가 되는 과정</h2>\n<p>저장공간에 존재하던 프로그램이 더블클릭등으로 실행되면 <strong>OS는 몇가지 작업을 수행</strong>한다. 우선, 내부적으로 프로그램의 실행 파일(<code class=\"language-text\">a.out</code>과 같은)이 실행될 것이다.</p>\n<ol>\n<li>메모리를 할당하고, Memory image를 생성한다.\n<ul>\n<li>code와 정적인 데이터를 메모리에 로드한다</li>\n<li>stack, heap 영역을 만든다</li>\n</ul>\n</li>\n<li>Basic files(STDIN, OUT, ERR)를 open한다.</li>\n<li>실행을 위한 CPU register들을 초기화한다.\n<ul>\n<li>PC는 code의 첫번째 위치를 가리키고 있을 것</li>\n</ul>\n</li>\n</ol>\n<p>그림으로 프로그램이 실행되는 과정을 간단하게 그려보면 아래와 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 107.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADQUlEQVQ4y42Uy29TRxTGf/diO45NHGwnIcUJJQnY4CAIEFryAsKjRQUEBbqt1OcChCqiktzjgECV2qpKoKq6b6VKLFBV8Xd03T+ArhALkFggUHE8B83cSeyESmSkI82dueeb73znAaJ9iG5HdATRCUSHEK0gOkDNQE1jk1U2gOgVRL9G9ENEUyt3/nIHYg468KbzNkTTiAExgT/fgjRGiOr7iOqHierTRPWPmHtVRrTXmWc0juhpRC2ovexG9H1Euxx4TQMPvIMfNM2xBTg0Cyd+BlVY1B7EdCNmwgLu9WxsmJs9uyKiY005GkPc1gIzzyYZvToG9JHqKJDq6AJ6gCxR3T5Ysc4XET3mXhczhWg/opsQLXnwkGgJZl/2cltHufDnEdqL48Al4BBhsotUbi8vFG5o1ToMMuccexDNIroRMfsQPYGYMAY1cPlhOz9pCcgTJqeAb4AJxzaZKXP6N5j7b7cF2rnitJwpp5keQMxQrLFJ8NU/bSzou0CJMGHDvgCMuJATmQrHF20UDtCy2YXosE9Ib5x1t/d6mjKzL4dZ1AFgK2HiC+AMYEPfRjI7yAe/4v5ZXV8mFSfGlOLQPfNvn8O1p1u5oyc5+uMkkKRQTgE54B3ai92cvw9Rvbq2YP/PAlcaqiHjtTNkeiyzT4HPgWmnY3ZzhrN/QLRUjRm82Q3BKl3/UvhdOzjyvU1CP2HilAvV7glsouAXDRGz0+3fynLmGVx7kuee7QQgSBymdV1+aNmlne5u1VqzbJYz3dzPO9AcC7oFKNLWWfRQIaWxgJvu/40ueU3nFWtzxWzPIg9qAede5bmp+0nlqmwabFth5zrE+aVdt63Jsm21k4h+HA8Ce9YIeOySEnDxwR6mbk1zV8uu5uJyq/oS2+WaZI1eKT/KKojJIQ24+iigvRhScPIMAhmromP33syyLBsQ7XSRtYAl4qljhhGzH9FpoqUi1194tRIdBBvOAV8CFR9w8EYCWz4yfnzl4+ljdjOv2/lbIZntB4Z8Ifd5lhC0EjKxtQB2xkCNPGKOMq/DTN4adWEms72sezVfKDhRmwMijTTKXPl3rUewPkBXIm7YnkL0Ezd9bW19p7Dns2C9BF8DhUbcjDtVz5EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"running_process\" title=\"running_process\" src=\"/static/5aefc6e84f527b756ce8f374300cb86c/37523/running_process.png\" srcset=\"/static/5aefc6e84f527b756ce8f374300cb86c/e9ff0/running_process.png 180w,\n/static/5aefc6e84f527b756ce8f374300cb86c/f21e7/running_process.png 360w,\n/static/5aefc6e84f527b756ce8f374300cb86c/37523/running_process.png 720w,\n/static/5aefc6e84f527b756ce8f374300cb86c/00d43/running_process.png 1000w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<h2 id=\"프로세스의-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 상태</h2>\n<p><strong>CPU 가상화를 위해 OS는 Process를 상태에 따라 관리하도록 하며 상태는 지속적으로 변이(transition)된다.</strong> 프로세스의 상태 역시 PCB에 저장될 것이며, 크게 3개로 나눠볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 648px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQ4y42T14rDQAxF5/9/x0/JS0IgJIQUgkkhnfTee9NytMwwWXbNCuQZ7Ksr6Uo27/dbMM7H46H+X3s+n3K/3+X1ejkOYwlPp5Mcj0d17th8Ppfdbifb7VY2m42s12t1iG63m2LP57Ps93slxgwPAjqdjlwuFyWAaLlcSiqVklgsJslkUuLxuCQSCQmCQFqtlsYMBgMlIwlxjpDgUqkk1WpVKpWKpNNpTVAoFJwXi0XJ5/OKG41GSsg9k8noCaG2bLU4HA6qH3oAxsheLpclDEMNgrTb7eo3H+/L5DREE0C0y92KHDWQyWTyQeZa9g2S8Xis1fnvfHISUymD+hlrqAa9ELjX66mGzWZThsOhOoMCSGu0yDsS9vt9xXM2Gg2ZzWbfFQKizcVioS3U63Vpt9v6kZWo1WqqKRWDozq7GdPpVAfE1B1h1OJSGSthlx3S6/UaiTdWH+u0Zjcf4dlF1iiXy0k2m3WVgPFjrMbmr0w2aLVaaVVUiSxoGrUBJqp8jF/K/npo+tvUfcIvTVvlDBEEcmcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"state\"\n        title=\"state\"\n        src=\"/static/2f160f943f3404a15e87ae52c3cf7f7b/3996e/process_state.png\"\n        srcset=\"/static/2f160f943f3404a15e87ae52c3cf7f7b/e9ff0/process_state.png 180w,\n/static/2f160f943f3404a15e87ae52c3cf7f7b/f21e7/process_state.png 360w,\n/static/2f160f943f3404a15e87ae52c3cf7f7b/3996e/process_state.png 648w\"\n        sizes=\"(max-width: 648px) 100vw, 648px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li><strong>Running</strong> : CPU에서 해당 프로세스를 실행중에 있는 상태\n<ul>\n<li>Process는 많지만 한 CPU에서는 하나의 Process만 수행할 수 있다. Running Process로 가는 과정을 <code class=\"language-text\">Scheduling</code>이라고 하며, 이에 대하여 OS의 스케줄링 정책 등이 관여한다.</li>\n</ul>\n</li>\n<li><strong>Ready</strong> : scheduled 되기 위해서 기다리고 있는 상태\n<ul>\n<li>나머지 프로세스들은 Ready 상태로 <code class=\"language-text\">Ready Queue</code>에 들어가 있다. ready queue는 단순하게 하나만 존재하진 않으며 이는 뒤의 스케쥴링에서 자세히 다루도록 한다.</li>\n</ul>\n</li>\n<li><strong>Blocked</strong> : Running이였다가 인터럽트가 발생하여 잠시 CPU가 해당 프로세스에 대한 작업을 중지한 상태\n<ul>\n<li>File IO 등은 CPU 입장에서 매우 매우 시간이 오래 걸리는 작업이다. 따라서 운영체제는 cpu를 효율적으로 사용하기 위해 IO interrupt가 발생하면 이를 catch하여 해당 io작업이 완료될때까지 프로세스를 <code class=\"language-text\">block</code>시킨다.</li>\n<li>io작업이 완료되면 ready queue로 다시 돌아가게 될 것이다.</li>\n</ul>\n</li>\n</ul>\n<p>다음은 OSTEP 책에 나와있는 Process state transition의 예시이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz21TaW+CUBDs//9p9kNtkEsOCzwOReRQuTymmUVIm3aTTR4PdmZ2dnlLkgRKKXRdhyiKwOeqqtC2LaIwRJokaJoGj8cD9/sdz+cT+yyD7/m4Xq/yPN8z3tIXYFPX+Fyvsf74gKHruFwu2Gga3lcrxCrG7XZD3/cYhgGn0wkqUjifzxjHEUM/CKgAysUwSIFtWfBcF47jCGMQBALOQsZc9DOonLWLQrJSDT/e2vYCSBICWqaJqpws4LvdbockjuG5HkzTFJuyNBUwggrgrMAwDOgbXbyr61oUMwnCiJUSAmfrwPc8IdA3G/H4FyAVMmzLhm3bk6dNA9d1J1X+BEh76qqSodHzrm1RleXS7h/AMAigaRqOx6O0SALLtKS9uYhWlGUpbeZ5vni5eMh1mQHph2kYoo73ruOIyuDra1qX/R5hGMpq8VsKYF5elolCKiEj2+FErZdvHBInOA7jcqbXJO+7TlaISXLW/tsyF/ZwOCDLsj+tMEhMlaeikF1k8tu5XgB5YHtMMs0E/As4aariOyppr614y6HIdjTNrwmLh6Ls5U1+yFEUheyfrIXnyTkMwuUuTVPZAubO96GiaAGkwm9opI603SW8mwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"process_transition\" title=\"process_transition\" src=\"/static/f53018f749245d534e6c469b460bd325/37523/process_transition.png\" srcset=\"/static/f53018f749245d534e6c469b460bd325/e9ff0/process_transition.png 180w,\n/static/f53018f749245d534e6c469b460bd325/f21e7/process_transition.png 360w,\n/static/f53018f749245d534e6c469b460bd325/37523/process_transition.png 720w,\n/static/f53018f749245d534e6c469b460bd325/302a4/process_transition.png 1080w,\n/static/f53018f749245d534e6c469b460bd325/9685e/process_transition.png 1336w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>Time 3에서 P0에서 I/O interrupt가 발생하였을 때, Blocked 상태가 되며 Ready Queue에서 가장 먼저 있던 P1이 CPU의 점유를 가져가게 된다. 이후, P0의 IO작업이 끝나게 되고 ready queue로 들어가게 되며, P1이 끝나서 다시 CPU의 점유를 P0이 가져오게 된다. 만약 P1이 종료되지 않았더라도, P1의 I/O 작업이나 스케쥴링 정책에 의하여 P0으로 언젠가는 다시 돌아갔을 것이다.</p>\n<h3 id=\"세분화-프로세스의-5가지-상태\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%B6%84%ED%99%94-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%83%81%ED%83%9C\" aria-label=\"세분화 프로세스의 5가지 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(세분화) 프로세스의 5가지 상태</h3>\n<p>위에 상태에 추가적으로 생성되고 아직 ready queue에 들어가지 않은 <strong>New</strong> 상태와, 프로세스가 종료된 <strong>Dead</strong> 상태도 존재한다. 이러한 Process의 상태 역시 운영체제 마다 조금씩 다르니 참고하자.</p>\n<h2 id=\"pcb\" style=\"position:relative;\"><a href=\"#pcb\" aria-label=\"pcb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB</h2>\n<p>OS는 PCB(Process Control Block)이라는 자료구조를 리스트로 관리하여 프로세스에 대한 정보를 갖는다. 운영체제에 따라 PCB의 구현 방법이나 구체적인 이름은 다르지만 공통적으로 갖는 값들은 모두 프로그램의 실행과 프로세스의 관리를 위한 것이다. PCB는 보통 아래의 값들을 갖는다.</p>\n<ul>\n<li>PID</li>\n<li>Process state (Running, Blocked, Ready, …)</li>\n<li>Pointers to other related processes : 부모 프로세스의 정보</li>\n<li>CPU context of the process : running에서 다른 상태로 넘어갈 때, register값들(PC, SP …)을 PCB에 저장해놔야 스케줄링될때 복원할 수 있음</li>\n<li>pointers to memory locations</li>\n<li>pointers to open files</li>\n</ul>\n<p>추가적으로 스케줄링을 위한 Process의 우선순위 등도 PCB에 저장되어야 할 것이다.</p>\n<h1 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h1>\n<p>운영체제는 CPU를 <code class=\"language-text\">가상화</code>하여 multiple process를 동시에 실행하는 착각을 갖게 해준다. 시간을 잘게 쪼개서 여러 프로세스들을 돌아가며 실행하여(time sharing) 여러 프로그램들이 동시에 실행되는 것 처럼 보이는 것이다.</p>\n<p>따라서 개발자들은 한 프로그램을 운영체제가 어떻게 지원해주는지만 알면 될 것이다. OS는 <code class=\"language-text\">PCB</code>와 같은 자료구조를 통해 Process를 추상화하여 제공하며, Process는 CPU가 해당 Process를 어떻게 관리 하고 있는지에 따라 <code class=\"language-text\">state</code>가 바뀌게 된다. 실행중인 process는 OS의 <code class=\"language-text\">scheduler</code>에 의하여 관리된다.</p>\n<p>다음 포스트에서는 OS에서 Process를 다루기 위해 제공해주는 Process API(주로 system call)와 Process가 실행되는 과정에 대하여 구체적으로 공부해보도록 하자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"June 28, 2023","title":"(OS) 운영체제 복습 [2. Process Abstraction]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(2)-Process/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(1)-computer-architecture/","nextSlug":"/OS(0)-intro/","prevSlug":"/OS(2)-Process/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}