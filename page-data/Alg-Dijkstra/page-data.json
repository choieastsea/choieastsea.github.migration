{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-Dijkstra/",
    "result": {"data":{"cur":{"id":"e1e5d260-58e0-58af-a974-6c589aef1c8d","html":"<p>Dijkstra(다익스트라) Algorithm은 그래프에서, <strong>한 노드에서 출발하여 다른 노드로 가는 최단 거리</strong>를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다.</p>\n<h2 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h2>\n<p>input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight)</p>\n<p>output : 1번노드에서 n번노드까지의 최단 거리</p>\n<p>​\t(입력 예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n</code></pre></div>\n<h1 id=\"그래프를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"그래프를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프를 표현하는 방법</h1>\n<p>weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데,</p>\n<ol>\n<li>\n<p>노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다.</p>\n<p>4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, <code class=\"language-text\">matrix[4][3]=5</code>와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다.</p>\n</li>\n<li>\n<p>한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)로 저장해도 헷갈리지만 않으면 좋다!</p>\n<p>위와 같은 상황일때, <code class=\"language-text\">node_4의 인접노드 : (5, 3번)</code>와 같이 표현할 수 있다.</p>\n</li>\n</ol>\n<p>2의 방법이 공간적으로 효율적이고 여러 엣지가 존재할 경우도 활용이 가능하다. <code class=\"language-text\">c++</code>에서는 pair와 vector배열을 이용하여 입력에 대하여 인접노드를 추가하는 형태로 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvector&lt;pair&lt;int, int&gt;&gt; E[100005];\nint main(void)\n{\n    int n, m; // number of nodes, number of edges\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++)\n    {\n        int from, to, weight;\n        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;\n        E[from].push_back(make_pair(to, weight));\n        E[to].push_back(make_pair(from, weight));\n    }\n   ...\n}</code></pre></div>\n<p>전역변수 E에 모든 엣지의 정보가 저장되어 있으므로, 이를 탐색하며 최단거리를 구할 수 있다.</p>\n<h1 id=\"dijkstra-의사-코드\" style=\"position:relative;\"><a href=\"#dijkstra-%EC%9D%98%EC%82%AC-%EC%BD%94%EB%93%9C\" aria-label=\"dijkstra 의사 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dijkstra 의사 코드</h1>\n<p>위와 같이 그래프를 만들고 나서는 다익스트라 알고리즘을 이용하여 그래프를 탐색하며 최단거리를 구할 수 있다.</p>\n<p>(1번노드에서 출발하여 n번노드까지의 최단거리를 구하는 다익스트라 알고리즘이라고 가정해보자) 우선 출발지부터 i번 노드까지의 최단거리를 기록하는 <code class=\"language-text\">D[i]</code>가 필요하다. D 배열의 각 원소는 처음에 매우 큰 값으로 세팅하도록 하고, 이후 탐색하면서 더 작은 비용의 거리가 발견된다면 업데이트 되도록 하므로, 큰 값으로 초기화를 해준다.</p>\n<ul>\n<li>\n<p>1번노드~1번노드의 거리는 0이므로, 이를 priority queue(이하 pq, 방문할 노드를 엣지의 거리 순으로 저장함)에 저장한다. D[시작노드] = 0 임을 확정짓는다.</p>\n<ul>\n<li>pq가 비어있을때 까지</li>\n</ul>\n<ol>\n<li>\n<p>pq에서 가장 거리가 짧은 엣지를 찾는다. 노드 번호 : <code class=\"language-text\">curNode</code>, 엣지 길이 : <code class=\"language-text\">curDist</code></p>\n</li>\n<li>\n<p>pq에서 해당 엣지(ex. x번 노드까지의 거리)을 제거한다. (방문 처리)</p>\n</li>\n<li>\n<p>만약 <code class=\"language-text\">D[curNode]</code>가 <code class=\"language-text\">curDist</code>보다 작지 않은경우, (D[ ] 업데이트 필요)</p>\n<ol>\n<li>\n<p>curNode의 인접한 노드들을 조사하는데…</p>\n</li>\n<li>\n<p><code class=\"language-text\">D[x]</code>와 <code class=\"language-text\">D[curNode]+curNode~x의 거리</code>를 비교하여 더 작은 값으로 X 노드까지의 최단거리를 업데이트한다.</p>\n</li>\n<li>\n<p>업데이트 되는 경우에는 해당 엣지 정보를 pq에 추가한다.</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>주의해야할 점은 크게 두가지가 있다.</p>\n<ul>\n<li>인접한 엣지 중에서 가장 weight가 짧은 것을 추출하는 과정에서, 일반 배열로 저장하는 것(<code class=\"language-text\">O(N)</code>)보다는 PQ로 저장하는 것(<code class=\"language-text\">O(log(N))</code>)이 효율적이다.</li>\n<li>A에서 C까지의 최단경로를 볼 때, 임의의 노드 B에서 A<del>B + B</del>C까지의 거리와 A~C의 거리를 비교하고, 더 짧은 것으로 거리를 확정짓는 것이 다익스트라의 핵심이다.</li>\n</ul>\n<p>코드는 아래와 같다. 만약 endNode가 추가적으로 필요하다면, 인자에 추가하고 endNode탐색시 종료하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void dijkstra(int startNode)\n{\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // (weight, nodeNo)\n    // startNode PQ에 추가\n\n    pq.push(make_pair(0, startNode));\n    d[startNode] = 0;\n    while (!pq.empty())\n    {\n        int curNode = pq.top().second;\n        int curDist = pq.top().first;\n        // printf(&quot;curNode : %d, curDist : %lld\\n&quot;, curNode, curDist);\n        //해당 노드 방문 처리\n        pq.pop();\n        if (d[curNode] &gt;= curDist)\n        {\n            for (int i = 0; i &lt; E[curNode].size(); i++)\n            {\n                //최단 거리 노드의 인접노드\n                int nextNode = E[curNode][i].second;\n                int nextDist = E[curNode][i].first;\n                // printf(&quot;nextDist : %lld, nextNode: %d\\n&quot;, nextDist, nextNode);\n                if (d[curNode] + nextDist &lt; d[nextNode])\n                {\n                    // printf(&quot;update needed\\n&quot;);\n                    // update 필요\n                    d[nextNode] = d[curNode] + nextDist;\n                    // pq push\n                    pq.push(make_pair(nextDist, nextNode));\n                }\n            }\n        }\n    }\n}</code></pre></div>\n<h2 id=\"다익스트라에서-경로를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%EC%97%90%EC%84%9C-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"다익스트라에서 경로를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다익스트라에서 경로를 표현하는 방법</h2>\n<p>위의 코드는 단지 x번 노드부터 n번 노드까지의 최단거리를 의미한다. 따라서, 어떠한 경로를 통하여 갔는지는 추가적인 작업이 필요하다. 이는 최단거리가 업데이트되어 확정되는 순간에 <strong>해당 노드를 방문하기 직전의 노드를 기록하면 된다</strong>! nextNode와 curNode를 통하여 최단거리를 비교하는 과정에서, 업데이트가 일어나면(최단거리 확정이 일어나면) 배열에다가 curNode를 저장하면 될 것이다.</p>\n<p>그렇게 하면 1 -> 4 -> 3 -> 5의 경로로 최단경로가 확정될 때, [0, 1, 0, 5, 0, 3]와 같이 저장될 것이다. 이를 스택에다가 넣어서 출력하면 깔끔하게 나올 것이다. 최종 코드는 다음과 같다. <code class=\"language-text\">codeforces 20C</code>문제에 대한 코드이다.! 결국 다익스트라가 이러한 틀로 구성되니까 참고하면 좋을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvector&lt;pair&lt;int, int&gt;&gt; E[100005];\nlong long d[100005];\nint prevNode[100005]; // 최단경로에서 i번째 노드의 이전 노드를 저장\n\nvoid dijkstra(int startNode, int endNode)\n{\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // (weight, nodeNo)\n    // startNode PQ에 추가\n\n    pq.push(make_pair(0, startNode));\n    d[startNode] = 0;\n    prevNode[startNode] = startNode;\n    while (!pq.empty())\n    {\n        int curNode = pq.top().second;\n        int curDist = pq.top().first;\n        // printf(&quot;curNode : %d, curDist : %lld\\n&quot;, curNode, curDist);\n        //해당 노드 방문 처리\n        pq.pop();\n        if (d[curNode] &gt;= curDist)\n        {\n            for (int i = 0; i &lt; E[curNode].size(); i++)\n            {\n                //최단 거리 노드의 인접노드\n                int nextNode = E[curNode][i].second;\n                int nextDist = E[curNode][i].first;\n                // printf(&quot;nextDist : %lld, nextNode: %d\\n&quot;, nextDist, nextNode);\n                if (d[curNode] + nextDist &lt; d[nextNode])\n                {\n                    // printf(&quot;update needed\\n&quot;);\n                    // update 필요\n                    d[nextNode] = d[curNode] + nextDist;\n                    // for path\n                    prevNode[nextNode] = curNode;\n                    // pq push\n                    pq.push(make_pair(nextDist, nextNode));\n                }\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, m, from, to, weight; // n : number of nodes, m : number of edges\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++)\n    {\n        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; // 1-based-node\n        E[from].push_back(make_pair(weight, to));\n        E[to].push_back(make_pair(weight, from));\n        // printf(&quot;from : %d, to : %d, weight : %lld\\n&quot;, from, to, weight);\n    }\n    for (int i = 1; i &lt;= n; i++)\n    {\n        d[i] = LLONG_MAX;\n    }\n    dijkstra(1, n);\n    if (d[n] == LLONG_MAX)\n    {\n        // update되지 않았다 -&gt; 경로 없다\n        printf(&quot;-1\\n&quot;);\n        return 0;\n    }\n    int c = n;\n    stack&lt;int&gt; path;\n    while (c != 1)\n    {\n        // printf(&quot;%d &quot;, c);\n        path.push(c);\n        c = prevNode[c];\n    }\n    path.push(c);\n    while (!path.empty())\n    {\n        printf(&quot;%d &quot;, path.top());\n        path.pop();\n    }\n    printf(&quot;\\n&quot;);\n    return 0;\n}</code></pre></div>","excerpt":"Dijkstra(다익스트라) Algorithm은 그래프에서, 한 노드에서 출발하여 다른 노드로 가는 최단 거리를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다. 문제 설명 input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight) output : 1번노드에서 n번노드까지의 최단 거리 ​\t(입력 예시) 그래프를 표현하는 방법 weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데, 노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다. 4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, 와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다. 한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)…","frontmatter":{"date":"May 28, 2022","title":"(Alg) 그래프 알고리즘 - Dijkstra와 최단 경로 출력","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/Alg-Dijkstra/"}},"next":{"id":"d992bf3f-f7f6-5d35-b6e4-c199d5db8768","html":"<p>ADsP 32회 시험을 본지 거의 한달이 되었는데 아직도 시험결과가 나오지 않아 까먹고 있었는데, 이런 문자가 도착했다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACi0lEQVQ4y2WT63LaSBCFeRAbXJXUOqmywSBbWOZiQRAIJBAX3ZBwLDAGQ1h7N8n7f1s9draS8o9TPT2aOdN9Tit3fHyM4OjoiF9rQT6f5+Tk5A8UCq8xny9wenpKqVTi/PycDx8+UigU1J3c9bVBFM0Jw4ggiIjjOUEQYtsDNO2Kq6sql5c6un5NtWr8D8l/h2HUODs7J9fpdPn+/SfPzy8kyYLRaKzguiN6vT6W1WMwcLm9bVGrNajXm+8g+42GSblckQpvmE59hkNPkTjOEGfg4nkTRt6E/sAlDGNarS/I2Zubuqrmd8i+kJZKZXL1eoMkSZnNfHXR90MlQRTGREHAxPPwp1PCIMD3A3VGpBGJpBCJs1mgoq5XyZlmm/3+G9vtE+v1hs1my+HwN5unPf5ig2lPMcwBN6ZN2xrgOK6SwvPG9PsOzaap5BAe1bJpthTharVWUUiX2ZLkbkUn3NNL/6ETP9OND8T3T2TZkvtsxf39Uskj7UrbtVqTi4syuWr1muFwpFyVF8UEMarb7eH0+wpDZ4Db72G1W7TNFj3LotG4RdcNpZ3oWq/fvhKKhrvdNxaLr2TZioeHNeuHRx4ft2yfdipPsw21jofWsNGbNld1i45lq9aF7JXwrUJp+XB4ZrfbMx5PsW1HjYm4PpnM8EYeze6Y8pcYrbtAs+Zo7RnOcILrDt8TytCm6Z0yZZll3KUpUeAThZEilNkce2NW6ltC6Pt8XSzU49LyO0L5U8SIl5cX5tmO5PFfks0PonRJ4AfM56kai3myII5TlUsB8pjo9mu4xW3lcqVSoduzaZsmRaPDX7rNqeFyVjEoFUsUSxdqYIuyLl68oaT2ymXtDRU07ZJPnz7zH7+f2TQR7xeDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"message\" title=\"message\" src=\"/static/587ee6508b31761f1d5ebeee245c874c/37523/message.png\" srcset=\"/static/587ee6508b31761f1d5ebeee245c874c/e9ff0/message.png 180w,\n/static/587ee6508b31761f1d5ebeee245c874c/f21e7/message.png 360w,\n/static/587ee6508b31761f1d5ebeee245c874c/37523/message.png 720w,\n/static/587ee6508b31761f1d5ebeee245c874c/914ae/message.png 860w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>바로 들어가서 확인했는데, 불합격이다…?</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 18.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAt0lEQVQY04WQzU7DMBCE8/5vhOAN6I0DLZUQFDBEcdvUjtc/cfyhbJE4IUaanR/taTr+RNP79mG4ub3jfrNh97TnP3RBIjFlcplV17z6lItmY0cetnsetzvMV4+fAs5PTEH0Z80i6ep9oBtOjkkyIRbs6YLprXrJFXt2DMczeW7aX7yoPr++MxxHUln47C2jC8Sy8HIwdHOFZak455Tee5zz5FwIQX4YlDElaq2IxOsorf0O1Jr23x/4NK+HBckPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20220321163113611\" title=\"image-20220321163113611\" src=\"/static/c3f935909f9443ceb43ab9d9d02bea91/37523/site.png\" srcset=\"/static/c3f935909f9443ceb43ab9d9d02bea91/e9ff0/site.png 180w,\n/static/c3f935909f9443ceb43ab9d9d02bea91/f21e7/site.png 360w,\n/static/c3f935909f9443ceb43ab9d9d02bea91/37523/site.png 720w,\n/static/c3f935909f9443ceb43ab9d9d02bea91/302a4/site.png 1080w,\n/static/c3f935909f9443ceb43ab9d9d02bea91/07a9c/site.png 1440w,\n/static/c3f935909f9443ceb43ab9d9d02bea91/e8f1b/site.png 2246w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>근데, 문자 내용을 다시보니, 아직 최종 결과 발표전이라 모두 “불합격”으로 표시된다는 것이였다!!(휴…) 그래서 ‘시험 결과 확인’ 버튼을 눌러보니</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJ0lEQVQoz31Ry07EMAzMr/MJfAgfgmARB4Q4ALsHWO2Dbrt5ukmcQTbbqtoDlkaZTGx37Br8E601vLy+4eFxhcfVE6y1s36dN4Xpug7OOQxDj2EYtMh7j1qrJn4fT/j4XGO92SARSfVfE2Yw89xs4ma7O2KwHqfBoT977A4dtvsjIhWENGLMjMJApAwXSPG13espOV1vcfjpEVJGogxTKoMbFBIhJpytBzNQuaHUpqfoMZHymEZMdaI7H5TLm6mlqNUJMnLf9zoCFjoRKea9yTsASgkxhssuGSaXqp0F8hXrvIIvmkDMiztxw60h5zI7TDQiqi4OGWYsDUvIbpZ3Kg0hFdhA8HEEFVZOV3WCXBvMctzpjy257Ovm9g73z+96r5dRr+sm/ALKiXCS/GY/YAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20220321163225740\"\n        title=\"image-20220321163225740\"\n        src=\"/static/58048df514dac20a2ed069f88bb6df66/37523/site_2.png\"\n        srcset=\"/static/58048df514dac20a2ed069f88bb6df66/e9ff0/site_2.png 180w,\n/static/58048df514dac20a2ed069f88bb6df66/f21e7/site_2.png 360w,\n/static/58048df514dac20a2ed069f88bb6df66/37523/site_2.png 720w,\n/static/58048df514dac20a2ed069f88bb6df66/302a4/site_2.png 1080w,\n/static/58048df514dac20a2ed069f88bb6df66/07a9c/site_2.png 1440w,\n/static/58048df514dac20a2ed069f88bb6df66/14586/site_2.png 2314w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>다행히 합격이다~ 응시료가 50000원으로 비싸서 다시 보지 않으려 했는데 다행이다. 아직 합격증은 나오지 않았지만, 짧게 시험 리뷰를 해보려고 한다.</p>\n<h1 id=\"준비기간\" style=\"position:relative;\"><a href=\"#%EC%A4%80%EB%B9%84%EA%B8%B0%EA%B0%84\" aria-label=\"준비기간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>준비기간</h1>\n<p>우선, 나는 고등학교 확률과 통계 과정을 이해정도만 하고 있는 사람이고, 현재 컴퓨터공학과에서 공부하고 있어 R 스크립트 작성에 부담을 가지진 않았다.</p>\n<p>나는 한달간 준비를 했는데, 방학이라 평일에 2<del>3시간정도 하고 주말에는 쉬면서 했다. 마지막 주에는 4시간 넘게도 했다. 블로그에 기록하면서 공부하지 않았다면 2</del>3주면 가능할 것 같다고 생각한다!</p>\n<h1 id=\"추천-하는-자료\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B2%9C-%ED%95%98%EB%8A%94-%EC%9E%90%EB%A3%8C\" aria-label=\"추천 하는 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추천 하는 자료</h1>\n<ul>\n<li>\n<p>보통 기출문제를 많이 담고 있는 책을 하나 갖고 있는 것이 좋다. 나도 솔직히 책 한권과 구글링, 유튜브로만 공부를 했다. 이외의 참고 서적은 없다.</p>\n</li>\n<li>\n<p>카페에 가입하여 기출문제를 얻을 수 있다고 하는데, 나는 책도 다 못 풀었기에 그럴 시간은 없었다.</p>\n</li>\n<li>\n<p>그리고, 나는 컴공이라 예제 R코드를 직접 입력해보면서 실습을 했는데, <u>솔직히 거의 필요없다</u>고 봐도 무방하다. 함수 이름과, 그 함수의 return 값의 의미 정도만 외우면 될 것 같다.</p>\n</li>\n</ul>\n<h1 id=\"과목별-난이도\" style=\"position:relative;\"><a href=\"#%EA%B3%BC%EB%AA%A9%EB%B3%84-%EB%82%9C%EC%9D%B4%EB%8F%84\" aria-label=\"과목별 난이도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>과목별 난이도</h1>\n<h2 id=\"1과목-데이터의-이해\" style=\"position:relative;\"><a href=\"#1%EA%B3%BC%EB%AA%A9-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4\" aria-label=\"1과목 데이터의 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1과목. 데이터의 이해</h2>\n<p>1단원은 많은 통계적 용어와 기업에서 사용하는 통계 자료들에 대한 용어(CRM, SCM, ERP, DW, DM 등…)를 알고 있는 것이 중요하다. 거의 유형이 정해져 있고, 이해하기 쉬운 내용이라서 가장 쉽게 끝낼 수 있을 것이다. 사례가 7가지 빅데이터 분석 방식 중 어디에 해당하는지 분류하는 유형, 빅데이터의 문제와 해결방안도 자주 나오는 것 같다. <u>주제에 대한 키워드 맥락을 암기</u>하고 있으면, 사례나 단어가 바뀌더라도 해결할 수 있는 문제라고 생각한다.</p>\n<h2 id=\"2과목-데이터-분석-기획\" style=\"position:relative;\"><a href=\"#2%EA%B3%BC%EB%AA%A9-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B8%B0%ED%9A%8D\" aria-label=\"2과목 데이터 분석 기획 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2과목. 데이터 분석 기획</h2>\n<p>나는 개인적으로 2단원이 가장 어려웠다(시험 결과도 가장 안좋다). 2단원은 용어가 너무 헷갈리게 범주화가 되어있다. 분석 방법론, 분석 방법론이 적용되는 모델, 분석 과제 탐색 방법, 분석 마스터플랜, 분석 준비도, 분석 성숙도, 데이터 거버넌스, 데이터 분석 조직 유형… 말들이 다 비슷하고 헷갈린다. 큰 흐름 정도만 이해하고, 지엽적인 것은 과감하게 포기하는 전략으로 하였다. 1단원과 3단원에서 보충하여 60점을 넘긴다는 마인드로 공부했다. 2과목은 통계학과 전공생보다는 경영학과 전공생이 더 잘 이해할 것 같다.</p>\n<h2 id=\"3과목-데이터-분석\" style=\"position:relative;\"><a href=\"#3%EA%B3%BC%EB%AA%A9-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D\" aria-label=\"3과목 데이터 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3과목. 데이터 분석</h2>\n<p>가장 배점이 높은 과목으로, 이부분부터 공부하는 것을 추천한다. 가장 재미있기도 한데, 궁금증은 해결되지 않는 과목이였다. 회귀분석의 결과를 왜 분산분석을 하는지 잘 모르겠는데, 찾아보면 더 모르겠다… 이론적 배경을 파고 들기는 어려우므로, <strong>해당 분석 방법의 결과와 쓰임새정도까지만</strong> 파악하면 충분한 것 같다(그 이상 물어보지도 않는다). 타 과목에 비해 문제가 2배 출제되므로, 범위도 많다… 나도 뒷부분은 시간이 없어 거의 포기했다. 통계와 분석 방법에 대하여 하나도 모른다면, 1주일 이상 충분히 시간을 갖고 공부하는 것을 추천한다.</p>\n<h1 id=\"난이도-총평\" style=\"position:relative;\"><a href=\"#%EB%82%9C%EC%9D%B4%EB%8F%84-%EC%B4%9D%ED%8F%89\" aria-label=\"난이도 총평 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>난이도 총평</h1>\n<p>너 회귀 분석 어떻게 하는지 알아? (X) -> 회귀분석이 뭔지 알아? (O)</p>\n<p>상관계수가 왜 두 집단의 상관성을 나타내는지 알아? (X) -> 상관계수가 1이면 상관성이 크다고 볼 수 있지? (O)</p>\n<p><strong>단순한 결과 암기로 거의 모든 문제가 해결 가능</strong>하며, 응용력은 크게 필요없다. 물론 개념을 깊게 이해하고 있다면 다른 유형의 문제가 나와도 해결할 수 있겠지만, 그러지 않아도 합격할 수준은 충분히 되는 것 같다고 생각한다. 코딩 역시 큰 상관은 없는 것 같다. 할 줄 안다면 스크립트를 봤을 때 겁을 덜 먹는 정도인데, 합격에 영향을 주진 않는다.</p>\n<p>시험고사장은 아무래도 얼마 안된 사설시험이다 보니 2-30대의 젊은 사람들이 많아 보였으며, 응시료 때문인지 결석생은 거의 없었다. 공부를 했다면 2~30분이면 다 풀고 나올 정도로 계산이나 생각할 거리가 많지 않다. 나는 모르는 문제를 찍느라 시간이 더 걸렸던 것 같다.</p>\n<p>결론적으로 시간이 남는다면 볼만한 시험이지만, 그것이 아니라면 얻어갈 것이 많은 시험은 아닌 것 같다. 시험이름처럼 준전문가까지는 아니고, <strong>데이터 분석 새내기</strong>정도가 맞는 것 같다. 나는 시간도 남고 평소 빅데이터 분석에 흥미를 갖고 있어 찍먹해보았는데, 이 분야가 어떻게 구성되었는지 정도를 간단하게 파악해볼 수 있는 시험이였던 것 같다.</p>","frontmatter":{"date":"March 22, 2022","title":"(ADsP) 데이터분석준전문가 32회 합격 후기","categories":"ADsP","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/ADsP-Review/"}},"prev":{"id":"74408fa6-45a8-50c5-90bc-2d58f542b7aa","html":"<p>자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다.</p>\n<h1 id=\"수학적-귀납법\" style=\"position:relative;\"><a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B7%80%EB%82%A9%EB%B2%95\" aria-label=\"수학적 귀납법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수학적 귀납법</h1>\n<p>컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다.</p>\n<blockquote>\n<p>BASE : P(1)이 참이다.</p>\n<p>STEP : P(n-1) -> P(n)이 참이다.</p>\n<p>따라서, 모든 자연수 n에 대하여 P(n)은 참이다.</p>\n</blockquote>\n<p>BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 <strong>P(n-1)이 참이라고 믿는 것</strong>인데, 이유는 무엇일까.</p>\n<h2 id=\"p-q의-의미\" style=\"position:relative;\"><a href=\"#p-q%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"p q의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>P->Q의 의미</h2>\n<p>예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자.</p>\n<ul>\n<li>100점을 맞고, 치킨을 사주었다. => 참</li>\n<li>100점을 맞고, 치킨을 안사주었다. => 거짓</li>\n<li>100점을 안맞았고, 치킨을 안사주었다. => 참</li>\n<li>100점을 안맞았는데, 치킨을 사주었다. => <strong>참</strong></li>\n</ul>\n<p>마지막 경우가 참인 이유는 100점을 안맞았을때의 약속에는 아무 내용도 없기 때문에 판단할 수 없고, 약속을 어긴 것은 아니기 때문이다. 이를 <code class=\"language-text\">vacuously true</code>라고 부르는 사람도 있고, 어쨌든 약속은 100점을 안맞았을때는 신경쓸 필요가 없이 참이고, <strong>100점을 맞았을 때 치킨을 사주는지 여부에 따라서 약속의 참거짓이 결정</strong>된다.</p>\n<p>이를 위의 step에 대입시켜보자. P(n-1) -> P(n)이 참인 것을 보이려면, P(n-1)이 거짓인 경우에는 항상 참이므로(vacuously true), 굳이 무언가를 증명할 필요가 없다. 따라서, P(n-1)이 참인 것을 가정하고, P(n)이 참임을 보이면 되는 것이다. 주로, 귀납법에서는 해당 함수, 수식이 항상 성립함을 증명하므로 이와 같이 생각하면 편할 것이다.</p>\n<h1 id=\"배열array\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4array\" aria-label=\"배열array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Array)</h1>\n<p>이제 본격적으로 자료구조에 대하여 공부해보자. 가장 기본적인 자료구조는 배열이다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>배열은 연속된 주소에 동일한 type의 자료형들이 모여있는 것들을 말한다. C에서의 배열은 연속된 주소에 같은 타입의 데이터가 저장되어 있고, python과 같은 언어에서는 array가 아닌 list를 사용하는데, 이는 연속된 주소에 데이터를 가리키는 reference가 저장되어 있다. 따라서, list에는 여러가지 자료형을 넣을 수 있는 것이다.</p>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<p>배열의 가장 큰 장점은 배열의 연속된 공간에서 오는 특징에서 기인하는데, 바로 Access Time 이다. 보통 선형 자료구조에서는 처음부터 끝까지 가리키기 위해 index가 존재하는데, 배열에서는 연속된 공간에 같은 type이 모여있으므로, <strong>특정 인덱스에 대하여 상수시간에 접근이 가능하다</strong>.</p>\n<p>예를 들어, 배열에서 k번째의 data에 접근하려고 한다고 해보자. 이는 <code class=\"language-text\">배열의 시작주소 + (k-1)*(type size)</code>로 접근이 가능하며, 이는 배열의 크기가 크거나 k의 크기가 커도 항상 같은 시간(<code class=\"language-text\">O(1)</code>)에 접근할 수 있게 된다. LinkedList 등은 시작부터 k-1번 인덱스까지 차례대로 접근해야하므로, 이는 상수시간이 아니다.</p>\n<p>또한, 정렬된 배열(sorted array)의 경우 <code class=\"language-text\">search</code>가 빠르다. 이는 <code class=\"language-text\">Binary Search</code>(이분탐색)을 통해 <code class=\"language-text\">O(log n)</code>시간에 탐색이 가능하다. 참고로, 접근과 탐색은 특정 값을 찾는지 특정 위치의 값을 찾는지 이므로 완전히 다른 것이다.!</p>\n<p>정렬되지 않은 배열의 경우에는 탐색에는 일일이 탐색하는 <code class=\"language-text\">Linear Search</code>(선형탐색)을 통해 <code class=\"language-text\">O(n)</code> 시간이 걸리므로 느리다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<p>배열의 단점으로는 크기 변화에 대한 비용이 크다는 것이 있다. 배열은 선언시 정해진 크기만큼 메모리 공간을 차지하므로, 해당 크기를 넘어가게 되면 새로운 빈 공간을 찾아서 할당하고 이전의 값들을 복사하여 옮기는 작업이 필요하다! 우리가 사용하는 동적배열도 내부적으로는 정적배열로 구현되어있고, 크기 변화시 이러한 오버헤드가 발생함을 알 수 있다. 배열의 크기가 줄이는 경우에도 마찬가지.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>배열은 크기의 변화가 적고, 같은 자료형인 data들로 구성하는 것이 적합하다. 만약, 정렬이 되어있거나 정렬에 대하여 오래걸리지 않는다면 배열은 탐색 또한 빠른 자료구조이다!</p>\n<h1 id=\"재귀-recursion\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-recursion\" aria-label=\"재귀 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 (Recursion)</h1>\n<p>재귀는 보통 함수에서 많이 사용되는 개념으로, 함수 안에 해당 함수를 호출하는 것을 재귀함수라고 한다. loop를 사용하는 것을 재귀를 사용하면 더 직관적이고 코드가 짧아지는 경우가 많으므로 잘 알아두자.</p>\n<h2 id=\"재귀함수의-구성\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"재귀함수의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 구성</h2>\n<p>재귀는 위에서 공부한 <code class=\"language-text\">수학적 귀납법</code>과 매우 유사한 구조를 갖는다. 재귀 자체가 귀납적으로 구성되어 있기 때문이다. 재귀함수는 보통 base case와 recursion case로 나뉜다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>재귀함수를 탈출(return)하는 조건. 귀납법에서의 base 에 해당</p>\n</li>\n<li>\n<p>recursion case</p>\n<p>재귀적으로 실행되는 조건. 귀납법에서의 step에 해당</p>\n</li>\n</ol>\n<h2 id=\"재귀함수의-해석\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%B4%EC%84%9D\" aria-label=\"재귀함수의 해석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 해석</h2>\n<p>재귀적으로 생각하기 위해, 재귀함수를 n부터 1까지 따라 내려가는 것은 오히려 이해에 방해가 될 수 있다. 귀납법과 같이, 해당 함수가 정답이 return된다고 생각하고 재귀함수를 구성하면 된다!</p>\n<p>이에 대한 예시로, 정렬 중 하나인 merge sort를 구현해보도록 하자.</p>\n<h2 id=\"merge-sort\" style=\"position:relative;\"><a href=\"#merge-sort\" aria-label=\"merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort</h2>\n<p><code class=\"language-text\">merge sort</code>는 <code class=\"language-text\">merge algorithm</code>을 이용한 정렬이다. 머지 알고리즘은, 두 정렬된 배열을 합쳐 하나의 정렬된 배열을 만드는 알고리즘이다. 두 정렬된 배열 first, second가 있을 때, 각 배열의 <u>제일 앞 요소만을 비교하여 더 작은 것을 새로운 배열에 차례대로 빼서 넣어주</u>면 된다. c++로 코드를 다음과 같이 짜보았다. (인자는 순서대로 정렬된 결과 배열, 정렬된 첫번째 배열, 정렬된 두번째 배열, 결과 배열의 크기, 첫번째 배열의 크기, 두번째 배열의 크기를 의미한다)</p>\n<h3 id=\"merge-algorithm\" style=\"position:relative;\"><a href=\"#merge-algorithm\" aria-label=\"merge algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge algorithm</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first_size<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second_size<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 정렬된 두 배열을 합쳐 하나의 정렬된 배열로 만든다.</span>\n    <span class=\"token keyword\">int</span> firstcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> secondcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>first <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n            first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            firstcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n            second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            secondcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstcnt <span class=\"token operator\">>=</span> first_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//1. first 배열에 남은 값이 없는 경우 -> 새로운 배열에 second를 순서대로 넣는다.</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n                second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>secondcnt <span class=\"token operator\">>=</span> second_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n          \t<span class=\"token comment\">//2. second 배열에 남은 값이 없는 경우</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n                first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++에서는 배열의 이름이 배열의 주소를 의미하고, 이를 하나씩 증가시킬때마다 배열의 인덱스 한칸만큼 증가하는 것을 이용하였다. 살짝 골치아픈 것은 두 배열의 크기가 다를 수도 있고, 두 배열의 크기가 같더라도 한 배열이 값이 더 작은 것들이 많아 먼저 소진된다면, 결과 배열에 나머지 값들을 차례대로 넣어줘야하는데, 다른 방법이 생각나지 않아 단순하게 차례대로 넣어주도록 처리하였다.</p>\n<p>이제, merge sort를 재귀적으로 구현해보자! 핵심은 재귀적으로 생각하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// base case</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> new_arr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 결과를 저장할 새로운 배열</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        new_arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 절반씩 나누어서 merge_sort &amp; 합치기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// n이 홀수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token comment\">// n이 짝수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"merge-sort-algorithm\" style=\"position:relative;\"><a href=\"#merge-sort-algorithm\" aria-label=\"merge sort algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort algorithm</h3>\n<p>합병 정렬의 인자로는 정렬되지 않은 배열이 주어질 것이고, 이 함수를 통하여 배열을 정렬하는 것을 기대한다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>배열의 크기가 1보다 작다면, <strong>(정렬이 완료된 것이므로)</strong> 종료한다.</p>\n</li>\n<li>\n<p>step</p>\n<ol>\n<li>배열의 크기가 1보다 크다면, 배열을 앞부분 배열과 뒷부분 배열로 나누어서 각각 <code class=\"language-text\">merge sort</code> 해준다.</li>\n<li>정렬된 두 배열을 merge 알고리즘을 통하여 하나의 정렬된 배열로 합쳐준다.</li>\n</ol>\n</li>\n</ol>\n<p>잘 와닿지 않지만, 2-1은 수학적 귀납법에서 P(n-1)이 참이라고 가정하는 부분과 유사하다! 나누어서 각각 merge sort 해주는데, 여기서 그 안을 생각하지 말자!! <strong>merge sort의 결과로 정렬된 배열이 나온다고 가정하는 것이 핵심</strong>이다. base case가 잘 되어있다면, 이 함수는 정렬을 완벽하게 수행하여 리턴될 것이다!</p>","frontmatter":{"date":"July 01, 2022","title":"(DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/CDS01-array-1/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-Dijkstra/","nextSlug":"/ADsP-Review/","prevSlug":"/CDS01-array-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}