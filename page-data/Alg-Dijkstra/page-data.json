{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-Dijkstra/",
    "result": {"data":{"cur":{"id":"e1e5d260-58e0-58af-a974-6c589aef1c8d","html":"<p>Dijkstra(다익스트라) Algorithm은 그래프에서, <strong>한 노드에서 출발하여 다른 노드로 가는 최단 거리</strong>를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다.</p>\n<h2 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h2>\n<p>input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight)</p>\n<p>output : 1번노드에서 n번노드까지의 최단 거리</p>\n<p>​\t(입력 예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n</code></pre></div>\n<h1 id=\"그래프를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"그래프를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프를 표현하는 방법</h1>\n<p>weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데,</p>\n<ol>\n<li>\n<p>노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다.</p>\n<p>4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, <code class=\"language-text\">matrix[4][3]=5</code>와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다.</p>\n</li>\n<li>\n<p>한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)로 저장해도 헷갈리지만 않으면 좋다!</p>\n<p>위와 같은 상황일때, <code class=\"language-text\">node_4의 인접노드 : (5, 3번)</code>와 같이 표현할 수 있다.</p>\n</li>\n</ol>\n<p>2의 방법이 공간적으로 효율적이고 여러 엣지가 존재할 경우도 활용이 가능하다. <code class=\"language-text\">c++</code>에서는 pair와 vector배열을 이용하여 입력에 대하여 인접노드를 추가하는 형태로 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvector&lt;pair&lt;int, int&gt;&gt; E[100005];\nint main(void)\n{\n    int n, m; // number of nodes, number of edges\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++)\n    {\n        int from, to, weight;\n        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;\n        E[from].push_back(make_pair(to, weight));\n        E[to].push_back(make_pair(from, weight));\n    }\n   ...\n}</code></pre></div>\n<p>전역변수 E에 모든 엣지의 정보가 저장되어 있으므로, 이를 탐색하며 최단거리를 구할 수 있다.</p>\n<h1 id=\"dijkstra-의사-코드\" style=\"position:relative;\"><a href=\"#dijkstra-%EC%9D%98%EC%82%AC-%EC%BD%94%EB%93%9C\" aria-label=\"dijkstra 의사 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dijkstra 의사 코드</h1>\n<p>위와 같이 그래프를 만들고 나서는 다익스트라 알고리즘을 이용하여 그래프를 탐색하며 최단거리를 구할 수 있다.</p>\n<p>(1번노드에서 출발하여 n번노드까지의 최단거리를 구하는 다익스트라 알고리즘이라고 가정해보자) 우선 출발지부터 i번 노드까지의 최단거리를 기록하는 <code class=\"language-text\">D[i]</code>가 필요하다. D 배열의 각 원소는 처음에 매우 큰 값으로 세팅하도록 하고, 이후 탐색하면서 더 작은 비용의 거리가 발견된다면 업데이트 되도록 하므로, 큰 값으로 초기화를 해준다.</p>\n<ul>\n<li>\n<p>1번노드~1번노드의 거리는 0이므로, 이를 priority queue(이하 pq, 방문할 노드를 엣지의 거리 순으로 저장함)에 저장한다. D[시작노드] = 0 임을 확정짓는다.</p>\n<ul>\n<li>pq가 비어있을때 까지</li>\n</ul>\n<ol>\n<li>\n<p>pq에서 가장 거리가 짧은 엣지를 찾는다. 노드 번호 : <code class=\"language-text\">curNode</code>, 엣지 길이 : <code class=\"language-text\">curDist</code></p>\n</li>\n<li>\n<p>pq에서 해당 엣지(ex. x번 노드까지의 거리)을 제거한다. (방문 처리)</p>\n</li>\n<li>\n<p>만약 <code class=\"language-text\">D[curNode]</code>가 <code class=\"language-text\">curDist</code>보다 작지 않은경우, (D[ ] 업데이트 필요)</p>\n<ol>\n<li>\n<p>curNode의 인접한 노드들을 조사하는데…</p>\n</li>\n<li>\n<p><code class=\"language-text\">D[x]</code>와 <code class=\"language-text\">D[curNode]+curNode~x의 거리</code>를 비교하여 더 작은 값으로 X 노드까지의 최단거리를 업데이트한다.</p>\n</li>\n<li>\n<p>업데이트 되는 경우에는 해당 엣지 정보를 pq에 추가한다.</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>주의해야할 점은 크게 두가지가 있다.</p>\n<ul>\n<li>인접한 엣지 중에서 가장 weight가 짧은 것을 추출하는 과정에서, 일반 배열로 저장하는 것(<code class=\"language-text\">O(N)</code>)보다는 PQ로 저장하는 것(<code class=\"language-text\">O(log(N))</code>)이 효율적이다.</li>\n<li>A에서 C까지의 최단경로를 볼 때, 임의의 노드 B에서 A<del>B + B</del>C까지의 거리와 A~C의 거리를 비교하고, 더 짧은 것으로 거리를 확정짓는 것이 다익스트라의 핵심이다.</li>\n</ul>\n<p>코드는 아래와 같다. 만약 endNode가 추가적으로 필요하다면, 인자에 추가하고 endNode탐색시 종료하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void dijkstra(int startNode)\n{\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // (weight, nodeNo)\n    // startNode PQ에 추가\n\n    pq.push(make_pair(0, startNode));\n    d[startNode] = 0;\n    while (!pq.empty())\n    {\n        int curNode = pq.top().second;\n        int curDist = pq.top().first;\n        // printf(&quot;curNode : %d, curDist : %lld\\n&quot;, curNode, curDist);\n        //해당 노드 방문 처리\n        pq.pop();\n        if (d[curNode] &gt;= curDist)\n        {\n            for (int i = 0; i &lt; E[curNode].size(); i++)\n            {\n                //최단 거리 노드의 인접노드\n                int nextNode = E[curNode][i].second;\n                int nextDist = E[curNode][i].first;\n                // printf(&quot;nextDist : %lld, nextNode: %d\\n&quot;, nextDist, nextNode);\n                if (d[curNode] + nextDist &lt; d[nextNode])\n                {\n                    // printf(&quot;update needed\\n&quot;);\n                    // update 필요\n                    d[nextNode] = d[curNode] + nextDist;\n                    // pq push\n                    pq.push(make_pair(nextDist, nextNode));\n                }\n            }\n        }\n    }\n}</code></pre></div>\n<h2 id=\"다익스트라에서-경로를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%EC%97%90%EC%84%9C-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"다익스트라에서 경로를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다익스트라에서 경로를 표현하는 방법</h2>\n<p>위의 코드는 단지 x번 노드부터 n번 노드까지의 최단거리를 의미한다. 따라서, 어떠한 경로를 통하여 갔는지는 추가적인 작업이 필요하다. 이는 최단거리가 업데이트되어 확정되는 순간에 <strong>해당 노드를 방문하기 직전의 노드를 기록하면 된다</strong>! nextNode와 curNode를 통하여 최단거리를 비교하는 과정에서, 업데이트가 일어나면(최단거리 확정이 일어나면) 배열에다가 curNode를 저장하면 될 것이다.</p>\n<p>그렇게 하면 1 -> 4 -> 3 -> 5의 경로로 최단경로가 확정될 때, [0, 1, 0, 5, 0, 3]와 같이 저장될 것이다. 이를 스택에다가 넣어서 출력하면 깔끔하게 나올 것이다. 최종 코드는 다음과 같다. <code class=\"language-text\">codeforces 20C</code>문제에 대한 코드이다.! 결국 다익스트라가 이러한 틀로 구성되니까 참고하면 좋을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvector&lt;pair&lt;int, int&gt;&gt; E[100005];\nlong long d[100005];\nint prevNode[100005]; // 최단경로에서 i번째 노드의 이전 노드를 저장\n\nvoid dijkstra(int startNode, int endNode)\n{\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // (weight, nodeNo)\n    // startNode PQ에 추가\n\n    pq.push(make_pair(0, startNode));\n    d[startNode] = 0;\n    prevNode[startNode] = startNode;\n    while (!pq.empty())\n    {\n        int curNode = pq.top().second;\n        int curDist = pq.top().first;\n        // printf(&quot;curNode : %d, curDist : %lld\\n&quot;, curNode, curDist);\n        //해당 노드 방문 처리\n        pq.pop();\n        if (d[curNode] &gt;= curDist)\n        {\n            for (int i = 0; i &lt; E[curNode].size(); i++)\n            {\n                //최단 거리 노드의 인접노드\n                int nextNode = E[curNode][i].second;\n                int nextDist = E[curNode][i].first;\n                // printf(&quot;nextDist : %lld, nextNode: %d\\n&quot;, nextDist, nextNode);\n                if (d[curNode] + nextDist &lt; d[nextNode])\n                {\n                    // printf(&quot;update needed\\n&quot;);\n                    // update 필요\n                    d[nextNode] = d[curNode] + nextDist;\n                    // for path\n                    prevNode[nextNode] = curNode;\n                    // pq push\n                    pq.push(make_pair(nextDist, nextNode));\n                }\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, m, from, to, weight; // n : number of nodes, m : number of edges\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++)\n    {\n        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; // 1-based-node\n        E[from].push_back(make_pair(weight, to));\n        E[to].push_back(make_pair(weight, from));\n        // printf(&quot;from : %d, to : %d, weight : %lld\\n&quot;, from, to, weight);\n    }\n    for (int i = 1; i &lt;= n; i++)\n    {\n        d[i] = LLONG_MAX;\n    }\n    dijkstra(1, n);\n    if (d[n] == LLONG_MAX)\n    {\n        // update되지 않았다 -&gt; 경로 없다\n        printf(&quot;-1\\n&quot;);\n        return 0;\n    }\n    int c = n;\n    stack&lt;int&gt; path;\n    while (c != 1)\n    {\n        // printf(&quot;%d &quot;, c);\n        path.push(c);\n        c = prevNode[c];\n    }\n    path.push(c);\n    while (!path.empty())\n    {\n        printf(&quot;%d &quot;, path.top());\n        path.pop();\n    }\n    printf(&quot;\\n&quot;);\n    return 0;\n}</code></pre></div>","excerpt":"Dijkstra(다익스트라) Algorithm은 그래프에서, 한 노드에서 출발하여 다른 노드로 가는 최단 거리를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다. 문제 설명 input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight) output : 1번노드에서 n번노드까지의 최단 거리 ​\t(입력 예시) 그래프를 표현하는 방법 weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데, 노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다. 4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, 와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다. 한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)…","frontmatter":{"date":"May 28, 2022","title":"(Alg) 그래프 알고리즘 - Dijkstra와 최단 경로 출력","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/Alg-Dijkstra/"}},"next":{"id":"e0bdf019-16fc-5372-b49e-2db69640ff06","html":"<p>react로 이것저것 할때마다 가장 귀찮은 것 중 하나가 input을 다루는 일이였다. 회원가입페이지 등을 구성하면서, input을 객체로 갖고 관리하지만 중복되는 코드가 매우 많아 귀찮다. 그래서 customHook을 만들어보았는데, 케이스에 맞게 적용할 수 있을 것 같아 업로드한다.</p>\n<p>우선, 해당 hook에서 대응가능한 event는 다음과 같다.</p>\n<ul>\n<li>Text Input event</li>\n<li>Select event : mui를 이용하여 프론트를 구성하였기에 해당 이벤트를 처리하였음</li>\n<li>check event</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SelectChangeEvent <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@mui/material'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ChangeEvent<span class=\"token punctuation\">,</span> Dispatch<span class=\"token punctuation\">,</span> SetStateAction<span class=\"token punctuation\">,</span> useCallback<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">SetState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Dispatch<span class=\"token operator\">&lt;</span>SetStateAction<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">useInputObjectCallback</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  initialState<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  SetState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span>\n    e<span class=\"token operator\">:</span> ChangeEvent<span class=\"token operator\">&lt;</span>HTMLInputElement <span class=\"token operator\">|</span> HTMLTextAreaElement<span class=\"token operator\">></span> <span class=\"token operator\">|</span> SelectChangeEvent<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    inputType<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> onChangeInput <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span>\n      e<span class=\"token operator\">:</span> ChangeEvent<span class=\"token operator\">&lt;</span>HTMLInputElement <span class=\"token operator\">|</span> HTMLTextAreaElement<span class=\"token operator\">></span> <span class=\"token operator\">|</span> SelectChangeEvent<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n      inputType<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> checked <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>target <span class=\"token keyword\">as</span> HTMLInputElement<span class=\"token punctuation\">;</span>\n      <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>prevObj<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>prevObj<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">[</span>inputType<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'checkbox'</span> <span class=\"token operator\">?</span> checked <span class=\"token operator\">:</span> value<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">,</span> onChangeInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> useInputObjectCallback <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>사용법은 다음과 같다.</p>\n<p>우선, 인풋 객체와 초기화 객체를 만들어준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">//model.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">SignupInfo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  username<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  password<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  passwordConfirm<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  first_name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  last_name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  phone_number<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  address<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> SignupInit<span class=\"token operator\">:</span> SignupInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  username<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  password<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  passwordConfirm<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  first_name<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  last_name<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  phone_number<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  address<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>react input component에 사용할 때,</p>\n<ul>\n<li>custom hook을 호출하여 state, setState function, onChangeFunction을 할당받는다</li>\n<li>input 태그에 value는 <code class=\"language-text\">state.field_name</code>, onChange는 <code class=\"language-text\">(e)=>onChangeFunction(e, 'field_name')</code>으로 적어준다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">&lt;input\n\tplaceholder=&quot;아이디&quot;\n\tvalue={signupObj.username}\n\tonChange={(e) =&gt; onChangeSignupInput(e, &#39;username&#39;)}\n/&gt;\n\n&lt;OutlinedInput\n  placeholder=&quot;주소&quot;\n  value={signupObj.address}\n  onChange={(e) =&gt; onChangeSignupInput(e, &#39;address&#39;)}\n/&gt;</code></pre></div>\n<p>내가 주로 사용하는 mui에서도 편하게 사용이 가능하므로 input과 관련된 별도의 처리를 해주지 않아도 된다. 물론 validation을 해야한다면 onChange가 아닌 setState를 사용하면 될 것이다.</p>\n<p>필드네임을 문자열로 관리하는 것이 좋은 방법은 아니지만, 이렇게 하면 코드를 줄일 수 있다고 생각한다~!</p>","frontmatter":{"date":"April 23, 2022","title":"(React TS) 다양한 input을 다룰 수 있는 custom hook","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-input-custom-hook-ts/"}},"prev":{"id":"74408fa6-45a8-50c5-90bc-2d58f542b7aa","html":"<p>자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다.</p>\n<h1 id=\"수학적-귀납법\" style=\"position:relative;\"><a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B7%80%EB%82%A9%EB%B2%95\" aria-label=\"수학적 귀납법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수학적 귀납법</h1>\n<p>컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다.</p>\n<blockquote>\n<p>BASE : P(1)이 참이다.</p>\n<p>STEP : P(n-1) -> P(n)이 참이다.</p>\n<p>따라서, 모든 자연수 n에 대하여 P(n)은 참이다.</p>\n</blockquote>\n<p>BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 <strong>P(n-1)이 참이라고 믿는 것</strong>인데, 이유는 무엇일까.</p>\n<h2 id=\"p-q의-의미\" style=\"position:relative;\"><a href=\"#p-q%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"p q의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>P->Q의 의미</h2>\n<p>예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자.</p>\n<ul>\n<li>100점을 맞고, 치킨을 사주었다. => 참</li>\n<li>100점을 맞고, 치킨을 안사주었다. => 거짓</li>\n<li>100점을 안맞았고, 치킨을 안사주었다. => 참</li>\n<li>100점을 안맞았는데, 치킨을 사주었다. => <strong>참</strong></li>\n</ul>\n<p>마지막 경우가 참인 이유는 100점을 안맞았을때의 약속에는 아무 내용도 없기 때문에 판단할 수 없고, 약속을 어긴 것은 아니기 때문이다. 이를 <code class=\"language-text\">vacuously true</code>라고 부르는 사람도 있고, 어쨌든 약속은 100점을 안맞았을때는 신경쓸 필요가 없이 참이고, <strong>100점을 맞았을 때 치킨을 사주는지 여부에 따라서 약속의 참거짓이 결정</strong>된다.</p>\n<p>이를 위의 step에 대입시켜보자. P(n-1) -> P(n)이 참인 것을 보이려면, P(n-1)이 거짓인 경우에는 항상 참이므로(vacuously true), 굳이 무언가를 증명할 필요가 없다. 따라서, P(n-1)이 참인 것을 가정하고, P(n)이 참임을 보이면 되는 것이다. 주로, 귀납법에서는 해당 함수, 수식이 항상 성립함을 증명하므로 이와 같이 생각하면 편할 것이다.</p>\n<h1 id=\"배열array\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4array\" aria-label=\"배열array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Array)</h1>\n<p>이제 본격적으로 자료구조에 대하여 공부해보자. 가장 기본적인 자료구조는 배열이다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>배열은 연속된 주소에 동일한 type의 자료형들이 모여있는 것들을 말한다. C에서의 배열은 연속된 주소에 같은 타입의 데이터가 저장되어 있고, python과 같은 언어에서는 array가 아닌 list를 사용하는데, 이는 연속된 주소에 데이터를 가리키는 reference가 저장되어 있다. 따라서, list에는 여러가지 자료형을 넣을 수 있는 것이다.</p>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<p>배열의 가장 큰 장점은 배열의 연속된 공간에서 오는 특징에서 기인하는데, 바로 Access Time 이다. 보통 선형 자료구조에서는 처음부터 끝까지 가리키기 위해 index가 존재하는데, 배열에서는 연속된 공간에 같은 type이 모여있으므로, <strong>특정 인덱스에 대하여 상수시간에 접근이 가능하다</strong>.</p>\n<p>예를 들어, 배열에서 k번째의 data에 접근하려고 한다고 해보자. 이는 <code class=\"language-text\">배열의 시작주소 + (k-1)*(type size)</code>로 접근이 가능하며, 이는 배열의 크기가 크거나 k의 크기가 커도 항상 같은 시간(<code class=\"language-text\">O(1)</code>)에 접근할 수 있게 된다. LinkedList 등은 시작부터 k-1번 인덱스까지 차례대로 접근해야하므로, 이는 상수시간이 아니다.</p>\n<p>또한, 정렬된 배열(sorted array)의 경우 <code class=\"language-text\">search</code>가 빠르다. 이는 <code class=\"language-text\">Binary Search</code>(이분탐색)을 통해 <code class=\"language-text\">O(log n)</code>시간에 탐색이 가능하다. 참고로, 접근과 탐색은 특정 값을 찾는지 특정 위치의 값을 찾는지 이므로 완전히 다른 것이다.!</p>\n<p>정렬되지 않은 배열의 경우에는 탐색에는 일일이 탐색하는 <code class=\"language-text\">Linear Search</code>(선형탐색)을 통해 <code class=\"language-text\">O(n)</code> 시간이 걸리므로 느리다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<p>배열의 단점으로는 크기 변화에 대한 비용이 크다는 것이 있다. 배열은 선언시 정해진 크기만큼 메모리 공간을 차지하므로, 해당 크기를 넘어가게 되면 새로운 빈 공간을 찾아서 할당하고 이전의 값들을 복사하여 옮기는 작업이 필요하다! 우리가 사용하는 동적배열도 내부적으로는 정적배열로 구현되어있고, 크기 변화시 이러한 오버헤드가 발생함을 알 수 있다. 배열의 크기가 줄이는 경우에도 마찬가지.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>배열은 크기의 변화가 적고, 같은 자료형인 data들로 구성하는 것이 적합하다. 만약, 정렬이 되어있거나 정렬에 대하여 오래걸리지 않는다면 배열은 탐색 또한 빠른 자료구조이다!</p>\n<h1 id=\"재귀-recursion\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-recursion\" aria-label=\"재귀 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 (Recursion)</h1>\n<p>재귀는 보통 함수에서 많이 사용되는 개념으로, 함수 안에 해당 함수를 호출하는 것을 재귀함수라고 한다. loop를 사용하는 것을 재귀를 사용하면 더 직관적이고 코드가 짧아지는 경우가 많으므로 잘 알아두자.</p>\n<h2 id=\"재귀함수의-구성\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"재귀함수의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 구성</h2>\n<p>재귀는 위에서 공부한 <code class=\"language-text\">수학적 귀납법</code>과 매우 유사한 구조를 갖는다. 재귀 자체가 귀납적으로 구성되어 있기 때문이다. 재귀함수는 보통 base case와 recursion case로 나뉜다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>재귀함수를 탈출(return)하는 조건. 귀납법에서의 base 에 해당</p>\n</li>\n<li>\n<p>recursion case</p>\n<p>재귀적으로 실행되는 조건. 귀납법에서의 step에 해당</p>\n</li>\n</ol>\n<h2 id=\"재귀함수의-해석\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%B4%EC%84%9D\" aria-label=\"재귀함수의 해석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 해석</h2>\n<p>재귀적으로 생각하기 위해, 재귀함수를 n부터 1까지 따라 내려가는 것은 오히려 이해에 방해가 될 수 있다. 귀납법과 같이, 해당 함수가 정답이 return된다고 생각하고 재귀함수를 구성하면 된다!</p>\n<p>이에 대한 예시로, 정렬 중 하나인 merge sort를 구현해보도록 하자.</p>\n<h2 id=\"merge-sort\" style=\"position:relative;\"><a href=\"#merge-sort\" aria-label=\"merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort</h2>\n<p><code class=\"language-text\">merge sort</code>는 <code class=\"language-text\">merge algorithm</code>을 이용한 정렬이다. 머지 알고리즘은, 두 정렬된 배열을 합쳐 하나의 정렬된 배열을 만드는 알고리즘이다. 두 정렬된 배열 first, second가 있을 때, 각 배열의 <u>제일 앞 요소만을 비교하여 더 작은 것을 새로운 배열에 차례대로 빼서 넣어주</u>면 된다. c++로 코드를 다음과 같이 짜보았다. (인자는 순서대로 정렬된 결과 배열, 정렬된 첫번째 배열, 정렬된 두번째 배열, 결과 배열의 크기, 첫번째 배열의 크기, 두번째 배열의 크기를 의미한다)</p>\n<h3 id=\"merge-algorithm\" style=\"position:relative;\"><a href=\"#merge-algorithm\" aria-label=\"merge algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge algorithm</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first_size<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second_size<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 정렬된 두 배열을 합쳐 하나의 정렬된 배열로 만든다.</span>\n    <span class=\"token keyword\">int</span> firstcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> secondcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>first <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n            first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            firstcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n            second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            secondcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstcnt <span class=\"token operator\">>=</span> first_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//1. first 배열에 남은 값이 없는 경우 -> 새로운 배열에 second를 순서대로 넣는다.</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n                second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>secondcnt <span class=\"token operator\">>=</span> second_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n          \t<span class=\"token comment\">//2. second 배열에 남은 값이 없는 경우</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n                first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++에서는 배열의 이름이 배열의 주소를 의미하고, 이를 하나씩 증가시킬때마다 배열의 인덱스 한칸만큼 증가하는 것을 이용하였다. 살짝 골치아픈 것은 두 배열의 크기가 다를 수도 있고, 두 배열의 크기가 같더라도 한 배열이 값이 더 작은 것들이 많아 먼저 소진된다면, 결과 배열에 나머지 값들을 차례대로 넣어줘야하는데, 다른 방법이 생각나지 않아 단순하게 차례대로 넣어주도록 처리하였다.</p>\n<p>이제, merge sort를 재귀적으로 구현해보자! 핵심은 재귀적으로 생각하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// base case</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> new_arr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 결과를 저장할 새로운 배열</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        new_arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 절반씩 나누어서 merge_sort &amp; 합치기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// n이 홀수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token comment\">// n이 짝수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"merge-sort-algorithm\" style=\"position:relative;\"><a href=\"#merge-sort-algorithm\" aria-label=\"merge sort algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort algorithm</h3>\n<p>합병 정렬의 인자로는 정렬되지 않은 배열이 주어질 것이고, 이 함수를 통하여 배열을 정렬하는 것을 기대한다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>배열의 크기가 1보다 작다면, <strong>(정렬이 완료된 것이므로)</strong> 종료한다.</p>\n</li>\n<li>\n<p>step</p>\n<ol>\n<li>배열의 크기가 1보다 크다면, 배열을 앞부분 배열과 뒷부분 배열로 나누어서 각각 <code class=\"language-text\">merge sort</code> 해준다.</li>\n<li>정렬된 두 배열을 merge 알고리즘을 통하여 하나의 정렬된 배열로 합쳐준다.</li>\n</ol>\n</li>\n</ol>\n<p>잘 와닿지 않지만, 2-1은 수학적 귀납법에서 P(n-1)이 참이라고 가정하는 부분과 유사하다! 나누어서 각각 merge sort 해주는데, 여기서 그 안을 생각하지 말자!! <strong>merge sort의 결과로 정렬된 배열이 나온다고 가정하는 것이 핵심</strong>이다. base case가 잘 되어있다면, 이 함수는 정렬을 완벽하게 수행하여 리턴될 것이다!</p>","frontmatter":{"date":"July 01, 2022","title":"(DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/CDS01-array-1/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-Dijkstra/","nextSlug":"/FE-input-custom-hook-ts/","prevSlug":"/CDS01-array-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}