{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(1)-intro/",
    "result": {"data":{"cur":{"id":"022c18c1-b2d0-5e01-bc62-931440b696f2","html":"<h1 id=\"운영체제란\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80\" aria-label=\"운영체제란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제란?</h1>\n<blockquote>\n<p>OS</p>\n<p>Operating System</p>\n</blockquote>\n<p>운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..!</p>\n<p><strong>운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어</strong>이다.</p>\n<h3 id=\"운영체제는-자원을-어떻게-관리하고-보호할까\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B3%A0-%EB%B3%B4%ED%98%B8%ED%95%A0%EA%B9%8C\" aria-label=\"운영체제는 자원을 어떻게 관리하고 보호할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제는 자원을 어떻게 관리하고 보호할까?</h3>\n<p>OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 <strong>직접 접근할 수 없도록</strong> 한다. 이러한 자원에 접근할 수 있는 <code class=\"language-text\">interface</code>를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 <code class=\"language-text\">Virtualization</code>(가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다.</p>\n<p>자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 통해 엔진의 상태를 보는 것과 유사하다.</p>\n<p>따라서, 운영체제는 <strong>사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어</strong>라고 정의할 수 있다. OS의 목적이 이것이므로, 이를 위해 자원을 가상화하고, 인터페이스를 통하여 접근하도록 하고… 등으로 구성된 것이라고 보면 될 것 같다.</p>\n<h1 id=\"운영체제의-구성\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"운영체제의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 구성</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 135.55555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEHElEQVRIx42VW0xcVRSGv3MGZoCCtAgVKdIGxLYIQsdSwKHQ4aqUkhYU2oIlXrjaeqEMzB5EKqEasBo11YR4qYnGFxNNTGN8EuOLT76YmBpNfNTEl9YYEVM4y+wzezpTAk13sufszMz59lrrXxe4eaUBI0AvcBJ4ERgFugEFHAf6gWQ2XUrAPxI9J6dvAWaAF8xeMOBzwOvAeWAeSL018EeBMn0xPuBp4BljXQdQA7QBlUATEDaebAr0EVq2OfN7Mu+JvvkBsB4GTgBDYNWCdQjLbsCym7A8Ze57Qz/D0JWoQbFtgEdRMo6SQZRznFXxut/vDKYAfu64B0p6YG8PlJ2C6glYFHhLIHwdIvq5BsqJbpTTTUQ6mPyvnNByFd8IPP+nRuZh2UNM/JtGz1d3MvzrdoZ/yWPsai6fylYuShaTK9uZFg9qLWqhhjMjSYRXg8xKkHlpcPf7EmDoygkaXlvgI6nhggSZlkeYlRaU00b35RF6l07xknS570Zcl+0o8Oxf2cxIOzsbiihsbaX4SBsF9X3kB7rIKa3F8jwBVLlCiBunY0AE2E92SSYz0sCHxjo3js/+kcOr8pBRsd+o+A5wGtCwL4Hn8PjqsJNewfJ8jcd7Go/vKBn5dzMndYxdS4sLM3Y1izk5BOwiIz8Lyw5g2XX4MlPxeDNdgXZ3gmXrZN5mUiYTb3oxEyvasibUWlYcOCXZhK+30n4plkhJ5nkv0GDO9oYpp1VWThMRyYkDlZNDRFpYEGi9mJTw91zj8vqLoqvjY4+JWzPKyb4ZqKSFc7HEZKupVQ9QDGQAO4DOdQVhG0gjSu5KAEoUuHgDeNA0hHeBWeAz4AMjWNx9JZaB1KCkMJrYYsWBF24Ai4w1A0ApUA00a2nWWRgD+lGy15xvAFujN6ytD77fNIyNekAMWIaS8o2BEyv2OlV1DFM2B7puFqOkKhGY7QK1Yt2Xo0p6Uu7HTurFk7IPb/ou7ORGkrcUuL89+YPF+N9WgiiFKKk1Z1t/bENJkwtcE6gYxMRQN1Kd8GeARbet1U7DpYQyi+4dKAkkWOj4UNKJkjxCy7nMSwFdn9fz6BfN9C4F6f++nrFrfpRTypSUoBwtwB4Tu0qUPI6S/XGge5tThnIOu2UUXj3ItPhZkgIqBsbZfewNPpEiQsuVKEe/eADlHDDq3mc0sOJ5GDM/YnZ4FX4T6PtWu54DBKgOwXcC5wVmRbc8eNk85wS3Cz04atSKmIScEpvQPzbz2uxYsaXuwUo66Z5F4grHzgM/WdzGsky1BM2g0hVzBNgHpJtuYyeMUp0ZXnPO2gioa3cYqDAQnS7lZlY3m/GqL3obeNM02wngKWDwVsBuN37RwT8JHDYjNWA6eKMZr8Xmcp1i7RsBtUtngT4DGzVWPXY78foffO+o6MyDxioAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"os\" title=\"os\" src=\"/static/8899fcdb131df900902558feb87eaaf1/37523/os-1.png\" srcset=\"/static/8899fcdb131df900902558feb87eaaf1/e9ff0/os-1.png 180w,\n/static/8899fcdb131df900902558feb87eaaf1/f21e7/os-1.png 360w,\n/static/8899fcdb131df900902558feb87eaaf1/37523/os-1.png 720w,\n/static/8899fcdb131df900902558feb87eaaf1/00d43/os-1.png 1000w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>운영체제에서 자원을 관리하는 핵심은 <code class=\"language-text\">kernel</code>(커널)에서 담당한다. application(응용 프로그램)에서는 resource에 접근하기 위해 kernel을 통해야(커널 모드) 하며, 이는 <code class=\"language-text\">system call</code>을 호출하여 가능한 것이다. 예를 들어, C언어에서 표준 쉘 입출력에 사용되는 <code class=\"language-text\">printf</code>함수는 OS의 입출력을 담당하는 어떠한 시스템 콜을 호출할 것이다.</p>\n<p>커널은 자원(장치)을 driver를 통해 장치를 독점하는 것처럼 가상화하여 접근한다. driver는 하드웨어마다 달라 이미 OS에 구현이 되어있을수도 있고, 추가적으로 설치하거나 업데이트해야할 수도 있다. 또한, 드라이버는 커널 내부에 구현이 되어 있어 커널에서 바로 접근할 수도 있다.</p>\n<h1 id=\"운영체제의-3가지-개념\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-3%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90\" aria-label=\"운영체제의 3가지 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 3가지 개념</h1>\n<p><code class=\"language-text\">OSTEP</code>이라는 책에서는 OS에서 가장 중요한 개념으로 <code class=\"language-text\">Virtualization</code>, <code class=\"language-text\">Concurrency</code>, <code class=\"language-text\">Persistence</code>를 언급한다. 간단하게 의미를 생각해보면서 운영체제 복습을 본격적으로 시작해보자.</p>\n<ol>\n<li>\n<p>Virtualization(가상화)</p>\n<ol>\n<li>\n<p>CPU 가상화</p>\n<p>Processor(CPU)가 하나여도 동시에 여러 프로그램을 실행할 수 있다! CPU는 한번에 한가지 일만 처리한다고 배웠는데, 마치 많은 수의 가상의 CPU가 존재하는 듯한 illusion이 보인다. 이를 CPU 가상화라고 하며, 프로세스를 실행하고 멈추고 어떤 프로세스를 선택할 지 등을 OS가 선택하기 위해서는 많은 규칙들이 존재하며 이것을 배울 필요가 있다.</p>\n</li>\n<li>\n<p>메모리 가상화</p>\n<p>메모리 역시 process가 하나의 독립적인 메모리 주소를 보장받아서 사용하는 것처럼  보이는데, 이는 Memory virtualization이 되어있기 때문이다. 이러한 가상화를 통하여 OS는 목표(편리하고 안전하고 효율적으로 자원을 관리)를 달성할 수 있게 된다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>Concurrency(동시성)</p>\n<p>Process는 동시에 많은 일들을 처리하기 위해 <code class=\"language-text\">Thread</code>를 만들어서 처리한다. 이러한 multi thread환경에서는 공유되는 데이터를 정말 잘 공유하는 것처럼 보여야 동시성이 만족되는 것으로 보인다. 동시성을 활용하여 작업단위를 분할하고 병렬로 처리할 수 있게 된다.</p>\n</li>\n<li>\n<p>Persistence(영속성)</p>\n<p>메모리와 달리 보조 기억 장치는 컴퓨터가 종료되더라도 데이터가 남아있는다. 이는 <code class=\"language-text\">file system</code>으로 디스크 등의 저장장치가 추상화되어 구현되어있기 때문이다. 하지만 저장장치와의 I/O는 별도의 가상화를 거치지 않으며 영속적으로 데이터를 관리할 필요가 있다.</p>\n</li>\n</ol>\n<h2 id=\"운영체제의-목표\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"운영체제의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제의 목표</h2>\n<p>운영체제의 목표에 대하여 구체적으로 생각해보자. 해당 내용은 OSTEP의 번역본에서 발췌했다.</p>\n<p>가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 <code class=\"language-text\">개념</code>(abstraciton)들을 정의하는 것이다. 해당 추상화로 많은 것들을 직접 구현하고 생각하지 않아도 된다.</p>\n<p>다음으로는 <code class=\"language-text\">성능</code>이다. 성능은 주로 minimize overhead에 초점을 맞춘다. silver bullet은 없으므로, 최대한의 절충안을 찾아서 가야할 것이다.</p>\n<p>또한, OS와 프로그램, 혹은 프로그램들 간의 <code class=\"language-text\">보호</code>이다. 각 프로세스들은 다른 프로세스들로부터 고립(isolation)되어있어야 하며, 이는 보호의 핵심이다.</p>\n<p>그리고, <code class=\"language-text\">신뢰성</code>이다. 운영체제는 컴퓨터의 실행과 동시에 계속 실행중이여야하므로, 높은 신뢰성을 제공해야 한다. 추가적으로 에너지 효율성, 보안, 네트워크에서의 이동성 등이 있다.</p>\n<p>위의 목표를 달성하기 위해 우리는 운영체제가 어떤 기능들이 제공되고, 어떤 고민들을 해서 만들어졌는지 공부해볼 필요가 있다!</p>\n<p>우리는 운영체제 개발자가 아니지만, 보통 운영체제 위에서 돌아가는 프로그램을 만드므로 운영체제를 알아야 할 것이다.</p>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">OSTEP</a></p>\n<p>쉽게 배우는 운영체제 ‘조성호’</p>","excerpt":"운영체제란? OS Operating System 운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..! 운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어이다. 운영체제는 자원을 어떻게 관리하고 보호할까? OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 직접 접근할 수 없도록 한다. 이러한 자원에 접근할 수 있는 를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 (가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다. 자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 …","frontmatter":{"date":"June 26, 2023","title":"(OS) 운영체제 복습 [1. 운영체제의 개요]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(1)-intro/"}},"next":{"id":"d26a1107-cacb-5c12-bb01-14391a2df0aa","html":"<p>저번까지 Item 모델과 연관된 Question과 Answer 모델을 구현해보았다. 질문을 남긴 사람만 해당 질문을 변경할 수 있고, 답변은 관리자 페이지를 통해서만 달 수 있다.</p>\n<p>오늘은 쇼핑몰의 핵심 기능인 사용자가 물건을 장바구니에 담고, 구매하는 기능을 구현해보도록 하자.</p>\n<h2 id=\"장바구니cart-모델-만들기\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88cart-%EB%AA%A8%EB%8D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"장바구니cart 모델 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장바구니(Cart) 모델 만들기</h2>\n<p>장바구니에 대한 요구사항을 간단하게 정리해보자. 장바구니는 User model과 Item model을 <code class=\"language-text\">N:M</code>으로 연결해주는 테이블이므로, 별도의 모델로 작성하도록 한다. <code class=\"language-text\">python manage.py startapp cart</code>로 장바구니 앱을 만들자.</p>\n<ul>\n<li>사용자</li>\n<li>물건(item) &#x26; 물건의 현재 가격</li>\n<li>수량</li>\n<li>장바구니 추가/업데이트 시점(추가, 수정 등으로 7일 지나면 장바구니 삭제되도록 할 수 있을 것)</li>\n</ul>\n<p>위의 요구사항을 <code class=\"language-text\">cart/models.py</code>에 구현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Cart</span><span class=\"token punctuation\">(</span>models<span class=\"token punctuation\">.</span>Model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    user <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>ForeignKey<span class=\"token punctuation\">(</span>settings<span class=\"token punctuation\">.</span>AUTH_USER_MODEL<span class=\"token punctuation\">,</span> on_delete<span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>CASCADE<span class=\"token punctuation\">,</span> verbose_name<span class=\"token operator\">=</span><span class=\"token string\">'사용자'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 사용자 삭제되면 장바구니도 삭제되도록</span>\n    item <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>ForeignKey<span class=\"token punctuation\">(</span>Item<span class=\"token punctuation\">,</span> on_delete<span class=\"token operator\">=</span>models<span class=\"token punctuation\">.</span>CASCADE<span class=\"token punctuation\">,</span> verbose_name<span class=\"token operator\">=</span><span class=\"token string\">'상품'</span><span class=\"token punctuation\">)</span>\n    amount <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>PositiveIntegerField<span class=\"token punctuation\">(</span>verbose_name<span class=\"token operator\">=</span><span class=\"token string\">'수량'</span><span class=\"token punctuation\">,</span> default<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    date_created <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>DateField<span class=\"token punctuation\">(</span>verbose_name<span class=\"token operator\">=</span><span class=\"token string\">'최종 수정 일자'</span><span class=\"token punctuation\">,</span> auto_now<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 추가되거나, 수정되면 update되도록 함</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Meta</span><span class=\"token punctuation\">:</span>\n        db_table <span class=\"token operator\">=</span> <span class=\"token string\">'cart'</span>\n        verbose_name <span class=\"token operator\">=</span> <span class=\"token string\">'장바구니 물건'</span>\n        verbose_name_plural <span class=\"token operator\">=</span> <span class=\"token string\">'장바구니 물건들'</span></code></pre></div>\n<p>다음으로는, serializer를 구현한다. serializer에서는 아래의 두가지 필드가 추가되면 좋을 것 같다.</p>\n<ul>\n<li>총 금액</li>\n<li>주문이 가능한지 여부(품절이 되면 주문이 불가능)</li>\n</ul>\n<p>사용자에게 해당 필드를 제공하면서, 동시에 Create나 Update 할때는 필요 없으므로 <code class=\"language-text\">readonly</code>로 선언하도록 한다. 추가적으로, user 정보 역시 <code class=\"language-text\">request.user</code>로만 받고, <strong>body를 통하여 변경되면 안되므로 readonly여야한다</strong>.</p>\n<h3 id=\"serializermethodfield---set-value-in-serializers-field\" style=\"position:relative;\"><a href=\"#serializermethodfield---set-value-in-serializers-field\" aria-label=\"serializermethodfield   set value in serializers field permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SerializerMethodField - set value in serializer’s field</h3>\n<p>총 금액, 주문 가능 여부와 같은 필드는 참조를 통해 바로 알아낼 수 있는 값이 아니므로, 별도의 함수를 통하여 값을 가져와야 한다. 이는 <code class=\"language-text\">SerializerMethodField</code>로 선언해주면 된다. <a href=\"https://www.django-rest-framework.org/api-guide/fields/#serializermethodfield\">공식문서참고</a></p>\n<p>인자로 <code class=\"language-text\">method_name</code> 을 명시하지 않는다면 <code class=\"language-text\">get_{field_name}</code>의 함수를 오버라이드 하면 되고, 명시한다면 해당 함수를 작성하면 해당 함수를 통하여 값을 가져온다. 해당 함수는 model instance를 <code class=\"language-text\">obj</code>인자로 받아 접근할 수 있다.</p>\n<p><code class=\"language-text\">cart/serializers.py</code>는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CartSerializer</span><span class=\"token punctuation\">(</span>serializers<span class=\"token punctuation\">.</span>ModelSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    user <span class=\"token operator\">=</span> serializers<span class=\"token punctuation\">.</span>CharField<span class=\"token punctuation\">(</span>source<span class=\"token operator\">=</span><span class=\"token string\">'user.username'</span><span class=\"token punctuation\">,</span> read_only<span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    total_price <span class=\"token operator\">=</span> serializers<span class=\"token punctuation\">.</span>SerializerMethodField<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    is_available_now <span class=\"token operator\">=</span> serializers<span class=\"token punctuation\">.</span>SerializerMethodField<span class=\"token punctuation\">(</span>method_name<span class=\"token operator\">=</span><span class=\"token string\">'is_available'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">get_total_price</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 총 금액 리턴</span>\n        <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> obj<span class=\"token punctuation\">.</span>amount\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">is_available</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 현재 수량이 주문 가능한지</span>\n        <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">.</span>stock_count <span class=\"token operator\">>=</span> obj<span class=\"token punctuation\">.</span>amount\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> validated_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># user, itm_info 이미 존재한다면 수량만 누적하는 update</span>\n        cart_exist <span class=\"token operator\">=</span> Cart<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">=</span>validated_data<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> item<span class=\"token operator\">=</span>validated_data<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'item'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> cart_exist<span class=\"token punctuation\">:</span>\n            validated_data<span class=\"token punctuation\">[</span><span class=\"token string\">'amount'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> validated_data<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'amount'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> cart_exist<span class=\"token punctuation\">.</span>amount\n            <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>cart_exist<span class=\"token punctuation\">,</span> validated_data<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 존재하지 않는다면 create</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">(</span>validated_data<span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\"># item을 보여줄 때, id만 보여주는 것이 아닌, 안의 내용들을 ItemCartSerializer 통해서 보여주도록 해야함</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">to_representation</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        response <span class=\"token operator\">=</span> <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to_representation<span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span>\n        response<span class=\"token punctuation\">[</span><span class=\"token string\">'item'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ItemCartSerializer<span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data\n        <span class=\"token keyword\">return</span> response\n    \n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Meta</span><span class=\"token punctuation\">:</span>\n        model <span class=\"token operator\">=</span> Cart\n        fields <span class=\"token operator\">=</span> <span class=\"token string\">\"__all__\"</span></code></pre></div>\n<ul>\n<li>\n<p>SerializerMethodField를 이용하면 <u>필드마다 동적인 데이터로 처리</u>해줄 수 있다. 또한 이는 <strong>항상</strong> <code class=\"language-text\">read_only</code> 속성이므로, deserialize 과정에서는 필요가 없다.</p>\n</li>\n<li>\n<p>serializer를 통해서 Cart instance를 create가 될 때, <strong>해당 사용자에게 이미 있던 item이라면 <code class=\"language-text\">update</code>가 되도록 해야한다!</strong> 따라서 create 함수를 오버라이드 해주었다.</p>\n</li>\n<li>\n<p>이전에 사용자의 이름을 마스킹하기 위해 <code class=\"language-text\">to_representation</code> 함수를 사용했었는데, 여기서는 item에 대한 JSON을 보여주기 위해 사용할 수 있다. 추가적으로, item은 <code class=\"language-text\">ItemCartSerializer</code>의 data로 가져오지 않으면 item__id만 가져오므로 ItemCartSerializer를 정의하여 장바구니에 담은 아이템의 정보들을 보여줄 수 있을 것이다. serializer의 field로 ItemCartSerializer를 갖도록 하는 방법도 있지만, 그렇게 하면 request에 Item id만이 아닌 Item model 객체를 실어야 하므로 이 방법이 더 좋아 보인다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ItemCartSerializer</span><span class=\"token punctuation\">(</span>serializers<span class=\"token punctuation\">.</span>ModelSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    item_id <span class=\"token operator\">=</span> serializers<span class=\"token punctuation\">.</span>IntegerField<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Meta</span><span class=\"token punctuation\">:</span>\n        model <span class=\"token operator\">=</span> Item\n        fields <span class=\"token operator\">=</span> <span class=\"token string\">\"__all__\"</span></code></pre></div>\n<p>이제, ViewSet을 만들어보자!</p>\n<h3 id=\"cartmodelviewset---메소드에-따라-오버라이드\" style=\"position:relative;\"><a href=\"#cartmodelviewset---%EB%A9%94%EC%86%8C%EB%93%9C%EC%97%90-%EB%94%B0%EB%9D%BC-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C\" aria-label=\"cartmodelviewset   메소드에 따라 오버라이드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CartModelViewSet - 메소드에 따라 오버라이드</h3>\n<p>요구사항은 다음과 같다.</p>\n<ol>\n<li>\n<p>장바구니는 <strong>본인의 것만 보여주도록</strong> 해야한다.</p>\n</li>\n<li>\n<p>또한, 수정에 있어서 <strong>item 자체는 수정이 불가능하고 <u>수량만 수정 가능</u>하도록</strong> 한다. 이러한 요구사항에 맞게 ViewSet을 구성해보도록 하자.</p>\n</li>\n</ol>\n<p>우선, 요청이 들어온 사용자가 갖고 있는 Cart만 보여줘야 하므로, <code class=\"language-text\">queryset</code>을 수정해야한다.! 이는 <code class=\"language-text\">get_queryset()</code>을 오버라이드 하면 될 것이다.</p>\n<p>수정에 있어서는 입력 인자를 <code class=\"language-text\">amount</code>만 가능하게 해야하므로, PUT 요청에 대하여는 다른 <code class=\"language-text\">serializer_class</code>를 선택하도록 한다. Update를 위한 serializer는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CartUpdateSerializer</span><span class=\"token punctuation\">(</span>serializers<span class=\"token punctuation\">.</span>ModelSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    item <span class=\"token operator\">=</span> ItemCartSerializer<span class=\"token punctuation\">(</span>read_only<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 아이템 정보 보여주기 read_only</span>\n\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Meta</span><span class=\"token punctuation\">:</span>\n        model <span class=\"token operator\">=</span> Cart\n        fields <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'amount'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'item'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>item을 read_only로 하였기에 amount만 입력받을 것이다. amount는 Cart model에서 <code class=\"language-text\">PositiveIntegerField</code>로 정의되어있기에 serializer에서 별도의 validation은 진행하지 않았다. 이를 이용한 ModelViewSet은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CartModelViewSet</span><span class=\"token punctuation\">(</span>viewsets<span class=\"token punctuation\">.</span>ModelViewSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    queryset <span class=\"token operator\">=</span> Cart<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    serializer_class <span class=\"token operator\">=</span> CartSerializer\n    permission_classes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>IsAuthenticated<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 인증된 사용자만 접근 가능</span>\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">get_queryset</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 본인이 장바구니에 포함시킨 것들만 보여주도록 해야함(타인 접근 불가)</span>\n        queryset <span class=\"token operator\">=</span> Cart<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">=</span>self<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> queryset\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">get_serializer_class</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>action <span class=\"token operator\">==</span> <span class=\"token string\">'update'</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> CartUpdateSerializer\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> CartSerializer\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">perform_create</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> serializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># cart 생성되기 전, serializer에 auth에 해당하는 user 정보 넣어줘야함</span>\n        serializer<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span>user<span class=\"token operator\">=</span>self<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이제 테스트를 해보자!</p>\n<ul>\n<li>\n<p>POST (create)</p>\n<p>item_id와 amount를 body에 넣으면 생성된다.</p>\n</li>\n<li>\n<p>GET</p>\n<p>본인이 담은 장바구니만 볼 수 있다.</p>\n</li>\n<li>\n<p>UPDATE</p>\n<p>amount만 수정 가능하다.</p>\n</li>\n<li>\n<p>DELETE</p>\n<p>본인의 것만 삭제할 수 있다.</p>\n</li>\n</ul>\n<p>모두 완료되었음을 확인해보았다~ api 테스트는 DRF에서 localhost:8000으로 접속시 디버깅모드로 확인할 수 있으니, 편하게 이를 사용하였다.</p>\n<p>서버 소스코드는 <a href=\"https://github.com/choieastsea/market-guri-django/commit/91de4eca0979d470484655ee452d7b5efd158f7f\">여기와</a>, <a href=\"https://github.com/choieastsea/market-guri-django/commit/a66ff714d2a4a278711d9034429012bd2dfee799\">여기에</a> 있다.</p>\n<h3 id=\"csrf-token-관련-로직-수정\" style=\"position:relative;\"><a href=\"#csrf-token-%EA%B4%80%EB%A0%A8-%EB%A1%9C%EC%A7%81-%EC%88%98%EC%A0%95\" aria-label=\"csrf token 관련 로직 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSRF token 관련 로직 수정</h3>\n<p>프론트에서 장바구니를 담는 부분을 확인하려고 했는데, CSRF Token 관련하여 내가 잘못한 부분이 있어 수정을 해야할 것 같다. (이전 게시물의 내용은 바꿔 놓을 것)</p>\n<p>CSRF는 만료되므로 주기적으로 점검해줘야한다. 따라서, 프론트에서 페이지가 바뀔때마다 CSRF token을 요청하도록 수정하였고, 서버에서도 이에 대하여 토큰을 발급하도록 api를 추가해주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> django<span class=\"token punctuation\">.</span>middleware<span class=\"token punctuation\">.</span>csrf <span class=\"token keyword\">import</span> get_token\n<span class=\"token keyword\">from</span> django<span class=\"token punctuation\">.</span>http <span class=\"token keyword\">import</span> HttpResponse\n\n<span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_csrf</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    unsafe method에 대하여 csrf 검증을 위한 토큰을 발급하는 함수\n    \"\"\"</span>\n    csrf_token <span class=\"token operator\">=</span> get_token<span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span>\n    response <span class=\"token operator\">=</span> HttpResponse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>csrf_token<span class=\"token punctuation\">)</span>\n    response<span class=\"token punctuation\">.</span>set_cookie<span class=\"token punctuation\">(</span><span class=\"token string\">'csrftoken'</span><span class=\"token punctuation\">,</span>csrf_token<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># print(response.cooki)</span>\n    <span class=\"token keyword\">return</span> response</code></pre></div>\n<p>위의 view 함수를 myuser app에 추가하였고, 프론트에서 주기적으로 호출하여 token을 쿠키의 형태로 유지하도록 구현하였다.</p>\n<h2 id=\"프론트와-함께보기\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%A0%ED%8A%B8%EC%99%80-%ED%95%A8%EA%BB%98%EB%B3%B4%EA%B8%B0\" aria-label=\"프론트와 함께보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프론트와 함께보기</h2>\n<p>프론트 코드는 <a href=\"https://github.com/choieastsea/market-guri-react/commit/c007c68cd908c98dffbe812eceff4fce0c4aad03\">여기</a>를 참고한다.</p>\n<ul>\n<li>\n<p>아이템 페이지</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABMUlEQVQoz5VT26qDMBD0/39Lq/VeaB+kL32pCsop3q8xUzYloj3xwFkYdrPJDjubRIuiCPf7HeSfz6cArZMkwbdxzn9B5qVpqiJpy7LsoDJ5vugYxnmBlmUZLpcLbrfbIa7XK6QSih+Ph1hTrSSdGcfCObQ4jmGaJlzXheM4sG179duY9ouiwDzPGMdRQCmZZnU+n+H7PjzP23kZE1kQBMjzHGVZ7gi2pIQdIXVjWdbaHeUlIe3XdS06ZIwdX8qWkEh0XRcjOJ1OMAxjJSTfNM1KME3T/yRvY9nhq2wwzBx1zzCxZSd1R0gyZaEKjvPpsG27z3M6kCsI0zQVRWEYisF/Q+bJ9123ITmYIQ2573slhmHAq+rwU7Zom2Z93PyvDukQva+qqpQ/gXGSqP5JKnsDFfmBrdRe9usAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"item_page\"\n        title=\"item_page\"\n        src=\"/static/345a25ba3193c53bf805b276dc3aa2b0/37523/item_page.png\"\n        srcset=\"/static/345a25ba3193c53bf805b276dc3aa2b0/e9ff0/item_page.png 180w,\n/static/345a25ba3193c53bf805b276dc3aa2b0/f21e7/item_page.png 360w,\n/static/345a25ba3193c53bf805b276dc3aa2b0/37523/item_page.png 720w,\n/static/345a25ba3193c53bf805b276dc3aa2b0/302a4/item_page.png 1080w,\n/static/345a25ba3193c53bf805b276dc3aa2b0/07a9c/item_page.png 1440w,\n/static/345a25ba3193c53bf805b276dc3aa2b0/28b65/item_page.png 2414w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>수량을 체크하고 장바구니를 누르면 장바구니에 추가된다.</p>\n</li>\n<li>\n<p>장바구니 페이지</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApklEQVQoz62R3QrDIAyFff/3q94UKfZCW3bltNL5c0YcHYPRdqweyE2iX3ISxjlH13UQQkBKCa01KNf3PWKMIJVSdmOrb2I40efjo3pMBbd7BKNECAHruiLnfDjN/pQFmTiP/AIOwwClVAVeVQXO81x3Z62tHQn8T9DfCiS7V0BfQLI7TdPpAX454NsyhXOuzYTLssB739byOI5IKbWxTPszxjSx/AQS4GK2VUqBagAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cart_page\"\n        title=\"cart_page\"\n        src=\"/static/1f1498ed3a70de1e5dd480c42e1f7752/37523/cart_page.png\"\n        srcset=\"/static/1f1498ed3a70de1e5dd480c42e1f7752/e9ff0/cart_page.png 180w,\n/static/1f1498ed3a70de1e5dd480c42e1f7752/f21e7/cart_page.png 360w,\n/static/1f1498ed3a70de1e5dd480c42e1f7752/37523/cart_page.png 720w,\n/static/1f1498ed3a70de1e5dd480c42e1f7752/302a4/cart_page.png 1080w,\n/static/1f1498ed3a70de1e5dd480c42e1f7752/07a9c/cart_page.png 1440w,\n/static/1f1498ed3a70de1e5dd480c42e1f7752/dc0c1/cart_page.png 2348w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>본인의 장바구니에 담긴 물건들과 총 수량, 가격과 재고에 따른 현재 구매 가능 여부를 보여준다.</p>\n</li>\n</ul>\n<p>오늘 배운 내용을 복습해보면,</p>\n<ul>\n<li>read_only <code class=\"language-text\">SerializerField</code>로 보여줄때만 사용하는 필드를 추가할 수 있다</li>\n<li><code class=\"language-text\">to_representation</code>을 오버라이드하여 nested serializer를 보기 좋게 할 수 있다 (request 받을 때에는 단순 id로만 받고, response는 model의 데이터를 해당 모델의 시리얼라이저로 보여줌)</li>\n<li>ViewSet에서 request method 등에 따라 serializer를 바꿔줄 수 있다</li>\n<li>get_queryset에서 필요에 따라 <code class=\"language-text\">self.request.user</code>에 접근할 수 있다</li>\n</ul>\n<p>다음에는 장바구니를 통하거나 상품 페이지에서의 구매를 할 수 있도록 <code class=\"language-text\">구매</code> 기능을 만들어보자! 지금은 프론트가 매우 못생겼지만, 심심하면 바꾸도록 하겠다…^_^</p>","frontmatter":{"date":"June 16, 2023","title":"(Django) 장고 api 서버를 이용한 프로젝트 [12- nested model & serializer, 장바구니 모델 추가]","categories":"BE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/Django(12)- nested model & serializer/"}},"prev":{"id":"328e4644-a010-5a01-a36b-43fec5db2009","html":"<p>운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자!</p>\n<h1 id=\"von-neumann-architecture\" style=\"position:relative;\"><a href=\"#von-neumann-architecture\" aria-label=\"von neumann architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Von Neumann Architecture</h1>\n<blockquote>\n<p>폰 노이만 구조</p>\n</blockquote>\n<p>컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 <code class=\"language-text\">CPU</code>로부터 <strong>fetch, decode, execute, writeback의 과정</strong>을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 <code class=\"language-text\">Memory</code>에 올라가(load)있어야하며, CPU는 <code class=\"language-text\">Program Counter</code> 레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다.</p>\n<p>이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 <code class=\"language-text\">폰 노이만 구조</code>라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 <u>실행하기 위해서는 메모리에 로드가 되어야 한다</u>는 것을 알 필요가 있다.</p>\n<h1 id=\"cpu\" style=\"position:relative;\"><a href=\"#cpu\" aria-label=\"cpu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU</h1>\n<blockquote>\n<p>Central Processing Unit</p>\n<p>중앙 처리 장치</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACoUlEQVQoz23R3U+SURzAcf+XbrvoplqrddPa2tq66rqbttYqc26WaFipmb1oolZSusTAlwaai3gVQYOHF8FHEQRFBeRlLITx9gDPyznnVwirizoXv6vzOd+zc5rgn0UIAQAkIPUEpeg3Tb80GafdOplTNbwq69Fv2fcBAOPanqb/4drkOD4cSCT3M/G9dCZVCLhijm87yXA2Hk39CTQwOT4JY0KAABwPILHDhHZ+eUVrLzPlZCjbfGaMWtgGguqygXmBLzHFYqFUZAr5XL6QK+ZzBQBsnqObT0vvnnrvNG1HcbT72szAbaUXNtIkDceFGmbZajyU3nUlY3s/g2uH27ZY2J8kgKwL3geXJkQXJzXWVarqbD//eeSeOgB+B3bWrgm4hkuF0v1zY7dOvu26Iu+8PHXjhOTpdTkAsqi8bRcmO87KdU47FfX0XZ06cO4c8Rma0EAA18u8gFWjVpn4u0xikA8YPokWdVOUAORoP2Z2m0y2H8GI2w9JEnZAPhivZmnY/FsGvgDFBAQ8FtD4cnpY1xIuIGAMEdqWk2qS0gO3coP3InqO8WlSxQhdWYIKg+sPhhIG1v6CU7/Wptod9EO02MdGvvApK4S+2iOdevpO1Cz2J16BV4r9H7IH42u7rRBdInWMPZu8Qsl/lBu8I279IEhnkGsd+fxA+VxrE0v6rtjMu4BzFnR2rLdmVnTrRgk4thrlkovKqmaZZZPS/cTsGGK1hqLNwgS3BLt7mRpY8PSEVhRu6xirNTA6TcKiMhofcw5X458VoGoBcT+MtoCoA3p6QdILg/OgHobxVhC3QdcjeC6C7j4Y7oU3z2DoJrTIQdXAZVwqCQUWVXjEcYitIKaKygLmWVTlEStgjkNVDlVZVGZRmUPVCmLKuPQb/wJXool93Z1D2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cpu_architecture\"\n        title=\"cpu_architecture\"\n        src=\"/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png\"\n        srcset=\"/static/c9124f66758e84c155c133f783a2c728/e9ff0/cpu_architecture.png 180w,\n/static/c9124f66758e84c155c133f783a2c728/f21e7/cpu_architecture.png 360w,\n/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png 720w,\n/static/c9124f66758e84c155c133f783a2c728/7527b/cpu_architecture.png 754w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>CPU는 명령어를 해석하고 실행하는 장치이며, 이를 수행하기 위해 많은 Unit들이 존재한다. 주요 구성은 다음과 같다.</p>\n<ul>\n<li>\n<p>Control Unit</p>\n<p>decoder를 통해 binary코드의 명령어를 해석하고, 이에 적절한 제어 신호(메모리에서 레지스터로 가져오기, 연산, 쓰기)를 발생시킨다. 또한, 명령어의 실행 순서를 결정한다.</p>\n</li>\n<li>\n<p>Arithmetic &#x26; Logic Unit(ALU)</p>\n<p>연산 명령에 대하여 연산을 수행한다. 모든 연산은 atomic하며, 산술연산(ex 덧셈)과 논리연산(ex AND)으로 구분되어 수행된다.</p>\n</li>\n<li>\n<p>Register</p>\n<p>CPU가 갖는 <u>임시 저장소</u>. 연산을 수행하거나, 명령어를 fetch하는 것들이 각각의 레지스터에서 일어난다. 다음 명령어의 위치를 가리키고 있는 <code class=\"language-text\">Program Counter</code>(PC), 데이터를 보관하기 위한 <code class=\"language-text\">Data Register</code>와 주소를 저장하기 위한 <code class=\"language-text\">Address Register</code>, 실행 중인 명령어를 가져오는 <code class=\"language-text\">Instruction Register</code>, 메모리에 저장하거나 가져올 때 사용하는 <code class=\"language-text\">Memory Address Register</code>, <code class=\"language-text\">Memory Buffer Register</code> 등이 있다.</p>\n</li>\n</ul>\n<p>CPU가 다른 기기들과 주고 받는 정보는 크게 3가지로 나눌 수 있다.</p>\n<ul>\n<li>Control</li>\n<li>Address</li>\n<li>Data</li>\n</ul>\n<p>따라서 이는 위의 그림처럼 각각의 역할을 수행하는 버스를 통하여 주변 장치와 연결을 한다.</p>\n<p>CPU는 한번에 처리할 수 있는 데이터의 크기에 따라 오늘날 32bit, 64bit 컴퓨터로 나뉜다. 32비트 주소 체계는 2^32개의 주소를 담을 수 있다. 메모리는 한 주소당 1Byte를 갖으므로 2^32Byte = 4GB 정도의 데이터를 가리킬 수 있는 것이다. 따라서 32비트 컴퓨터는 최근에 사용되지 않는다.</p>\n<h2 id=\"interrupt\" style=\"position:relative;\"><a href=\"#interrupt\" aria-label=\"interrupt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt</h2>\n<p>CPU는 매우 빠르다.! 하지만, 주변 장치의 증가로 매우 느린 I/O 작업이 늘어나게 되면서 기존의 polling 방식은 성능이 낮아졌다. 이는 CPU가 IO device의 상태를 주기적으로 검사하여 데이터를 처리하는 방식으로, CPU의 본래 역할(fetch, decode, execute)에 I/O까지 수행하게 되어 매우 느리다. I/O가 수행될때까지 기다려야하기 때문이다.</p>\n<p>Interrupt 방식은 IO작업을  CPU가 기다리지 않고 다른 곳(입출력 관리자)에 위임하고, 완료되면 Interrupt 신호를 발생시키는 것이다. CPU는 I/O가 수행되는 동안 다른 작업들을 수행하면 되고, interrupt가 발생하면 지금 하던 작업을 멈추고 가져와진 데이터로 작업을 이어가면 된다.</p>\n<h3 id=\"direct-memory-accessdma\" style=\"position:relative;\"><a href=\"#direct-memory-accessdma\" aria-label=\"direct memory accessdma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Direct Memory Access(DMA)</h3>\n<p>기본적으로 Memory에 대한 접근 권한은 CPU만 갖고 있다. 따라서 장치들이 interrupt를 발생시켜 CPU가 메모리에 작업을 하도록 전송할 것이지만, 이것은 느리다. 따라서 I/O 수행시 <strong>장치들이 직접 메모리에 접근할 수 있다면 CPU를 더 효율적으로 사용할 수 있을 것</strong>이다. <code class=\"language-text\">DMA Controller</code>에게 CPU가 메모리에 대한 정보를 제공하고, 입출력 장치와 메모리 간의 직접적인 연결을 수행할 수 있도록 한다.</p>\n<p>DMA를 통해 메모리를 관리한다면, 메모리 구조가 복잡해질 수 있다.(CPU가 사용하는 영역과 입출력 장치가 사용하는 영역들의 혼재) 따라서 메모리를 OS 영역, CPU 영역, 입출력 작업 영역 등으로 분리하여 관리하는 방법을 <code class=\"language-text\">MMIO</code> (Memory Mapped I/O) 기법이라고 한다.</p>\n<p>DMA를 통해 메모리에 접근하면 여러 장치들(CPU 포함)이 동시에 메모리에 접근하려는 순간이 생긴다. 이때, CPU의 작업속도가 훨씬 빠르므로 CPU가 메모리 접근 순서를 양보하는데, 이를 <code class=\"language-text\">cycle stealing</code> 이라고 한다.</p>\n<h2 id=\"parallel-processing\" style=\"position:relative;\"><a href=\"#parallel-processing\" aria-label=\"parallel processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Processing</h2>\n<p>CPU의 성능을 향상시키기 위해 CPU의 클럭을 높이거나, 캐시의 크기를 늘리는 방법이 가장 대표적이다. 하지만, 클럭을 높이면 저항이 많아져 발열이 증가하게 되므로 이러한 하드웨어적인 향상에는 비용등의 현실적인 제약이 있다. 따라서, <strong>CPU 코어를 여러개 두어 병렬적으로 처리</strong>하는 기법들이 소프트웨어적으로 고려되고 있다.</p>\n<p>CPU가 명령어를 실행하는 작업은 크게 (Fetch, Decode, Execute, Write)의 4개의 순서대로 별도의 위치에서 이루어진다. 이때, 한 코어에서 작업을 나누어 병렬로 처리하는 <code class=\"language-text\">Pipeline</code>기법이라고 하고, 여러 코어에서 동시에 작업을 수행하는 것을 <code class=\"language-text\">Super-scalar</code>기법이라고 한다.</p>\n<h1 id=\"memory\" style=\"position:relative;\"><a href=\"#memory\" aria-label=\"memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory</h1>\n<blockquote>\n<p>저장 장치</p>\n</blockquote>\n<p>폰노이만 구조에서, CPU는 명령어를 메모리에서부터 가져와서 실행한다. 메모리는 프로그램과 데이터를 저장하는 공간으로, R/W가 모두 가능한 RAM과 Read Only Memory인 ROM으로 구분된다.</p>\n<ul>\n<li>\n<p>RAM (Random Access Memory)</p>\n<p>주소를 통하여 메모리 공간에 접근하므로, 모든 공간에의 접근 시간이 동일하다. 램은 전력이 끊겼을 때 데이터가 지워지냐 여부에 따라, 휘발성과 비휘발성으로 나뉜다.</p>\n<ul>\n<li>\n<p>휘발성</p>\n<p>DRAM(일정 시간이 지나면 데이터가 사라져 주기적 재생 필요. 보통 우리가 <strong>주기억장치로 사용</strong>함. 시금치 램 같은 것들), SRAM(빠르고 안정적이지만 비싸서 <strong>캐시, 레지스터</strong> 등에 사용됨)</p>\n</li>\n<li>\n<p>비휘발성</p>\n<p>전원이 해제되어도 데이터가 사라지지 않지만, 속도가 느리고 비용이 비싸다. flash memory는 usb처럼 주변 장치로 사용되기도 하지만, 어느정도 사용횟수가 제한되어 있다. HDD와 SSD는 보조 기억장치로 많이 활용 된다. <u>보조 기억장치에는 OS를 포함한 프로그램, 각종 파일들을 저장</u>할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ROM (Read Only Memory)</p>\n<p>데이터를 보관할 수 있지만, 한번 저장하면 바꿀 수 없다. (CD-ROM 이라고 하는 이유!) 하지만 전력과 무관하게 데이터가 저장되므로, 메인보드의 BIOS(부팅시 초기화를 담당하는 프로그램) 등이 ROM으로 저장되어 있다. ROM은 보통 제조 과정에서 프로그래밍되어 고정되지만, 지우거나 쓸 수 있는 EPROM등도 존재하긴 하지만 많이 쓰이진 않는다.</p>\n</li>\n</ul>\n<h2 id=\"저장장치-계층-구조\" style=\"position:relative;\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"저장장치 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>저장장치 계층 구조</h2>\n<p>돈이 많다면 모든 저장장치를 속도가 빠른 캐시 메모리나 레지스터로 구성하겠지만, 현실적으로 불가능하다. 이에 컴퓨터는 보통 속도와 용량의 trade-off에 따라 적절하게 계층구조를 두고 구성되어 있다.</p>\n<ul>\n<li>register</li>\n<li>cache</li>\n<li>memory</li>\n<li>ssd/hdd</li>\n</ul>\n<p>계층을 두고 데이터를 관리하면 데이터가 중복되어 저장될텐데, <strong>일관성을 유지하는 것이 핵심</strong> 이라고 볼 수 있다. 따라서, 각 계층 간 데이터 이동에는 전략이 있으므로 참고한다. 보통 memory와 보조기억장치 간의 이동을 제외하고는 개발자가 관여할 수 없을 것이다.</p>\n<h2 id=\"부팅\" style=\"position:relative;\"><a href=\"#%EB%B6%80%ED%8C%85\" aria-label=\"부팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부팅</h2>\n<p>application은 운영체제에 의하여 메모리에 적재되어 실행된다. 운영체제도 프로그램인데, 어떻게 메모리에 올라갈까? 이는 <code class=\"language-text\">부팅</code>의 과정과 관련있다. 컴퓨터의 전원을 켜면 BIOS-ROM에 저장된 BIOS(Basic I/O System)프로그램이 실행된다.</p>\n<p>바이오스는 하드웨어를 점검하고(POST라고 함), 이상이 없다면 미리 설정된 부팅 순서에 따라 부트 장치(flash memory, HDD, SSD 등)를 선택한다.</p>\n<p>해당 부팅 장치에서 MBR(Master Boot Record) 또는 UEFI(Unified Extensible Firmware Interface) 로더가 로드된다. 이를 통하여 부팅 가능한 부트로더의 위치를 찾아서 실행된다.</p>\n<p>부트로더는 운영체제의 위치를 찾아 초기화하여 메모리에 올려서 실행되게 된다! 부팅 끝</p>","frontmatter":{"date":"June 27, 2023","title":"(OS) 운영체제 복습 [2. 컴퓨터 구조 skim]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(2)-computer-architecture/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(1)-intro/","nextSlug":"/Django(12)- nested model & serializer/","prevSlug":"/OS(2)-computer-architecture/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}