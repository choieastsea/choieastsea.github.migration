{"componentChunkName":"component---src-templates-blog-template-js","path":"/Alg-LC-215&373/","result":{"data":{"cur":{"id":"ddc7f7fe-0304-568c-8919-ca52755b1610","html":"<ol start=\"215\">\n<li></li>\n</ol>\n<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>배열에서 k번째로 큰 원소를 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\">링크</a></p>\n<p>매우 간단하지만, 여러 방법이 존재한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>가장 기본적으로 배열을 정렬한 후, k번째 원소를 리턴하면 된다.</p>\n<p>하지만, 문제에서 이를 정렬없이 해결할 방법을 물어봤는데, 이는 <code class=\"language-text\">heap</code> 자료구조를 이용하면 될 것이다. python의 <code class=\"language-text\">heapq</code>는 기본적으로 min-heap이므로, 큰 것을 남기기 위해서는 작은 것들을 빼주면 될 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(nlogk)</p>\n<p>정렬의 경우 nlogn이 걸릴 것이다. heap을 이용하더라도 push하는데 log(n), pop하는데 log(n)이 걸리므로, 평균적으로 nlog(k)이 걸린다고 볼 수 있다. n과 k중에서 n이 더 크지만, 배열의 형태에 따라 시간이 달라질 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(k)</p>\n<p>heap의 크기를 k개로 유지시킨다면 정렬에 비하여 공간복잡도를 줄일 수 있을 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> reverse<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>처음 방법은 단순하게 정렬하여 k-1번째 원소를 출력하는 것이다. 이 방법도 나쁘지 않은 속도와 메모리를 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> heapq <span class=\"token keyword\">import</span> heappush<span class=\"token punctuation\">,</span> heappop\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n            heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> k<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># k개로 heap 유지</span>\n                heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 가장 작은 것 탈락</span>\n        <span class=\"token comment\"># print(heap)</span>\n        <span class=\"token keyword\">return</span> heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span></code></pre></div>\n<p>heap의 사이즈를 k개 이상 벗어나지 않게 하는 heap을 이용할 수 있다. heap에는 가장 작은 원소가 root에 저장되므로 k개로 유지한다면 가장 큰 k개의 원소들만 남게 될 것이다. 따라서 마지막에 heappop을 수행한 것을 리턴하면 된다.</p>\n<p>나의 경우, 단순 소팅이 더 빠르게 나왔다. 하지만 heap을 이용하면 메모리가 아주 약간 줄어든 것을 확인할 수 있었다.</p>\n<hr>\n<ol start=\"373\">\n<li></li>\n</ol>\n<h1 id=\"intuition-1\" style=\"position:relative;\"><a href=\"#intuition-1\" aria-label=\"intuition 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>두 정렬된 배열에서, 하나씩 원소를 가져와서 더한 합이 최소가 되는 k개의 쌍을 찾는 문제이다. <a href=\"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/\">링크</a></p>\n<p>처음에는 배열마다 포인터를 하나씩 두고 처리하려 했지만,,, 배열의 값이 같은 것이 존재할 수 있고, 합은 항상 커지는 방향이 아니므로(두 배열 중 하나가 한바퀴를 다 돌아 최솟값을 가질 수도 있음) 포기하고, k size가 유지되는 heap을 이용하여 처리하였다.</p>\n<p>nums1 배열과 nums2 배열을 이중 loop로 순회하며 합을 heap에 넣는다. 그리고 위 문제처럼 크기가 k 이상 되지 않도록 유지한다.</p>\n<h1 id=\"approach-1\" style=\"position:relative;\"><a href=\"#approach-1\" aria-label=\"approach 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>이 문제에는 중요한 3가지가 있다.</p>\n<ol>\n<li>heap의 크기를 유지해야한다. 안그러면 메모리 초과가 날 것이다.</li>\n<li>가장 작은 k개를 유지해야하는데, heap은 기본적으로 min heap이므로 큰 값을 없애야한다. 따라서, heap에 넣을 때 key 값은 -1을 곱하여 저장한다.</li>\n<li>두 배열 nums1, nums2가 정렬되어 있으므로, heap에서 탈락하는 값에 따라 nums2에서는 더 이상 보지 않고, 다음 nums1의 인덱스로 넘어갈 수 있다. 안그러면 시간초과가 날 것이다.</li>\n</ol>\n<h1 id=\"complexity-1\" style=\"position:relative;\"><a href=\"#complexity-1\" aria-label=\"complexity 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: <code class=\"language-text\">O(n*mlog(k))</code></p>\n<p>nums1의 크기가 n이고, nums2의 크기가 m일 때, 모든 경우에 수에 대하여 k size의 힙을 관리한다.</p>\n</li>\n<li>\n<p>Space complexity: O(k)</p>\n</li>\n</ul>\n<h1 id=\"code-1\" style=\"position:relative;\"><a href=\"#code-1\" aria-label=\"code 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>처음에는 합으로 정렬하여 k개를 slicing하는 방법을 생각해보았는데, 메모리 초과가 났다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> itertools <span class=\"token keyword\">import</span> product\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">kSmallestPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">,</span>nums2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> x<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>x<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>k<span class=\"token punctuation\">]</span></code></pre></div>\n<p>그래서 heap을 이용하여 구현하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> itertools <span class=\"token keyword\">import</span> product\n<span class=\"token keyword\">from</span> heapq <span class=\"token keyword\">import</span> heappush<span class=\"token punctuation\">,</span> heappop\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">kSmallestPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># (합, (el1, el2))</span>\n        <span class=\"token keyword\">for</span> el <span class=\"token keyword\">in</span> product<span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">,</span>nums2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> k<span class=\"token punctuation\">:</span>\n                heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> result</code></pre></div>\n<p>위 코드는 두 값의 합을 음수로 하는 key로 저장하여, 큰 값이 pop되어 작은 k개의 조합이 남게 된다. 하지만, 위 경우는 모든 경우를 탐색하므로 시간초과가 났다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> heapq <span class=\"token keyword\">import</span> heappush<span class=\"token punctuation\">,</span> heappop\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">kSmallestPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        정렬된 nums1과 nums2에서 하나씩 골라서 쌍을 만들 때, (a1,a2)의 합이 가장 작은 k개 뽑는다\n        \"\"\"</span>\n        heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># (합, (el1, el2))</span>\n        maxVal <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">10</span><span class=\"token operator\">**</span><span class=\"token number\">10</span>\n        <span class=\"token keyword\">for</span> n1 <span class=\"token keyword\">in</span> nums1<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> n2 <span class=\"token keyword\">in</span> nums2<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># print(n1,n2,maxVal)</span>\n                <span class=\"token keyword\">if</span> maxVal <span class=\"token operator\">>=</span> <span class=\"token operator\">-</span>n1 <span class=\"token operator\">-</span> n2<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">break</span>\n                heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span>n1<span class=\"token operator\">-</span>n2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n1<span class=\"token punctuation\">,</span>n2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># min-heap, n1+n2의 합이 크면 나가야하므로 heap의 앞에 위치해야함</span>\n                <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> k<span class=\"token punctuation\">:</span>\n                    maxVal <span class=\"token operator\">=</span> heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 가장 작은 것 없애준다 == 합이 가장 큰 것</span>\n        result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> result</code></pre></div>\n<p>따라서, product를 사용하지 않고 이중 loop를 순회하며 heappop되는 값을 기록하였다. 만약, maxVal보다 더 큰 값이 합으로 들어온다면 nums2에서 더 큰 값만 남았으므로 더 이상 보지 않아도 된다. 따라서, maxVal에 따라 break하는 코드를 추가하였다.!</p>","excerpt":"Intuition 배열에서 k번째로 큰 원소를 리턴하는 문제이다. 링크 매우 간단하지만, 여러 방법이 존재한다. Approach 가장 기본적으로 배열을 정렬한 후, k번째 원소를 리턴하면 된다. 하지만, 문제에서 이를 정렬없이 해결할 방법을 물어봤는데, 이는  자료구조를 이용하면 될 것이다. python의 는 기본적으로 min-heap이므로, 큰 것을 남기기 위해서는 작은 것들을 빼주면 될 것이다. Complexity Time complexity: O(nlogk) 정렬의 경우 nlogn이 걸릴 것이다. heap을 이용하더라도 push하는데 log(n), pop하는데 log(n)이 걸리므로, 평균적으로 nlog(k)이 걸린다고 볼 수 있다. n과 k중에서 n이 더 크지만, 배열의 형태에 따라 시간이 달라질 수 있다. Space complexity: O(k) heap의 크기를 k개로 유지시킨다면 정렬에 비하여 공간복잡도를 줄일 수 있을 것이다. Code 처음 방법은 단순하게 정렬하여 …","frontmatter":{"date":"September 11, 2023","title":"(Alg) LeetCode Top Interview 150 - 215. Kth Largest Element in an Array, 373. Find K Pairs with Smallest Sums","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-215&373/"}},"next":{"id":"8ab6fe9a-0b1a-5ff8-b900-b8bbe721f0d9","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>저번에 구현한 <code class=\"language-text\">Trie</code> 자료구조를 이용하여 search함수를 구현하는 문제이다. <a href=\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\">링크</a></p>\n<p>search함수는 208번 문제와 다르게 ’.’가 포함될 수 있는데, 이는 모든 문자가 가능한 경우를 의미한다. 예를 들어, ‘dad’, ‘pad’, ‘mad’가 들어있는 트라이에서 <code class=\"language-text\">search('.ad')</code>는 3 단어를 모두 리턴할 것이다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>트라이에 대한 구현은 <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">208번</a>에서 했으니, 이번에는 search함수에서 ’.’를 처리하는 부분에 중점 두어 해결해보자.</p>\n<p>여러 방법이 존재하겠지만, ’.’의 경우에는 결국 해당 노드에서 가능한 모든 다음 노드로 각각 search를 수행해야 한다. 나는 <code class=\"language-text\">deque</code> 자료구조를 이용하여 search 함수를 구현하였다. trie를 탐색하면서, 입력 문자열을 하나씩 matching하다가 ’.’를 만나면, 특정 노드가 아닌 모든 노드로 뻗어나가야 한다. 나는 이를 BFS의 구조와 유사하다고 판단하여 탐색할 노드들을 queue에 넣고, depth별로(문자별로) 모든 큐의 노드들을 탐색하는 방법으로 구현하였다. 마지막까지 탐색했다면 <code class=\"language-text\">isEnd</code> 여부를 검사하고, 하나라도 가능한 경우가 있다면 True를 리턴한다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<p>search함수의 시간복잡도는 아래와 같을 것이다.</p>\n<ul>\n<li>\n<p>Time complexity: O(size of trie)</p>\n<p>최악의 경우, ’…’와 같이 모든 트라이의 공간을 탐색할 수 있으므로 트라이의 크기만큼 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>deque를 각 단계마다 비우긴 하지만, deque의 크기는 각 단계별 너비, 즉 문자열의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WordDictionary</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'isEnd'</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">addWord</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'isEnd'</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        current<span class=\"token punctuation\">[</span><span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        \n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>self<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q, ch)</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    current <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span>v <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 가능한 다음 노드들을 모두 탐색함</span>\n                        <span class=\"token keyword\">if</span> k <span class=\"token operator\">!=</span> <span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">:</span>\n                            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>     \n                <span class=\"token comment\"># 일반 문자라면, 해당 문자가 있는지 확인하고 넣어줌. 없는 것들은 무시</span>\n                <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    current <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> el <span class=\"token keyword\">in</span> q<span class=\"token punctuation\">:</span> <span class=\"token comment\"># 마지막 단계의 노드들이 deque에 존재할 것</span>\n            <span class=\"token keyword\">if</span> el<span class=\"token punctuation\">[</span><span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n              \t<span class=\"token comment\"># 해당 단어가 존재함!</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n<span class=\"token comment\"># Your WordDictionary object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = WordDictionary()</span>\n<span class=\"token comment\"># obj.addWord(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span></code></pre></div>\n<p>처음에는 q에 head를 넣은 상태로 탐색을 시작한다.</p>\n<p>문자열을 한 문자씩 탐색하면서 해당 Node가 존재하는지를 판단하는데, ’.’를 만난다면, q를 비워주면서 해당 노드에서 가능한 모든 다음 노드들을 queue에 넣는다. 이전 노드는 앞에 있고, 넣을 노드는 뒤에 있어야하므로 <code class=\"language-text\">stack</code>보다는 <code class=\"language-text\">queue</code>가 적합하다고 볼 수 있다.</p>\n<p>다른 일반 문자라면, queue의 모든 노드에서 해당 문자의 노드를 갖는지 확인하고, 가능한 노드들만 다음 단계로 넘긴다.</p>\n<p>모든 word의 문자들을 탐색한 이후에는 여태까지 살아남은(가능한) 문자열들이 존재할 것이다. 여기에서 끝나야 하나의 문자열로 인정되므로, isEnd를 확인하며 하나라도 존재하면 True를 리턴하도록 한다.</p>","frontmatter":{"date":"September 11, 2023","title":"(Alg) LeetCode Top Interview 150 - 211. Design Add and Search Words Data Structure","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-211/"}},"prev":{"id":"a9e59f51-8a31-5d15-af62-f704e38b40a4","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Trie 자료구조를 직접 구현해보는 문제이다. <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">링크</a></p>\n<p>요구되는 메서드로는 해당 단어가 존재하는지 찾는 <code class=\"language-text\">search</code>, prefix로 시작하는 단어가 존재하는지 찾는 <code class=\"language-text\">startsWith</code>가 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>트라이(Trie)는 여러 문자열을 트리구조로 저장하는 자료구조로, root(head)에서부터 한 문자씩 이어나가면 된다. 단어의 마지막 문자에는 끝났는지 여부를 기록한다.</p>\n<p>예를 들어, ‘dad’를 저장하면,<code class=\"language-text\">[head] - d - a - d (end)</code>와 같이 저장하면 된다. 이를 위해 python에서는 <code class=\"language-text\">dictionary</code> 자료형을 이용하는 것이 가장 간편하다. key에 문자를 넣고, value에는 다음 node인 dictionary를 넣으면 된다.</p>\n<p>Trie의 장점은 여러 문자열이 저장되어 있을 때, 한 문자열을 찾는 속도가 빠르며 특히 prefix가 같은 문자열을 찾는데 <code class=\"language-text\">O(n)</code>의 시간이 걸리므로 좋다. 예를 들어, prefix가 같은 문자열을 Trie로 표현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[head]\nd\na\nd(end)\tr\nd\t\t\t\tt(end)\ny(end)</code></pre></div>\n<p>위는 dad, daddy, dart의 세 단어를 저장한 Trie를 시각화한 예시이다. 여기서 da-로 시작하는 단어들을 찾기위해서는 d - a 순으로 탐색한 줄기의 모든 자식을 leaf까지 탐색하며 end일때마다 출력하면 된다. 따라서, dad, daddy, dart가 모두 나올 것이다! 이를 선형 탐색을 하려면 문자열의 갯수만큼 많아지므로 어려워 질 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>문자열을 모두 차례대로 넣으므로 O(n)의 시간이 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>문자열의 갯수가 많아질수록 당연히 트라이의 크기는 커질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>처음에는 Node class를 둬서 구현하였다. 직관적이지만, 아무래도 클래스를 선언하는 것은 dictionary보다는 무거울 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        self<span class=\"token punctuation\">.</span>isEnd <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 없다면 노드 새로 만들어줌</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 다음 노드로 이동</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># 마지막 노드에 isEnd 추가</span>\n        current<span class=\"token punctuation\">.</span>isEnd <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>isEnd<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> prefix<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n\n<span class=\"token comment\"># Your Trie object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = Trie()</span>\n<span class=\"token comment\"># obj.insert(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span>\n<span class=\"token comment\"># param_3 = obj.startsWith(prefix)</span></code></pre></div>\n<p>노드에는 다음 노드를 가리키는 next dict가 존재하며, 각 노드에는 본인에서 끝나는 문자열이 있는지 여부를 나타내는 <code class=\"language-text\">isEnd</code> 프로퍼티를 갖는다.</p>\n<ul>\n<li>\n<p>insert함수는 head에서부터 차례대로 문자들을 추가해준다. 만약 이미 해당 문자가 존재한다면, 다음 문자를 그 뒤에 넣어준다.</p>\n</li>\n<li>\n<p>search함수는 current 포인터를 두어 차례대로 모든 문자들을 매칭하였고, 그 이후에는 isEnd가 True인지를 확인하여 해당 단어가 trie에 존재하는지 여부를 확인할 수 있다.</p>\n</li>\n<li>\n<p>startsWith 함수 역시 current 포인터를 두어 판단하는데, prefix만큼 탐색이 끝날때까지 다음 노드가 이어져 있다면 True를 반환하면 된다. (isEnd를 확인할 필요가 없음)</p>\n</li>\n</ul>\n<p>다음은 dictionary만을 이용하여 구현한 Trie의 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"isEnd\"</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 없다면 노드 새로 만들어줌</span>\n                current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"isEnd\"</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n            <span class=\"token comment\"># 다음 노드로 이동</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># 마지막 노드에 isEnd 추가</span>\n        current<span class=\"token punctuation\">[</span><span class=\"token string\">\"isEnd\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">[</span><span class=\"token string\">\"isEnd\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> prefix<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n\n<span class=\"token comment\"># Your Trie object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = Trie()</span>\n<span class=\"token comment\"># obj.insert(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span>\n<span class=\"token comment\"># param_3 = obj.startsWith(prefix)</span></code></pre></div>\n<p>모든 노드는 {“d” : 노드, “a” : 노드, “isEnd” : False}와 같이 문자를 key로 이용하여 가리키며, value는 다음 노드가 될 것이다.</p>\n<p>아래의 방법이 좀 더 빠르고 메모리도 덜 소비하는 것을 제출하여 확인할 수 있다.</p>","frontmatter":{"date":"September 11, 2023","title":"(Alg) LeetCode Top Interview 150 - 208. Implement Trie (Prefix Tree)","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-208/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-215&373/","nextSlug":"/Alg-LC-211/","prevSlug":"/Alg-LC-208/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}