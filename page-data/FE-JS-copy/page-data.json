{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/FE-JS-copy/",
    "result": {"data":{"cur":{"id":"8b6696db-6098-577e-8a21-f90d144ae266","html":"<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<h2 id=\"복사\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC\" aria-label=\"복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사</h2>\n<p><code class=\"language-text\">복사</code>: 내용은 완전히 같지만, 주소는 완전히 다른 사본을 만들어내는 것</p>\n<p><code class=\"language-text\">얕은 복사</code>: <strong>원본과 참조 공유가 있어</strong> 상황에 따라 문제가 생길 수 있는 복사, depth가 1인 복사</p>\n<p><code class=\"language-text\">깊은 복사</code>: 내용만 같고 모든 원소의 주소는 달라 <strong>원본과 완전히 독립</strong>된 복사</p>\n<h2 id=\"복사-판단방법\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC-%ED%8C%90%EB%8B%A8%EB%B0%A9%EB%B2%95\" aria-label=\"복사 판단방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사 판단방법</h2>\n<p>즉, 모든 원소의 내용은 같으면서 ===의 결과가 false가 나와야(<strong>다른 주소를 참조, 원본과 독립되어있다</strong>는 의미) 깊은 복사가 된 것이다.</p>\n<p>같은 방법을 통하여 복사를 했더라도 <strong>객체의 깊이에 따라 얕은 복사가 될 수도, 깊은 복사가 될 수도</strong> 있다!</p>\n<hr>\n<h1 id=\"계기\" style=\"position:relative;\"><a href=\"#%EA%B3%84%EA%B8%B0\" aria-label=\"계기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계기</h1>\n<p>React.js에서 state(상태)를 다루다보면 <code class=\"language-text\">불변성</code>이라는 속성이 굉장히 중요 하게 여겨진다. 리액트에서 불변성이란, 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 의미한다. 새로운 값이라는 것은 <strong>원본과는 완전히 독립된 사본</strong>에서 변형이 이루어진 데이터이며, 이를 위해 깊은 복사의 개념을 익힐 필요를 느끼게 되었다.</p>\n<h1 id=\"사전-지식\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%A0%84-%EC%A7%80%EC%8B%9D\" aria-label=\"사전 지식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사전 지식</h1>\n<h2 id=\"primitive-type과-reference-type\" style=\"position:relative;\"><a href=\"#primitive-type%EA%B3%BC-reference-type\" aria-label=\"primitive type과 reference type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primitive type과 Reference type</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">자바스크립트의 자료형</a></p>\n<p>자바스크립트에는 <code class=\"language-text\">원시타입</code>(primitive type)과 <code class=\"language-text\">참조타입</code>(reference type)이 존재한다. 원시타입은 값 자체이며 메모리에 바로 저장된다. 참조타입은 원시타입을 제외한 나머지를 저장하는 방식으로, 메모리에 실제 값들이 저장되어 있는 주소가 저장되어있다. 참조타입에서 실제 값들은 Heap 메모리에 저장되어있다.</p>\n<h2 id=\"객체의-깊이depth\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B9%8A%EC%9D%B4depth\" aria-label=\"객체의 깊이depth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체의 깊이(depth)</h2>\n<p><code class=\"language-text\">{abc: 'xyz'}</code>의 깊이는 1이다.</p>\n<p><code class=\"language-text\">{foo:{bar:{baz : 'baa'}}}</code>의 깊이는 3이다.</p>\n<h2 id=\"대입연산자를-통한-복사--aliasing\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%9E%85%EC%97%B0%EC%82%B0%EC%9E%90%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%B3%B5%EC%82%AC--aliasing\" aria-label=\"대입연산자를 통한 복사  aliasing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대입연산자를 통한 복사 ↔ Aliasing</h2>\n<p>원시타입에서 다음 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> num2 <span class=\"token operator\">=</span> num1<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnum2 <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//2</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/798584e8-7421-4ced-8479-aa6a432fae77/Untitled.png\" alt=\"\"><img src=\"https://images.velog.io/images/choieastsea/post/da95333d-b559-4df9-a728-3c29f9bb2442/Untitled%201.png\" alt=\"\"></p>\n<p><strong>원시 타입</strong>에서는 대입연산자를 통하여 할당이 된다. 위의 예시처럼 num2의 값을 바꾼다면, num2가 새로운 값을 갖도록 재할당한다고 볼 수 있다. num2의 값이 바뀌었다고 num1의 값도 바뀌지는 않는다.</p>\n<p>그렇다면 참조타입에서는 어떨까? 다음 코드의 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">**</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token operator\">**</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//[1,4,[1,2,3]]</span>\n<span class=\"token comment\">//true</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/df74b351-8d27-4261-99e1-e98e36b5eae7/Untitled%202.png\" alt=\"\">\n<img src=\"https://images.velog.io/images/choieastsea/post/a88e5715-2902-47b6-ba2e-d65ff10c7a70/Untitled%203.png\" alt=\"\">\n하지만, <strong>참조 타입에서는 참조 공유</strong>가 된다. 위에서도 b는 새로운 메모리 공간이 아닌 a와 같은 주소를 공유하게 된다. 그렇게되면 사본인 b를 수정했는데 원본인 a도 바뀌는 것이다.</p>\n<p>원시 타입에서는 대입연산자를 통한 복사(깊은 복사)라고 볼 수 있지만, <em>참조 타입에서 대입연산은 복사라고 볼 수 없다</em>. 참조타입에서의 대입연산(=)은 copy가 아닌 <code class=\"language-text\">aliasing</code>이다. alias란 <code class=\"language-text\">별명</code>이라는 뜻으로, A와 B가 같은 객체를 가리키는 것을 의미한다. 예컨데, 손흥민과 우리흥은 말(내용)은 다르지만 같은 본질(사람)을 가리킨다. 이때 ‘우리흥’은 ‘손흥민’의 alias라고 볼 수 있다.</p>\n<h1 id=\"복사란\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC%EB%9E%80\" aria-label=\"복사란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⭐복사란?</h1>\n<p>이 페이지에서 말하는 <code class=\"language-text\">복사</code>란, aliasing(참조공유)과는 완전 다른 개념이다.(‘손흥민’과 ‘우리흥’처럼 같은 객체를 가리키는 것이 아님!) <strong><em>외형은(내용은) 완전히 같지만, 본질은(주소는) 완전히 다른 사본</em>을 만들어내는 것</strong>이 여기서 말하는 복사이다.</p>\n<p>참조타입에는 <strong>복사되는 depth(깊이)에 따라</strong> 얕은 복사와 깊은 복사가 존재한다. 각 방법을 익히고 적재적소에 사용하도록 해보자!</p>\n<h2 id=\"얕은복사\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC\" aria-label=\"얕은복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은복사</h2>\n<p>하나의 depth까지만 복사한다. 따라서 참조공유의 문제가 발생할 수 있다.</p>\n<p>객체나 배열의 깊이를 생각하지 않고 1차원적으로 원소들을 복사하여 새로운 변수에 넣어주면 얕은복사이다. 이는 일차원 객체에서는 깊은복사이지만, 깊이가 2 이상인 경우에는 위에서 본 참조공유의 문제(aliasing)을 일으킨다.</p>\n<p>js에서는 이를 위해 반복문을 이용한 직접 대입, slice 함수, ES6의 spread 연산자 등을 이용할 수 있다.</p>\n<ol>\n<li>\n<p>for문</p>\n<p>일일이 객체의 value(배열이라면 원소)를 넣어준다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">shallow_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends <span class=\"token operator\">=</span> <span class=\"token function\">shallow_copy</span><span class=\"token punctuation\">(</span>friends<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"2\">\n<li>spread 연산자(전개구문, …)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends_2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>friends<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>직관적이며 기존의 함수들을 포함한 기능들을 사용할 수 있기에 최근에 많이 사용되는 것 같다.</p>\n<ol start=\"3\">\n<li>\n<p>assign 함수, slice 함수</p>\n<p>전개연산자가 있는데 굳이 해볼 필요는 없을 것 같으니 인터넷에서 찾아보도록 하자.</p>\n</li>\n</ol>\n<p>위 코드의 결과로 복사가 잘 되어있을 것이다. 깊이가 1인 객체에 대하여 위 방법은 깊은 복사가 된다고 볼 수 있다!</p>\n<p>이제 일차원 배열 말고 다음과 같이 <strong>깊이가 2이상인 객체</strong>에 대하여 위의 복사를 진행해보자. 이름, 나이, 가족 구성원 배열을 갖고 있는 객체를 복사하려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> shallow_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token operator\">===</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> shallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">//사본의 값을 바꿔보자.</span>\nshallow_copy<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'another_name'</span><span class=\"token punctuation\">;</span>\nshallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//참조 공유로 인해 원본도 수정된다.</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/d4c1c9b7-ecf0-46dd-91d4-599f15a39040/Untitled%204.png\" alt=\"\">얕은 복사 직후의 상황\n얕은 복사를 하면 1차원적으로는 복사가 이루어졌지만, 깊이가 2인 family배열은 공유하고 있는 상태가 된다. 이 경우 문제 있는 <code class=\"language-text\">origin.family===shallow_copy.family</code>를 하면 true가 나온다.\n<img src=\"https://images.velog.io/images/choieastsea/post/21b6cf6f-66bc-4566-b0cd-eef19968d35f/Untitled%205.png\" alt=\"\">이는 참조공유의 문제가 생긴다. 배열의 원소단위로 값만 가져왔지만, <em>원소가 만약 또 참조 타입인 경우</em>에 다시 참조를 공유하는 문제가 생기게 되는 것이다. 이와 같이 <strong>참조의 문제가 여전히 남아있는 복사가 얕은 복사이다</strong>.  우리는 이를 떼어내서 완벽하게 독립된 사본을 만들어줄 필요가 있다. 위에서는 간단하게 push해주는 부분을  <code class=\"language-text\">shallow_copy.family = shallow_copy.family.concat('cat');</code>으로 바꿔 새로운 객체를 할당함으로써 문제를 해결할 수 있다.</p>\n<p>하지만 이렇게 문제가 생겨 수정하는 것보다, 복사를 할때부터 이러한 참조의 문제를 일으키지 않도록 하고 싶을 때 <code class=\"language-text\">깊은복사</code>를 이용할 수 있다.</p>\n<h2 id=\"깊은-복사\" style=\"position:relative;\"><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깊은 복사</h2>\n<p>깊은 복사를 위해서는 구조적으로 제일 깊숙한 참조타입까지 복사를 진행해주면 되는데, 깊이마다 얕은복사, 재귀함수, 라이브러리, JSON 함수와 같은 방법들이 존재한다.</p>\n<p>아래와 같이 바꾸면 깊은 복사에 성공한 것이다. family를 ===한 결과 false가 나올 것이다.\n<img src=\"https://images.velog.io/images/choieastsea/post/6bca52a9-8858-4455-a729-d9e126aaa506/Untitled%206.png\" alt=\"\"></p>\n<ol>\n<li>\n<p>깊이마다 얕은 복사 진행</p>\n<p>얕은 복사를 객체의 깊이별로 진행해주면 된다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> deep_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>origin<span class=\"token punctuation\">,</span> family<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> deep_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p>하지만 위의 경우는 깊이가 깊어지면 매우 귀찮아진다. 아래의 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              num<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            name<span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          something<span class=\"token operator\">:</span> <span class=\"token string\">'something'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      last<span class=\"token operator\">:</span> <span class=\"token string\">'dance'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//얕은 복사</span>\n    <span class=\"token keyword\">const</span> shallow_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//깊이마다 얕은 복사 진행</span>\n    <span class=\"token keyword\">const</span> deep_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">,</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">,</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">,</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow<span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n        object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> shallow_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//true -> 참조 공유</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>위는 너무 귀찮으므로, 깊이가 깊어질때에는 아래의 방법을 사용하자.</p>\n<ol start=\"2\">\n<li>\n<p>재귀함수</p>\n<p>재귀적으로 객체의 깊이까지 모두 복사를 해주면 된다. 이는 어느 객체에나 사용할 수 있는 범용적인 방법이 될 것이다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">deep_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\">//if element is object</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//not object => primitive type</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> deep_object_recursion <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_recursion<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span>\n</code></pre></div>\n<p>위의 deep_copy 함수를 사용하면 깊이에 제한 없이 깊은 복사를 진행할 수 있다. 재귀적으로 원소의 type이 object이면 한단계 들어가서 복사를 진행하는 방법이다.</p>\n<ol start=\"3\">\n<li>\n<p>라이브러리</p>\n<p>깊은 복사를 해주도록 도와주는 자바스크립트 라이브러리가 있다. lodash, immutable을 찾아보도록 하자.</p>\n</li>\n<li>\n<p>JSON.stringfy, parse 함수</p>\n<p>이는 일종의 hack으로, 성능은 느리지만 간단하게 깊은 복사를 할 수 있는 방법이기도 하다. 원래 <code class=\"language-text\">JSON.stringify</code>는 JSON객체를 string으로 변환시켜주고, <code class=\"language-text\">JSON.parse</code>는 string을 JSON으로 변환시켜주는 메서드이다. 여기서 (객체 → string → 객체)의 방법으로 새로운 복사본을 만들어주면 된다. 아까의 object 예시에 이어서 해보겠다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> deep_object_json <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_json<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>이 방법이 외부 라이브러리를 사용하지 않는다면 가장 간단한 방법이겠으나, 문자열로 바꾼 객체를 다시 객체로 만드는 시간이 많이 든다는 것을 알고 있어야 한다.</p>\n<h1 id=\"마무리복사alias복습\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%EB%B3%B5%EC%82%ACalias%EB%B3%B5%EC%8A%B5\" aria-label=\"마무리복사alias복습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리(복사,alias복습)</h1>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/a3fad05e-6882-4ab8-8cb4-20be79ad1dd0/Untitled%207.png\" alt=\"\"></p>\n<p>위의 사진에서 a와 b는 같은 객체를 공유하고 있고(참조공유), 이는 <strong>alias의 관계</strong>이다. 반면 c는 a의 2번 인덱스를 공유하고 나머지는 복사가 되었다. 이 경우 c는 a에서 <strong>얕은 복사</strong>가 이루어졌다고 볼 수 있다.(이차원 배열인 a에서 1차원선에서만 복사가 이루어졌기 때문) d는 a와 완전히 데이터는 일치하지만, 그 어느 것도 주소를 공유하지 않는다. 이는 <strong>깊은 복사</strong>가 이루어졌다고 볼 수 있다!</p>\n<p>JS에서 <em>타입이나 객체의 구조에 따라서 같은 방법으로 복사를 하더라도 어떤 것은 얕은 복사일수도 있고, 깊은 복사일 수 있다</em>. 이를 판단하는 것은 값 비교와 주소비교이다. A를 원본으로 하는 사본 B가 있을때, B의 모든 원소는 A의 모든 원소와 값이 같아야하며 주소는 달라야(===의 결과 false) 깊은복사라고 한다.</p>\n<h2 id=\"리액트에서-이를-알아야-하는-이유\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"리액트에서 이를 알아야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+리액트에서 이를 알아야 하는 이유</h2>\n<p>React.js에서는 상태의 불변성을 유지시켜줘야하는 이유에 대해서 알아보자. 리액트에서 상태가 변하면 re-rendering을 해줘야하므로, 상태가 변했음을 판단할 수 있어야 한다. 하지만 하나의 상태를 변형해가며 사용한다면(불변성 x) 같은 객체이며 값만 바뀐 것이므로, <strong>상태가 바뀌었는지 확인하는데 더 많은 자원을 소비해야한다</strong>. <em>따라서 아예 다른 객체를 할당해줌으로써 상태가 바뀌었다고 인식하여 리렌더링</em>한다*.* 불변성을 유지하며 상태를 변경하는 방법으로는, 깊은 복사를 해준 후 바꿀 부분만 추가로 바꿔주면 된다! 객체의 깊이에 따라 다양한 방법을 사용할 수 있다.</p>","excerpt":"결론 복사 : 내용은 완전히 같지만, 주소는 완전히 다른 사본을 만들어내는 것 : 원본과 참조 공유가 있어 상황에 따라 문제가 생길 수 있는 복사, depth가 1인 복사 : 내용만 같고 모든 원소의 주소는 달라 원본과 완전히 독립된 복사 복사 판단방법 즉, 모든 원소의 내용은 같으면서 ===의 결과가 false가 나와야(다른 주소를 참조, 원본과 독립되어있다는 의미) 깊은 복사가 된 것이다. 같은 방법을 통하여 복사를 했더라도 객체의 깊이에 따라 얕은 복사가 될 수도, 깊은 복사가 될 수도 있다! 계기 React.js에서 state(상태)를 다루다보면 이라는 속성이 굉장히 중요 하게 여겨진다. 리액트에서 불변성이란, 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 의미한다. 새로운 값이라는 것은 원본과는 완전히 독립된 사본에서 변형이 이루어진 데이터이며, 이를 위해 깊은 복사의 개념을 익힐 필요를 느끼게 되었다. 사전 지식 Primitive type과 Refer…","frontmatter":{"date":"October 24, 2021","title":"(JS) 얕은복사와 깊은복사(shallow and deep copy) & aliasing","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-JS-copy/"}},"next":{"id":"ffd441a4-4019-57eb-90de-dea9ed0004e3","html":"<h1 id=\"react-hooks-2-usecallback-usememo\" style=\"position:relative;\"><a href=\"#react-hooks-2-usecallback-usememo\" aria-label=\"react hooks 2 usecallback usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(React) Hooks (2) useCallback, useMemo</h1>\n<p>나는 여태까지 useState와 useEffect로만 모든 프로젝트를 진행하였다. 이제 기능구현은 되니까 성능 최적화를 해보도록 하자!</p>\n<p>useEffect는 특정 조건(<strong>변수의 값이 바뀌거나 마운트, 언마운트 되었을 때</strong>)에 일어날 행동들(side effects)을 수행하는 Hook이다.</p>\n<p>useCallback은 함수를 memoization시켜놓아 모든 렌더링 시 함수가 재실행되지 않고, 특정 조건시에만 함수를 반환하여 실행도록 한다.</p>\n<p>useMemo는 변수를 ~~</p>\n<p>배열인자에 들어있는 의존성이 바뀌었을때 실행되는 것은 같지만, useEffect는 안의 내용이 실행되고, useMemo는 안의 변수를 반환하고 useCallback은 안의 함수를 반환한다.</p>","frontmatter":{"date":"October 22, 2021","title":"(React) Hooks (2) useCallback, useMemo","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-hooks-2/"}},"prev":{"id":"19b36e89-13e5-59ef-85e9-e9ac1c6d5531","html":"<p><code class=\"language-text\">Tree</code>(트리)는 계층적인 구조를 나타내기 위한 자료구조이다. 나무를 뒤집어 놓은 듯한 구조로 보통 표현되며, 뿌리인 root node에서부터 자식 노드로 단방향으로 뻗어져 나간다. 파일 디렉토리가 트리의 경로와 같이 표현되어 있으며 (ex C>>Desktop>>Document>>index.md), <code class=\"language-text\">Heap</code>, <code class=\"language-text\">Trie</code>  등에도 사용된다.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/400px-Binary_tree.svg.png\" alt=\"트리 위키백과\"></p>\n<h1 id=\"tree-용어\" style=\"position:relative;\"><a href=\"#tree-%EC%9A%A9%EC%96%B4\" aria-label=\"tree 용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree 용어</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAAB5ElEQVQoz31SXXPaMBD0//8/fe5MQwmBkLT5xsZ8phiwDbZsSzqd7i5jQ0r60h3p5aS93dm7gJlFWDpwB+oqe8M3O/pSPkNEPHFU8sFycJ/xtxWnDXoHxlpjjNYNI+y2yeD6ulZKOVFApw6ICGCJZbiBpPaB9ZwbNs6jA4fIREByl8l0+R6/PKbJ+3PuYyUixCIAYIxpxZ0lj0HluMGzJSJiIlU3T8t93ehY0SbZHfM9k0dqLSOic05ELAAiBr8y/rnl2qLRjdbtHfR+jH8/ZSgzxYeyGvZ7r/P3USYFsEcAABFxznnvg3/yECGidRxFq6RoBdrAoslks0mofeJWt1O+kOVLkvs0TxuoVOmx/WS0rqpKlcp7PHFOZABoyYMdTwo2SAAwDcPeYDRI3MNkFr29VlV1Px6Xx7wuDuPR0BjD3ntnL+R1zX9q1s7rpomn05fHBwSzWi6nYVgW5WIavW2KfpzeDm9sU0clj7dgUNCB99TZlrYjIipVHo9HrQ0RdcshwrTT/Fycl0gBN67dIuccEQVHy5UTRLeYz/M8Z6LVYqGUOoV3mmA75L+5dNGcA+slNEolTbP+1dV8Fltr725HcTiRTzIR+08udYeZtdaXUYnw97gMUy2C0bborXVYChL/Hx8lf+gCgZ9IdAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"용어\"\n        title=\"용어\"\n        src=\"/static/48d4dffdff985717ca8769cf822210d9/0b533/tree_term.png\"\n        srcset=\"/static/48d4dffdff985717ca8769cf822210d9/e9ff0/tree_term.png 180w,\n/static/48d4dffdff985717ca8769cf822210d9/f21e7/tree_term.png 360w,\n/static/48d4dffdff985717ca8769cf822210d9/0b533/tree_term.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>root(루트) : 최상위 계층에 있는 노드. 한 트리에서 루트 노드는 유일하게 존재한다.</p>\n</li>\n<li>\n<p>level(레벨) : 루트에서 특정노드까지의 거리(엣지의 수)</p>\n</li>\n<li>\n<p>parent/child node(부모-자식 노드) : 한 노드와 직접 연결되어 있는 경우, 부모 자식 노드의 관계이다. 가리키는 노드가 부모, 아닌 노드가 자식 노드라고 보면 된다.</p>\n</li>\n<li>\n<p>sibing nodes(형재 노드) : 같은 부모 노드를 갖는 노드</p>\n</li>\n<li>\n<p>height(높이) : 트리의 높이 == <code class=\"language-text\">max(all nodes' level)</code></p>\n</li>\n<li>\n<p>sub tree(서브 트리) : 한 노드를 기준으로 하는 트리. 트리를 재귀적으로 볼 수 있게 해준다.</p>\n</li>\n</ul>\n<h1 id=\"tree의-특징과-종류\" style=\"position:relative;\"><a href=\"#tree%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-label=\"tree의 특징과 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree의 특징과 종류</h1>\n<h2 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h2>\n<ul>\n<li>루트에서 특정 노드까지의 경로가 유일하다.(두 노드를 잇는 경로는 유일하다)</li>\n<li>부모 노드에서 자식노드로 단방향 연결되어 있다.</li>\n</ul>\n<h2 id=\"종류\" style=\"position:relative;\"><a href=\"#%EC%A2%85%EB%A5%98\" aria-label=\"종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>종류</h2>\n<ul>\n<li>이진 트리 : 자식이 최대 2개인 트리. 보통 자식을 왼쪽 오른쪽으로 구분하여 표현</li>\n<li>완전 이진 트리 : 이진 트리 중, 자식 노드가 왼쪽부터 차례대로 채워져 있는 트리. 0번 인덱스를 무시하면 <strong>배열로 편하게 구현 가능하다.</strong></li>\n<li>힙: 부모노드의 값이 항상 자식노드의 값보다 큰(혹은 작은) 완전 이진 트리. 이 경우, **루트 노드의 값은 항상 최댓값(혹은 최솟값)**이 된다.</li>\n<li>Binary Search Tree(BST, 이진 탐색 트리)</li>\n</ul>\n<p>그 중 오늘은 <code class=\"language-text\">Binary Tree</code>를 직접 구현해보자.</p>\n<h1 id=\"binary-tree이진-트리\" style=\"position:relative;\"><a href=\"#binary-tree%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC\" aria-label=\"binary tree이진 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Tree(이진 트리)</h1>\n<p><code class=\"language-text\">Binary Tree</code>(이진트리)는 한 노드의 자식이 최대 2개인 트리이며, 보통 왼쪽 자식과 오른쪽 자식으로 나눈다. n개의 노드가 있을 때, 가능한 레벨은 log(n)~n이라고 볼 수 있다. log(n)은 모든 노드의 자식이 가능할 때까지 2개씩 차있는 경우이며, n일때는 모든 노드가 하나의 자식 노드만을 갖는 경우(skew tree)이다.</p>\n<h1 id=\"이진-트리-구현\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84\" aria-label=\"이진 트리 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리 구현</h1>\n<p>이진트리를 만드는데에는 다양한 방법이 있지만, 데이터를 담고 있는 노드간의 참조(reference)로 계층적인 구조를 구현해보자. 우선 노드는 다음의 properties를 갖고 있어야 한다.</p>\n<ul>\n<li>data</li>\n<li>left child</li>\n<li>right child</li>\n</ul>\n<p>부모 노드는 자식(최대 2개)을 가리키고 있으며, 데이터를 갖고 있도록 한다.</p>\n<p><code class=\"language-text\">Binary Tree</code> class는 root만 갖고 있으면 된다. root에서 그 이하의 노드들까지 모두 접근이 가능하기 때문이다. 따라서 나는 아래와 같이 루트 노드를 만들어 트리 관계를 만들어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">BT_Node</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token comment\">//이진 트리의 노드</span>\n    value<span class=\"token punctuation\">;</span>\n    leftChild <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    rightChild <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BinaryTree</span> <span class=\"token punctuation\">{</span>\n    root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> node_1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_5 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_6 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_7 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_8 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nnode_1<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_2<span class=\"token punctuation\">;</span>\nnode_1<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_3<span class=\"token punctuation\">;</span>\nnode_2<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_4<span class=\"token punctuation\">;</span>\nnode_2<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_5<span class=\"token punctuation\">;</span>\nnode_3<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_8<span class=\"token punctuation\">;</span>\nnode_3<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_7<span class=\"token punctuation\">;</span>\nnode_7<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_6<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> bt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BinaryTree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbt<span class=\"token punctuation\">.</span>root <span class=\"token operator\">=</span> node_1<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 아래와 같은 트리 구조를 보이게 될 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 540px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxUlEQVQ4y5VUXW/iMBDM//9L91FdpQpIK/Xh2j5wgIBCC01wSDaOHex4Ki9NsZJcpVpaOVnPjteza0dN06BvlmdrLYDm05w7+9q1odgo/PGgMMA5izw32GxOmP7TyLITE4eYLnEU7mZtCHLwY7dXuLnZ4c/1K4TQ7AvJfEzIEYXZ+aO2AKUUDgcBIRJoXaLWhMMhgRACWmt0T/afDC3rlOc50jSBlBX7nXNs/ltKyWtEhG4sE7ape23y/IQ4Jvz4KfD3QcGYvrbe9/io8Ou3wGhMEOKiq7foEuBnh5cXgdlsiyyr4BxgjO1pm6YlY/b7I8eEG0aX1nAgEpDyyNXNsjfUtfwowlkKj1GKUBQpY4pCgChjf5tl5IFU+taoMJsdkaSG9UpTjfk8w3qtobWBUhZJUmM6zbBYKMYQWcwXR6zXFR/dc0WeebvVmMSEyaTEcqV4t6cnidvbEuNxAaUM9+D9fcmYuztizPNGYzQqEMcFrzNh9za0qYf/50oPYQApC1QV8XenKPajAJc2MJ/NO2x+KFVCKckS9Ai7V+9rsgarlWJJrq5yLJdnqaLhx+Fray8AkcHrTmO3r1GWpv84fJd06CV6B7XqkF28bbv4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tree\" title=\"tree\" src=\"/static/6b5b77574a5c815ed3aafe575d2e2117/07484/tree.png\" srcset=\"/static/6b5b77574a5c815ed3aafe575d2e2117/e9ff0/tree.png 180w,\n/static/6b5b77574a5c815ed3aafe575d2e2117/f21e7/tree.png 360w,\n/static/6b5b77574a5c815ed3aafe575d2e2117/07484/tree.png 540w\" sizes=\"(max-width: 540px) 100vw, 540px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<h1 id=\"이진-트리의-탐색\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%83%90%EC%83%89\" aria-label=\"이진 트리의 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리의 탐색</h1>\n<p>위의 트리 구조를 직접 확인하기 위해서는 <u>트리 탐색(<code class=\"language-text\">traverse</code>)</u>가 필요하다. <u>트리의 <strong>모든 노드를 일정한 순서로 한번씩 탐색</strong></u>해야 하며 루트 노드를 기준으로 시작한다. (탐색은 출력과 같은 의미로 해석 가능)</p>\n<p>탐색에는 크게 두가지 방법이 있으며 <code class=\"language-text\">recursion</code>(재귀)을 이용하여 구현해볼 수 있다.</p>\n<h2 id=\"1-pre-order-traverse\" style=\"position:relative;\"><a href=\"#1-pre-order-traverse\" aria-label=\"1 pre order traverse permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Pre order traverse</h2>\n<p>이진트리를 탐색하는 방법으로 후위, 중위, 전위 순회가 있다. 한 노드를 기준으로 트리를 보면 현재 노드, 왼쪽 서브 트리, 오른쪽 서브 트리로 볼 수도 있다. 각각을 1,2,3번이라고 했을 때 1-2-3의 순서로 탐색을 하는 것이 <code class=\"language-text\">pre-order-traverse</code>방식이다. 2-3-1로 서브 트리를 먼저 탐색한 후 현재 노드를 탐색하는 <code class=\"language-text\">post-order</code>, 2-1-3의 순서로 서브 트리 사이에 현재 노드를 탐색하는 <code class=\"language-text\">in-order</code>방식이 존재한다. 여기서는 그 중 하나인 <code class=\"language-text\">pre-order-traverse</code>를 구현해보도록 하자.</p>\n<p>위의 그림을 탐색한 결과를 예상해보면 아래와 같다.</p>\n<ol>\n<li>node1을 탐색(출력)</li>\n<li>node2를 root로 하는 sub-tree 탐색\n<ol>\n<li>node2를 탐색(출력)</li>\n<li>node4를 root로 하는 sub-tree 탐색\n<ul>\n<li>node4 탐색(출력)</li>\n</ul>\n</li>\n<li>node5를 root로 하는 sub-tree 탐색\n<ul>\n<li>node5 탐색(출력)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>node3을 root로 하는 sub-tree 탐색\n<ol>\n<li>node3을 탐색(출력)</li>\n<li>node8을 root로 하는 sub-tree 탐색\n<ul>\n<li>node8 탐색(출력)</li>\n</ul>\n</li>\n<li>node7을 root로 하는 sub-tree 탐색\n<ul>\n<li>node7 탐색(출력)</li>\n<li>node6을 root로 하는 sub-tree 탐색\n<ul>\n<li>node6 탐색(출력)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>위의 순서로 재귀적으로 탐색할 것이므로 1-2-4-5-3-8-7-6의 순서로 출력될 것이다.</p>\n<p>BinaryTree class의 traverse 메서드의 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">traverse</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//pre-order-traverse : 부모-왼쪽-오른쪽 탐색</span>\n  \t<span class=\"token comment\">//탐색은 출력과 같은 의미</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"2-bfs-algorithm을-이용한-트리-탐색\" style=\"position:relative;\"><a href=\"#2-bfs-algorithm%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8A%B8%EB%A6%AC-%ED%83%90%EC%83%89\" aria-label=\"2 bfs algorithm을 이용한 트리 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. BFS Algorithm을 이용한 트리 탐색</h2>\n<p>그래프에서 사용하는 <code class=\"language-text\">BFS</code> 알고리즘을 통하여 트리에서 사용해보자. 결국 트리도 그래프이므로 그래프 탐색 알고리즘을 사용할 수 있으며, 이진 트리일 필요는 없다.</p>\n<p>Breadth First Search(BFS, 너비 우선 탐색)은 그래프에서 인접한 노드를 먼저 탐색하는 방법이다. 트리에서는 루트에서부터 떨어진 거리(level)에 따라 탐색한다고 보면 될 것같다. 즉 루트, 루트에서부터 거리가 1인 노드들, 거리가 2인 노드들… 순으로 말이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 540px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVQ4y5WT61KjQBCFef9H8m90dU2CkVTIxUAwgaBAkAxm5P5tMcQY13Jr7apTPd1zpqsv01pVVdR1TavPUdedhvqEpqk/3X1w65PWvgtYlhVNU5EkBRs3Z7HIiONC+dq7bwOeG+/SNKcjYZhzfR1weRmQJOUXTtM0p/enDFtnmqaYpslsNmM+n2MYBsOhzmDwm/FYV+j3b5VvPB4rTst3XVcF/lJynuckSUKaCrZbD8dZEYYhQgiESI8QBEGg7p6efPb7PWn6+ql0rTO6cosCDKOkdylZLvlWLBuufklGowopOWbYtU71sChKLMtiMpnS6w24uOhx279X5U8mJqY5PcJkOp1xczNSnKurIaY5Y7FYkGX5e4a1mpyUKZ73yPOzixAvrNcWYfiEPOxJkheF19c9QbDF81YIkeB5a7bbNVIKFeM45Yo0LdluM+yVII678uO4ZOXscd2ComjI84bdrmRp7XGcXHEOssFxBK6XsYtzFVSDhuegYqi/MRhmuG73NeaLHP0uYzCQlCUI0WCMO87d6E1xfL/iti/RdUmatv+oQWunZFkLHGepsFoteXh4UPrctqwPX4u2b47T9t3ANMfYtoWUEi3LMqIoIop2J+x2u3/aHSKSJMb3XXzfU5z262nnG/JTCQK4vy+5vinUuRXt7x3+H7RJSHnAnNoMhja6bjOd2kRR2GX4E7yv6uFwYLN5xPc3Cuu1ozbrD3DNdMUsjujrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tree\" title=\"tree\" src=\"/static/e16884cb66aa9302adbaf47a1ac7d9b2/07484/tree_bfs.png\" srcset=\"/static/e16884cb66aa9302adbaf47a1ac7d9b2/e9ff0/tree_bfs.png 180w,\n/static/e16884cb66aa9302adbaf47a1ac7d9b2/f21e7/tree_bfs.png 360w,\n/static/e16884cb66aa9302adbaf47a1ac7d9b2/07484/tree_bfs.png 540w\" sizes=\"(max-width: 540px) 100vw, 540px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>위의 그림을 BFS방식으로 루트부터 탐색하면, 1-2-3-4-5-8-7-6의 순서로 될 것이다. 어쩌면 BFS알고리즘으로 트리를 탐색하는 것이 pre-order-traverse보다 우리의 직관으로 이해하기 쉽다. BFS는 FIFO의 특성을 갖는 <code class=\"language-text\">queue</code>를 이용하여 구현가능하다.</p>\n<p>이하는 큐를 이용한 BFS 알고리즘(tree ver)이다.</p>\n<ol>\n<li>현재 노드를 탐색한 후, 큐에 넣는다(enqueue)</li>\n<li>큐에 노드가 없을 때까지\n<ol>\n<li>큐 가장 앞 노드를 꺼낸다.(dequeue)</li>\n<li>꺼낸 노드의 자식 노드들을 탐색 후 큐에 넣는다(enqueue)</li>\n</ol>\n</li>\n</ol>\n<p>코드는 다음과 같다. 인자로 root node를 넣어주면 트리 순회를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">bfsTraverse</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> current_node <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>전체 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS04_BinaryTree.js\">깃허브에</a> 업로드 해놓았다~</p>\n<p>힙과 Binary Search Tree(BST, 이진 탐색 트리)는 다음에 알아보도록 하자.</p>","frontmatter":{"date":"November 05, 2021","title":"(자료구조 JS)트리와 이진트리 탐색 Tree & Binary Tree traverse","categories":"Algorithms","author":"choieastsea","emoji":"🏄‍♂️"},"fields":{"slug":"/DS04-Tree/"}},"site":{"siteMetadata":{"siteUrl":"http://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/FE-JS-copy/","nextSlug":"/FE-React-hooks-2/","prevSlug":"/DS04-Tree/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}