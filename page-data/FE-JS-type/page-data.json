{"componentChunkName":"component---src-templates-blog-template-js","path":"/FE-JS-type/","result":{"data":{"cur":{"id":"7df92e5c-18d2-56fc-b495-408cfe132637","html":"<h1 id=\"js-타입\" style=\"position:relative;\"><a href=\"#js-%ED%83%80%EC%9E%85\" aria-label=\"js 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 타입</h1>\n<p>우리는 타입을 크게 신경쓰지않으며 변수를 선언하지만, 실제 js에서는 크게 7가지 타입이 있다. 타입에 따라 js엔진이 저장, 처리하는 방법이 다르고 결과에 영향을 미치기에 우리는 타입에 대하여 알 필요가 있다.</p>\n<p>js 변수에는 주소가 할당된다. 변수는 결국 사람이 보기 위해 만든 ‘식별자’이며, 변수는 어떠한 값을 갖는 주소로 대치된다. 여기서는 구체적으로 js가 stack, heap의 공간에 적재하는 방법보다는 그 값들을 어떻게 사용하는지, 즉 타입에 대한 정책을 공부해보고자 한다.</p>\n<h2 id=\"원시-타입primitive-type---immutable\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85primitive-type---immutable\" aria-label=\"원시 타입primitive type   immutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원시 타입(Primitive type) -> immutable</h2>\n<ul>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Number</li>\n<li>BigInt</li>\n<li>String</li>\n<li>Symbol</li>\n</ul>\n<p>위의 타입들은 원시 타입에 해당하며, 원시값은 불변하다.</p>\n<p>불변한 값들은 바뀌지 않고, 대입 연산자(=)를 통하여 새로운 값이 할당 된다.</p>\n<p><u>여기서 말하는 값은 변수가 가리키는 주소에 적혀있는 내용</u>! 그걸 값이라고 생각하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\na<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">===</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// false</span></code></pre></div>\n<p>a는 새로운 값(2)이 할당된다. a는 1이 위치한 주소를 가리키고 있다가 대입 연산을 통하여 [1이 2로 변경된 것이 아닌] <strong>2가 위치한 주소를 가리키도록 바뀌</strong>는 것이다.</p>\n<h3 id=\"const\" style=\"position:relative;\"><a href=\"#const\" aria-label=\"const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const</h3>\n<p>위의 코드에서 변수 선언 키워드를 let에서 const로 바꾸면 반드시 에러가 난다. const로 선언된 변수는 값의 재할당이 되지 않기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\na<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code></pre></div>\n<p>즉, 원시타입의 변수는 항상 대입연산자에서 새로운 주소로 할당이 이루어 진다는 것을 알 수 있다!</p>\n<p>추가적으로, const에 대하여 헷갈렸던 점을 정리해보자면…</p>\n<p>const로 선언한 변수에 재할당이 완전 불가능한 것은 아니다. <strong>const로 선언한 변수로는 재할당이 불가능</strong>한 것이다… 말이 어렵지만, <code class=\"language-text\">react.js</code>에서 힌트를 얻을 수 있다. <code class=\"language-text\">const [count, setCount] = useState(0);</code>와 같이 state를 const로 선언하고, setState함수로 state를 재할당하지 않는가?</p>\n<p>당연히, 리액트에서 <code class=\"language-text\">count +=1;</code>와 같은 코드는 존재하면 의도하지 않은 결과를 보이겠지만, const로 선언하면 해당 코드에서 에러가 나오게될 것이다! 따라서 state를 const로 선언하는 것은 리액트가 추구하는 방향인 것이다 ^_^</p>\n<p>원시값에도 각 타입마다 사용가능한 함수가 다르므로 차이를 알고 사용할 수 있도록 한다. 원시값의 함수는 대부분 새로운 값을 리턴하는 immutable function일 것이다.</p>\n<h2 id=\"객체object-type--참조reference-타입---mutable\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4object-type--%EC%B0%B8%EC%A1%B0reference-%ED%83%80%EC%9E%85---mutable\" aria-label=\"객체object type  참조reference 타입   mutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체(object type) / 참조(reference) 타입 -> mutable</h2>\n<p>객체, 함수, 배열 등</p>\n<p>객체타입은 변경이 가능하다. 따라서, 객체 타입에서의 대입 연산은 원시타입과 다른 결과를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> age_origin <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span> <span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> age_origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person_after_year <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\nperson_after_year<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token operator\">===</span> person_after_year<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">===</span> age_origin<span class=\"token punctuation\">)</span> <span class=\"token comment\">//false</span></code></pre></div>\n<p>위의 코드를 <a href=\"https://pythontutor.com/visualize.html#mode=display\">pythontutor.com</a>의 visulize 서비스를 이용하여 이를 시각화해볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVQoz32SbW/aMBSF+f9/ZF/WD/vUVm2lTVvXjmYg6EqgLTQECMS8hJAXJ7bjZyLZKqRJO9Lx9dW1zvWxb4t/YOs1y1KCYFFTa/1eDcMQz/MQQmCtrc8fY7OHljYVSlcoYyl1RalNnctCEcUJ22iPNqZpZSHPJXF8IMtlnZ/yKN6ahzu+d0bcdVxG0zXt/gu90QyRWBa7kuVe1w1OHawCjyzZAiUggQJQtWhrE+dMlgn+OmfwFuL8mtB/ntNxpzyNV/SGPqYCU1WkhWJ3OLB8ucD98QExu0asr/H9TyjlNpaPgp7ImG8LXE9w1x1x6wz4fN/DfVvx0/VZxzmbQ8YqSplvtkTTK6a9jyy9c0JxyX5/iVJPfwUlnsiZiowgUkyCmHb/lYfHMZNFxGAWEewSjm/dwCDX9wydMybDc4LlDdY+YMxrY3m1S7j44tQ3+uYMuPrq0H4cc3Pb5dnf0h0LEqn+fIqlshatSoxRVEZTVRqlCoxpJqFVKE0iNVmhOWRlHeNUkkpNKlXN6mQ8/odj/TelLl46O0MgJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img1\"\n        title=\"img1\"\n        src=\"/static/ab3fbf029ae6ffc630a5a99864b03606/37523/img1.png\"\n        srcset=\"/static/ab3fbf029ae6ffc630a5a99864b03606/e9ff0/img1.png 180w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/f21e7/img1.png 360w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/37523/img1.png 720w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/5a6dd/img1.png 802w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>객체 타입을 대입해주면, 해당 변수가 객체의 주소를 갖게 되는 것이다. 따라서, 여러 변수가 같은 객체를 공유하게 되는 상황이 올 수 있다. 이러한 상황을 ‘얕은 복사’라고 볼 수 있다. person과 person_after_year는 <code class=\"language-text\">alias</code>관계를 갖게 되는 것이다.</p>\n<h3 id=\"const-1\" style=\"position:relative;\"><a href=\"#const-1\" aria-label=\"const 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const</h3>\n<p>그럼 여기서도 const로 선언해도 될까? 당연히 가능하다!! const는 재할당을 막는 것이지만, <strong>객체의 프로퍼티를 변경하는 것은 값을 변수의 주소를 재할당하는 것이 아니</strong>기 때문이다 ~</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> age_origin <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span> <span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> age_origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> person_after_year <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\nperson_after_year<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//에러가 발생하지 않는다!!</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token operator\">===</span> person_after_year<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">===</span> age_origin<span class=\"token punctuation\">)</span> <span class=\"token comment\">//false</span></code></pre></div>\n<h3 id=\"복사얕은-깊은\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC%EC%96%95%EC%9D%80-%EA%B9%8A%EC%9D%80\" aria-label=\"복사얕은 깊은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사(얕은, 깊은)</h3>\n<p>원시값과 다르게 참조의 형태로 값이 전달되는 것(얕은 복사)은 간혹 의도하지 않은 결과가 나올 수 있다. (실행 순서에 따라 다른 결과가 나올 수도 있다)</p>\n<p>따라서, 객체타입에서 값을 대입할 때(복사할 때)에는 깊은 복사를 진행해줄 필요가 있다. 이를 위해서는 크게 3가지 방법이 존재한다.</p>\n<ol>\n<li>정석적으로 깊은 복사(depth만큼의 for loop를 통하여 원시값들을 복사해온다) : 이 방법은 깊이가 낮을 때에는 편하지만 깊어질수록 어려워진다. 재귀함수를 써서 구현해볼 수 있을 것 같다.</li>\n<li>라이브러리(<code class=\"language-text\">immutable.js</code>등) : 이를 위한 신뢰도 높은 라이브러리가 존재하므로 잘 읽어보고 사용하면 될 것 같다.</li>\n<li>트릭 : <code class=\"language-text\">JSON.parse(JSON.stringify(object))</code> js에서 객체 타입은 JSON으로 변경이 가능하므로, 이와 같은 트릭으로 할 수도 있다. 하지만, 객체를 문자열로 바꾸고 다시 JSON으로 파싱하는 것이므로 속도가 느릴 것이며 권장되지 않는다.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB8UlEQVQ4y5WSWW/aUBCF+f9/o6patX2ooj61eUgTVU1ICIQtBgzesNkM3sAb1/erME0IbaOkRxrN6C5nzp1zK1JKnsYO2+2WMAxZr9dl/YAkSfB9nyiKHs8+5AdU+Ae2eY49HmMaBnEcP64HQYCmjbAs83ejnYiijH0NlYExZWTNMSYrNNtFt12W0RY/lmXk4lhJkm4p5N8i9tuSSq1rctPR6Yzm1Do6160RqhOg2gGKuSLOxBHhzKgxbJ8SzFvEcRfPqyOECoi9QstNmQaCtupw9rNB/d4oc0MxuGz0CeOcdZIRximOt2ZhnNO/foOlnOB5X1HV90TR2W5Qe0J7leN4OfYqw3ITLqptru4G9PQ5bX2Js1qX6gopEQVky2u0+jv6jU+Y5glCXCDEFVJme1OqrRHV5pDmwOFHTaHaVDm7anGvzeiYHm6YHM2qSGYsJ13cqYLvqySJTpaNkXI/msqdotPs6XTVMY3uiJ42oanomFOf4SRgEcRESUqc5uUFP9yQZsXzpvBKlHNMchbWLXr3FH92x2bTxvdvyfP+wZQ/P/ZzscMiTJho31Fv3mL1vrBafWMw+EAUnR9MeRXZE1Lh3TCsvaVX/4hhfEaIc4ri8mDKS089JoV8M8F17nGnfaJII00N8tw+mML/QMoXm/8Chx3ipfxGvU4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img2\"\n        title=\"img2\"\n        src=\"/static/b8b3d6798ff62b24c10f4c98c39d8924/37523/img2.png\"\n        srcset=\"/static/b8b3d6798ff62b24c10f4c98c39d8924/e9ff0/img2.png 180w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/f21e7/img2.png 360w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/37523/img2.png 720w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/d7542/img2.png 810w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>깊은 복사를 성공적으로 했다면 위와 같이 분리된 객체로 저장될 것이다. 두 변수는 이제 서로 영향을 미치지 않는다!</p>\n<p>추가적으로, <code class=\"language-text\">spread연산자</code>(<code class=\"language-text\">...</code>)는 1 depth에 대하여만 깊은 복사를 해준다. (값을 옮겨 담는다고 생각하면 편할 것 같다)</p>\n<h2 id=\"함수의-성격\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EC%9D%98-%EC%84%B1%EA%B2%A9\" aria-label=\"함수의 성격 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 성격</h2>\n<p>함수의 성격 역시 mutable, immutable로 구분할 수 있다. mutable한 함수는 값을 변화시킬 것이고, immutable한 함수는 파라미터 값을 기반으로 새로운 결과값을 리턴하는 형식으로 구현되어 있다. 배열에서 concat, push를 보면 차이를 알 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> list_a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nlist_a<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[1,2,3,4]의 새로운 배열을 리턴 (immutable)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>list_a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1,2,3]!</span>\nlist_a<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// list_a에 접근하여 4를 추가 (mutable)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>list_a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1,2,3,4]</span></code></pre></div>\n<p>물론 함수 자체는 mutable하지만, 이는 함수의 성격에 따라 나눈 것이므로 구분지을 필요가 있다.</p>\n<h2 id=\"타입의-필요성\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"타입의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입의 필요성</h2>\n<p>나도 위의 내용을 이해하고 있지 않아, 의도하지 않은 결과가 나올때가 종종 있었다. 또한, react js에서 state는 불변하게 관리되어야 하므로 꼭 타입에 대한 이해가 선수되어야 한다는 것을 깨달았다.</p>\n<p>또한, 타입에 따라 제공되는 함수가 다르므로 각 타입을 구분할 수 있어야 할 것이다!</p>\n<p>다음에는 js에서 변수를 선언하는 방식(var, let, const)과 이에 따른 메모리 구조에 대하여 간단하게 알아보자.</p>\n<p>출처 : <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures</a></p>","excerpt":"JS 타입 우리는 타입을 크게 신경쓰지않으며 변수를 선언하지만, 실제 js에서는 크게 7가지 타입이 있다. 타입에 따라 js엔진이 저장, 처리하는 방법이 다르고 결과에 영향을 미치기에 우리는 타입에 대하여 알 필요가 있다. js 변수에는 주소가 할당된다. 변수는 결국 사람이 보기 위해 만든 ‘식별자’이며, 변수는 어떠한 값을 갖는 주소로 대치된다. 여기서는 구체적으로 js가 stack, heap의 공간에 적재하는 방법보다는 그 값들을 어떻게 사용하는지, 즉 타입에 대한 정책을 공부해보고자 한다. 원시 타입(Primitive type) -> immutable Boolean Null Undefined Number BigInt String Symbol 위의 타입들은 원시 타입에 해당하며, 원시값은 불변하다. 불변한 값들은 바뀌지 않고, 대입 연산자(=)를 통하여 새로운 값이 할당 된다. 여기서 말하는 값은 변수가 가리키는 주소에 적혀있는 내용! 그걸 값이라고 생각하자. a는 새로운 값(…","frontmatter":{"date":"March 05, 2023","title":"(JS) 자바스크립트 타입","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-JS-type/"}},"next":{"id":"63f88978-7671-5bed-a256-0aebaa0739cb","html":"<p>웹서비스의 기본인 회원가입부터 해보자. nest js로 하려다가 db 구축이 매우 쉽다고 판단되는 <code class=\"language-text\">DRF</code>(Django Rest Framework)를 이용하여 만들어보려고 한다.</p>\n<p>회원가입 시, 서버의 요구사항은 회원들의 정보를 구분되도록, 추가적으로 안전하게 저장하는 것이다.</p>\n<h1 id=\"장고-세팅\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EA%B3%A0-%EC%84%B8%ED%8C%85\" aria-label=\"장고 세팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장고 세팅</h1>\n<p>장고에 대하여는 <a href=\"https://choieastsea.github.io/DRF_serializer/\">이전글</a>을 참고해보자. 나도 생활코딩님의 <a href=\"https://www.youtube.com/playlist?list=PLuHgQVnccGMDLp4GH-rgQhVKqqZawlNwG\">강의</a>를 보고 약간의 블로그와 공식문서를 읽은 정도의 수준이니 따라올 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">mkdir</span> server \n<span class=\"token builtin class-name\">cd</span> server\npython <span class=\"token parameter variable\">-m</span> venv project_env\n<span class=\"token builtin class-name\">source</span> project_env/bin/activate\npip <span class=\"token function\">install</span> djangorestframework mysqlclient\ndjango-admin startproject auth_project</code></pre></div>\n<p>auth_project/settings.py에서 config(db 세팅) 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">DATABASES <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'default'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'ENGINE'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'django.db.backends.mysql'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'NAME'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'member_auth'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'USER'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'db_konkuk'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'PASSWORD'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'6812'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'HOST'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'localhost'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'PORT'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'3306'</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">django-admin startapp member</code> 로 member app을 생성해준다.(회원에 대한 모듈)\nls >> auth_project   member  project_env\nsettings.py의 INSTALLED_APPS에 ‘member’ 추가해줘야 이후 만들 model을 인식할 수 있다.</p>\n<p>auth_project/urls.py 수정 (<code class=\"language-text\">path('', include('member.urls'))</code> 추가)\nmember/urls.py 생성하여 아래와 같이 작성해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">urlpatterns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    path<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> views<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>member/views.py 추가</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">index</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">(</span><span class=\"token string\">'Hello Django'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">python manage.py runserver</code>로 서버 실행할 수 있다.</p>\n<p>localhost:8000 접속시 나오는 Hello Django 확인\n이러면 장고 기본은 세팅 완료.!</p>\n<h1 id=\"db-세팅\" style=\"position:relative;\"><a href=\"#db-%EC%84%B8%ED%8C%85\" aria-label=\"db 세팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 세팅</h1>\n<p>settings.py에서 db_config 적어놓고, 해당 db에서 db를 생성해준다.\n<code class=\"language-text\">create database member_auth;</code>\n스키마를 만들어주기 위해, drf의 migration을 사용하자.</p>\n<p>우선, member app의 models.py에서 회원가입을 위한 사용자 모델을 만들어주자. user_id는 겹치지 않게 unique로 해준다. PK는 따로 지정하지 않으면 장고에서 <code class=\"language-text\">auto increment id</code>로 만들어 줄 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> django<span class=\"token punctuation\">.</span>db <span class=\"token keyword\">import</span> models\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span>models<span class=\"token punctuation\">.</span>Model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    user_name <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>CharField<span class=\"token punctuation\">(</span>max_length<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n    user_id <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>CharField<span class=\"token punctuation\">(</span>max_length<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> unique<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    user_pw <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>CharField<span class=\"token punctuation\">(</span>max_length<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n    created <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>DateTimeField<span class=\"token punctuation\">(</span>auto_now_add<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>그러고, migration file을 만들어준다. 해당 migration을 db에 apply시켜주면 스키마가 만들어 질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token operator\">>></span>python manage.py makemigrations member\nMigrations <span class=\"token keyword\">for</span> <span class=\"token string\">'member'</span><span class=\"token builtin class-name\">:</span>\n  member/migrations/0001_initial.py\n    - Create model User\n<span class=\"token operator\">>></span>python manage.py migrate member\nOperations to perform:\n  Apply all migrations: member\nRunning migrations:\n  Applying member.0001_initial<span class=\"token punctuation\">..</span>. OK</code></pre></div>\n<p>db에 member_user 테이블의 스키마가 만들어져있음을 확인할 수 있다.</p>\n<h2 id=\"serializer-구현\" style=\"position:relative;\"><a href=\"#serializer-%EA%B5%AC%ED%98%84\" aria-label=\"serializer 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serializer 구현</h2>\n<p>간단하게, serializer를 만들어보자. ModelSeriallizer를 이용한다.</p>\n<p>serializer.py</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> rest_framework <span class=\"token keyword\">import</span> serializers\n<span class=\"token keyword\">from</span> member <span class=\"token keyword\">import</span> models\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">UserSerializer</span><span class=\"token punctuation\">(</span>serializers<span class=\"token punctuation\">.</span>ModelSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Meta</span><span class=\"token punctuation\">:</span>\n        model <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>User\n        fields <span class=\"token operator\">=</span> <span class=\"token string\">'__all__'</span>\n</code></pre></div>\n<p>이제 회원가입을 처리하는 기본 메소드를 만들어보자.</p>\n<h1 id=\"회원가입-basic\" style=\"position:relative;\"><a href=\"#%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-basic\" aria-label=\"회원가입 basic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>회원가입-basic</h1>\n<p>우선, member의 urls.py에서 signup url과 views를 매핑해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">urlpatterns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    path<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> views<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    path<span class=\"token punctuation\">(</span><span class=\"token string\">'signup'</span><span class=\"token punctuation\">,</span>views<span class=\"token punctuation\">.</span>signup<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>그리고, views에서 signup 함수를 만들어주자.</p>\n<p>(POST method를 받아서 처리해야하므로, <strong>settings.py에 ‘rest_framework’를 추가해줘야한다</strong>)</p>\n<p>member > views.py</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> django<span class=\"token punctuation\">.</span>shortcuts <span class=\"token keyword\">import</span> HttpResponse\n<span class=\"token keyword\">from</span> rest_framework <span class=\"token keyword\">import</span> status\n<span class=\"token keyword\">from</span> rest_framework<span class=\"token punctuation\">.</span>decorators <span class=\"token keyword\">import</span> api_view\n<span class=\"token keyword\">from</span> rest_framework<span class=\"token punctuation\">.</span>response <span class=\"token keyword\">import</span> Response\n<span class=\"token keyword\">from</span> member<span class=\"token punctuation\">.</span>serializer <span class=\"token keyword\">import</span> UserSerializer\n<span class=\"token comment\"># Create your views here.</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">index</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">(</span><span class=\"token string\">'Hello Django'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">signup</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    user_info <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>data\n    serializer <span class=\"token operator\">=</span> UserSerializer<span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span> user_info<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> serializer<span class=\"token punctuation\">.</span>is_valid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        serializer<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span>serializer<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> status <span class=\"token operator\">=</span> status<span class=\"token punctuation\">.</span>HTTP_201_CREATED<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span>serializer<span class=\"token punctuation\">.</span>errors<span class=\"token punctuation\">,</span> status<span class=\"token operator\">=</span>status<span class=\"token punctuation\">.</span>HTTP_400_BAD_REQUEST<span class=\"token punctuation\">)</span> </code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABuElEQVQ4y6VUy07kMBD057InLgjtL3BguHDhfxatAHGaESwgVmJmNRKTh/NwYid+FGpnPHiHgCLRUslO2662u7rDqqpCXdew1nporWGM8WMA+Z1zk8CapkHf91BKoW1bZFmGNE2RJIkPRGsUYCoYAM9MRg4iFUJ4ojELe3fzgK35G9JNiCx+WkhBjK7rdmmgoMbagXhL7p+8KXuUZeE30CEpJYri/Ts8JeQ3HJRKQSYJ2tdXD5p7QlogAooe8kgEY0b+HaGU0LRXShipYLfB2H5+vkK8hy7gRoKyqeWwD08YxIhF2VduigXCMeGYIUWdg7YGvZkKjZrEaxoIqhJRoxAt1rwFg2hhawH0BqAq+CbY7OkWJ/dXuFjd4fzfHU6Xc5ytFpit5hEWI5hH4zvY8d8bHD1f4+fzDQ4ff+Pg4RI/JuLgz68PPgbZDc+dYiYS75MzrKgqNFScznphMp4j5zkyzkFrgooXDtpZkIBh7HQP1antucFHYPT7og4Z+tch5aWHVJ2vr7ig45FKZL1eI00ScMlRqWq4IfVsWZaelAh5JaC0/a8LxjqFsHxZYpNukKschSwgtcQbW0Yb2B5KgnAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20230105182137181\"\n        title=\"image-20230105182137181\"\n        src=\"/static/03057a989231151cd330d42b98007c85/37523/basic_signup.png\"\n        srcset=\"/static/03057a989231151cd330d42b98007c85/e9ff0/basic_signup.png 180w,\n/static/03057a989231151cd330d42b98007c85/f21e7/basic_signup.png 360w,\n/static/03057a989231151cd330d42b98007c85/37523/basic_signup.png 720w,\n/static/03057a989231151cd330d42b98007c85/302a4/basic_signup.png 1080w,\n/static/03057a989231151cd330d42b98007c85/07a9c/basic_signup.png 1440w,\n/static/03057a989231151cd330d42b98007c85/80cfc/basic_signup.png 1844w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>db에도 잘 생성되어있지만, pw가 그대로 저장되어 있어 db가 노출되면 문제가 생길 수 있다.!(사용자는 보통 같은 아이디와 비밀번호를 사용하기 때문이다) 이제 비밀번호를 암호화하여 저장하도록 하자.</p>\n<h1 id=\"회원가입---암호화\" style=\"position:relative;\"><a href=\"#%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85---%EC%95%94%ED%98%B8%ED%99%94\" aria-label=\"회원가입   암호화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>회원가입 - 암호화</h1>\n<p>장고에서 User모델을 이용하여 비밀번호를 암호화하여 관리하는 방법도 있지만, <code class=\"language-text\">bcrypt</code> 라이브러리를 이용하여 비밀번호를 암호화하여 저장해보도록 하자. 추가적으로, 암호학에 정통한 사람이 아니라면 직접 암호화 알고리즘을 만드는 것은 권장되지 않고, 잘 알려진 최신까지 잘 쓰이는 라이브러리를 사용하는 것이 권장된다.</p>\n<h2 id=\"bcrypt-간단한-사용법\" style=\"position:relative;\"><a href=\"#bcrypt-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"bcrypt 간단한 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>bcrypt 간단한 사용법</h2>\n<p><code class=\"language-text\">pip install bcrypt</code>로 설치할 수 있다.</p>\n<p>bcrypt를 이용하여 우리가 해볼 것은 크게 1. 회원가입시 비밀번호를 암호화하기 2. 로그인시 입력과 암호화한 비밀번호 비교하기 가 있다.</p>\n<ol>\n<li>\n<p>비밀번호 암호화</p>\n<p><code class=\"language-text\">bcrypt.hashpw(bytes, salt)</code>로 암호화할 수 있다.</p>\n<p>bytes에는 비밀번호를 bytes array로 인코딩하여 넘겨주면 되고, salt에는 추가할 salt값을 넘겨주면 된다. bytes는 python string의 내장함수를 이용하여 <code class=\"language-text\">${string}.encode('utf-8')</code>와 같이 바꿔줄 수 있고, salting값은 <code class=\"language-text\">bcyrpt.gensalt()</code>함수를 이용하여 생성할 수 있다. (default parm=10)</p>\n<p>추가적으로 생성된 암호는 bytes 타입이므로, DB에 저장할 때에는 다시 <code class=\"language-text\">decode('utf-8')</code>함수를 이용하여 문자열로 변환한 후 저장해줘야한다.</p>\n<p>views.py의 signup 함수는 아래와 같이 수정해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">signup</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    user_info <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>data\n    pw <span class=\"token operator\">=</span> user_info<span class=\"token punctuation\">[</span><span class=\"token string\">'user_pw'</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'원래 비밀번호: '</span></span><span class=\"token punctuation\">,</span>pw<span class=\"token punctuation\">)</span>\n    mod_pw <span class=\"token operator\">=</span> bcrypt<span class=\"token punctuation\">.</span>hashpw<span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> bcrypt<span class=\"token punctuation\">.</span>gensalt<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'암호화 후 비밀번호: '</span></span><span class=\"token punctuation\">,</span>mod_pw<span class=\"token punctuation\">)</span>\n    user_info<span class=\"token punctuation\">[</span><span class=\"token string\">'user_pw'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mod_pw<span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span>\n    serializer <span class=\"token operator\">=</span> UserSerializer<span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span> user_info<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> serializer<span class=\"token punctuation\">.</span>is_valid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        serializer<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span>serializer<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> status <span class=\"token operator\">=</span> status<span class=\"token punctuation\">.</span>HTTP_201_CREATED<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span>serializer<span class=\"token punctuation\">.</span>errors<span class=\"token punctuation\">,</span> status<span class=\"token operator\">=</span>status<span class=\"token punctuation\">.</span>HTTP_400_BAD_REQUEST<span class=\"token punctuation\">)</span> \n</code></pre></div>\n<p>실행해보면 같은 비밀번호에 대하여도 다른 암호화값으로 저장됨을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">원래 비밀번호:  <span class=\"token number\">1234</span>\n암호화 후 비밀번호:  b<span class=\"token string\">'$2b$12$Tp9RA7gOCYyXkL4tAcWRAOtiaTl5dlpIM6H8FsDSEnwfGmJzvent6'</span>\n<span class=\"token punctuation\">..</span>.\n원래 비밀번호:  <span class=\"token number\">1234</span>\n암호화 후 비밀번호:  b<span class=\"token string\">'$2b$12$g7H0uBrroFgqkMSgkikkVeEfOO.GVn06XksAfURraBiV3KFo9WtQS'</span></code></pre></div>\n<p>이제 로그인을 처리해보자.</p>\n</li>\n<li>\n<p>로그인</p>\n<p><code class=\"language-text\">bcrypt.checkpw(bytes, 암호화된 bytes)</code>로 로그인을 처리할 수 있다. 간단하게 성공시 hello, 실패시 bye를 출력해보도록 하자.</p>\n<p>views.py에서 login함수를 아래처럼 추가해주고, urls.py에도 <code class=\"language-text\">path('login', views.login)</code>를 추가해주도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    idpw <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>data\n    id_input <span class=\"token operator\">=</span> idpw<span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">]</span>\n    pw_input <span class=\"token operator\">=</span> idpw<span class=\"token punctuation\">[</span><span class=\"token string\">'pw'</span><span class=\"token punctuation\">]</span>\n    user_with_id <span class=\"token operator\">=</span> User<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>user_id<span class=\"token operator\">=</span>id_input<span class=\"token punctuation\">)</span>\n    serializer <span class=\"token operator\">=</span> UserSerializer<span class=\"token punctuation\">(</span>user_with_id<span class=\"token punctuation\">,</span> many<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    user_pw <span class=\"token operator\">=</span> serializer<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'user_pw'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">type</span><span class=\"token punctuation\">(</span>user_pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#암호화된 string</span>\n    <span class=\"token keyword\">if</span> bcrypt<span class=\"token punctuation\">.</span>checkpw<span class=\"token punctuation\">(</span>pw_input<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> user_pw<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">)</span> \n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token string\">'bye'</span><span class=\"token punctuation\">)</span>     </code></pre></div>\n<p>실행해보고 로그인이 되는지 postman 등에서 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">입력 비밀번호: <span class=\"token number\">1234</span>\n암호화 후 비밀번호: <span class=\"token variable\">$b</span><span class=\"token string\">'$2b$12$Nm22Ckx4vMVbZlckUyoodeBdDR2v3ANU8MJs98XJ3jtoJsXZG8sCm'</span></code></pre></div>\n<p>같은 비밀번호(1234)에 대하여 다른 해싱값이 생성됨을 확인할 수 있으며, 각각의 로그인도 잘 수행됨을 확인할 수 있다.</p>\n</li>\n</ol>\n<h3 id=\"bcrypt의-원리\" style=\"position:relative;\"><a href=\"#bcrypt%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"bcrypt의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>bcrypt의 원리</h3>\n<p>추가적으로, bcrypt와 같은 단방향 해싱을 이용한 암호화의 원리를 내가 이해한 만큼만 정리해보겠다. 단방향 해싱함수라는 것은 특정 input에 대하여 유일한 output이 나오지만, 역으로는 유추가 불가하도록 설계된 (역함수가 존재하지 않는.?) 함수이다. 따라서, 해시값으로 원본 비밀번호를 알 수 없으며 로그인 과정에서도 checkpw함수는 해시값과 input을 암호화한 값을 비교하여 일치하는지만 알 수 있는 것이다. 이러한 단방향 해싱에도 허점이 없는 건 아닌데, 바로 input 과 해시값을 매칭시켜놓은 표(ranbow table)를 아주 힘들게 만들어 놓고, 해시값으로 비밀번호 원본을 유추하는 방법(brute force로 일일이 대조)도 있긴 하다. 따라서 우리는 소금을 친다(?) gensalt()함수로 솔팅값을 주고 해싱을 돌리고, 이를 반복하여 원본을 유추하기 매우 힘들게 할 수 있다.</p>\n<p>또한, 위의 보면 생성된 비밀번호의 앞부분이 일치함을 알 수 있는데, bcrypt에서 암호화를 어떻게 수행하나를 보면 알 수 있다. <code class=\"language-text\">$&lt;used_algorithm>$&lt;cost_factor>$&lt;generated_salt>&lt;hash>$</code>의 꼴로 생성되므로 암호화된 bytes배열에서 알고리즘과 salt값을 이용하여 checkpw를 수행할 수 있게 되는 것이다.! (따라서, 암호화 생성 알고리즘이 같으므로 앞부분이 같은 것이다) <a href=\"https://stackoverflow.com/questions/69175990/how-does-password-checking-in-bcrypt-work\">출처</a></p>\n<p>회원제 사이트를 만들기 위해 기본적인 회원가입은 끝났다. 이제 해야할 것은, 로그인을 할 때 session이나 token을 만들어 사용자에게 권한에 맞는 요청만 허용하도록 하는 것이다!</p>","frontmatter":{"date":"January 08, 2023","title":"(배포) 웹서비스 배포하기 (2)(backend)회원가입과 암호화","categories":"WEB","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/deploy-2-drf_signup/README/"}},"prev":{"id":"b1a7cbae-d422-5854-a437-30b308f2df7a","html":"<p>기존 브라우저의 DOM 트리를 어떻게 처리하는지 간단하게 알아보고, react의 Virtual DOM이 어떤 방법으로 개선하려고 했는지 알아보도록 하자. (일부 정확하지 않을 수 있음)</p>\n<h3 id=\"브라우저에서-페이지를-보여주는-과정\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A5%BC-%EB%B3%B4%EC%97%AC%EC%A3%BC%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"브라우저에서 페이지를 보여주는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저에서 페이지를 보여주는 과정</h3>\n<p>기존 브라우저에서 html, css, js, 각종 정적인 파일들로 구성된 페이지를 보여주는 아주 개략적인 과정은 다음과 같다.</p>\n<p>우선, HTTP 프로토콜을 통한 리소스 요청 등(url을 입력한다던가, 특정 버튼을 누른다던가)에 의하여 서버로부터 위의 파일들을 받는다.</p>\n<p>브라우저는 렌더링엔진(ex. Gecko, webkit 등 브라우저마다 상이)의 html parser를 이용하여 HTML tag에 각각 대응이 되는 <code class=\"language-text\">DOM</code>(Document Object Model) tree를 만든다. 또한 CSS parser를 이용하여 <code class=\"language-text\">CSSOM</code>(CSS Object Model) tree를 만들고 이를 합쳐 <code class=\"language-text\">render tree</code>를 만든다. 파싱이 다 되고 나서야 render tree를 만드는 것은 아니고 되는대로(네트워크를 통해 전송받아 파싱이 되는대로, 등…) 만들어서 사용자에게 보여주는 것이라고 한다.(<a href=\"https://d2.naver.com/helloworld/59361\">출처</a>) render tree는 DOM tree와 1:1로 대응되지는 않는다.</p>\n<p>렌더 트리를 만드는 과정을 <code class=\"language-text\">attach</code>(스타일 포함한 객체로 변환)라고 한다. 이후,  <code class=\"language-text\">layout</code>(px단위로 정확한 위치 계산, <code class=\"language-text\">reflow</code>)의 과정 이후에 <code class=\"language-text\">paint</code>(그리기)를 하여 사용자가 보게 되는 것이다. 이 과정은 항상 정해진 것은 아니고, 각 엔진별로 캐싱, 최적화 등의 과정을 통하여 다르게 진행될 것이다.</p>\n<p>script 태그를 마주치는 경우에는 렌더링엔진에서 자바스크립트 엔진(ex. v8)으로 스위칭되어 자바스크립트 코드를 실행하게 된다. 해당 태그의 코드가 모두 실행된다면 다시 렌더링엔진이 컨텍스트를 가져가게 된다. 만약 자바스크립트 등에 의하여 화면의 변경이 이루어진다면, reflow, repaint의 과정을 거치게 된다.</p>\n<blockquote>\n<p>브라우저가 웹페이지를 그리는 방법</p>\n<p>[fetch] -> HTML/CSS/JS -> [parsing] -> DOM + CSSOM ->[attach]-> Render tree -> [layout/reflow] -> [(re)paint]</p>\n</blockquote>\n<h4 id=\"만약-리렌더링되는-경우에는\" style=\"position:relative;\"><a href=\"#%EB%A7%8C%EC%95%BD-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8A%94\" aria-label=\"만약 리렌더링되는 경우에는 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>만약 리렌더링되는 경우에는?</h4>\n<p>JS에서 DOM element를 건드리는 경우에는, 바꿔야 할 부분을 sub tree로 하는 DOM tree를 다시 만들고, re-paint하는데 까지의 과정이 필요하다. 모든 요소가 그려진 후 브라우저에서 일부 변경이 생길 경우엔, 해당 렌더러와 그 자식의 배치과정과 repaint 메서드가 발생한다.</p>\n<p>만약, 위의 과정에서 비교적 시간이 오래 걸리는 reflow, repaint를 줄일 수 있다면 좋겠지만 이는 어려운 일이다. 요즘 같이 복잡한 웹서비스에서는 더 많은 리렌더링 연산이 요구된다. 이에 리액트에서는 <code class=\"language-text\">Virtual DOM</code>으로 성능을 개선하고자 한다.</p>\n<h3 id=\"virtual-domin-react\" style=\"position:relative;\"><a href=\"#virtual-domin-react\" aria-label=\"virtual domin react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM(in react)</h3>\n<p>경량화, 추상화된 DOM이라고도 볼 수 있는 가상돔(Virtual DOM, VDOM)은 브라우저의 리렌더링 횟수를 줄이기 위해 <strong>최종적으로 리렌더링해야할 노드들을 기록하였다가 한번에 렌더링하도록 한다</strong>. 여러 layout과 paint 연산 대신 <u>하나의(그치만 무거운) layout과 paint 연산을 수행</u>하도록 하여 속도를 어느정도 개선한 것이다. 리렌더링이 매우 자주 일어나는 웹서비스에서는 VDOM이 더 유리할 가능성이 높다.</p>\n<p>React 공식 홈페이지에서는 VDOM을 <code class=\"language-text\">이상적인 또는 “가상”적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념</code>이라고 정의한다. DOM에서 필요한 정보들만으로 추상화되어 있고, js 객체로 구성된 VDOM은 2개의 상태(과거 시점, 업데이트 시점)를 비교하여 리렌더링을 진행한다.</p>\n<blockquote>\n<p>VDOM은 기존의 많은 리렌더링 연산을 한번의 리렌더링으로(batch 단위로) 업데이트한다.</p>\n</blockquote>\n<h4 id=\"리렌더링-in-vdom-reconciliation\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81-in-vdom-reconciliation\" aria-label=\"리렌더링 in vdom reconciliation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리렌더링 in VDOM (reconciliation)</h4>\n<p>리액트에서는 VDOM에서 어떤 노드가 변하였는지 알기 위해 비교(diffing)의 과정을 갖는다. 만약 모든 노드들의 값, 속성이 바뀌었는지 파악한다면 매우 많은 시간이 걸릴 것이지만, 리액트는 비교를 해야할 것들을 최소화하여 이 시간을 단축하였다. (<u>컴포넌트의 이름을 비교하고, list 등에 key로 비교하는</u> 등)</p>\n<p>리액트에서 리렌더링이 발생하는 과정에 대하여 좀 더 공부해보자.</p>\n<p>우선, 해당 컴포넌트의 <strong>state가 변경이 된다</strong>. useState hook의 setter로 업데이트 하였다면 해당 컴포넌트가 <code class=\"language-text\">rendering queue</code>로 들어간다. React는 <code class=\"language-text\">Object.is()</code>와 같은 비교 알고리즘으로 state가 진짜로 변경되었는지 여부를 판단할수 있게 된다. <a href=\"https://ko.reactjs.org/docs/hooks-reference.html\">출처</a></p>\n<p>VDOM의 루트노드부터 렌더링을 해야하는지 판단하는데, 이를 <code class=\"language-text\">rendering pass</code>라고 부른다. 이때는 해당 컴포넌트가 rendering queue에 있다면 렌더링해준다. 렌더링된다면, 해당 컴포넌트의 자식 컴포넌트가 리턴되는 형식이며 이는 재귀적으로 수행된다. 그러나 이전과 값이 동일한 참조이고, 렌더링을 해야하는 다른 이유가 없다면 리액트는 컴포넌트에 대한 렌더링 결과를 버리고 렌더링 패스를 벗어난다고 한다. <a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">출처</a></p>\n<p>따라서, 아래와 같이 버튼을 눌렀을 때 1을 더해주는 코드는 state가 변경이 된 것 처럼 보여도 해당 시점에 렌더링이 되지 않을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>me<span class=\"token punctuation\">,</span> setMe<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">25</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">...</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onPlusAge</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> after_change <span class=\"token operator\">=</span> me<span class=\"token punctuation\">;</span>\n    after_change<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">is</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">,</span> after_change<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n    <span class=\"token function\">setMe</span><span class=\"token punctuation\">(</span>after_change<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// re-render X!</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>따라서 불변성 지키며(다른 주소를 할당해야 함) state를 set해줘야 한다. <strong>헷갈리면 Object.is()로 비교해보자.</strong></p>\n<p>++ (참고) useEffect는 그리기를 완료한 <strong>후</strong> 발생한다고 한다.</p>\n<blockquote>\n<p>리액트의 리렌더링에서 알아야할 것</p>\n<ul>\n<li>state 변경은 불변적으로 수행해준다. setState가 다 해주는 것은 아니다</li>\n<li>리렌더링된다면 재귀적으로 자식 컴포넌트도 리렌더링 된다.</li>\n</ul>\n</blockquote>\n<p>리렌더링이 된다고 해서, 항상 다시 paint가 일어나는 것은 아니고 위에서 말한 reconciliation의 과정을 거쳐 실제 DOM에 적용을 하는 것으로 이해하면 될 것 같다.</p>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<p>리액트에서 VDOM은 항상 빠르다고 볼 수 없지만, Diffing과 batch update의 과정(필요한 노드들만 한번에 업데이트 하는 과정)을 통하여 DOM을 직접 제어하는 것보다는 빠를 확률이 높다고 볼 수 있다.</p>","frontmatter":{"date":"March 12, 2023","title":"(React) Virtual DOM에 대하여 알아보자","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-VDOM/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/FE-JS-type/","nextSlug":"/deploy-2-drf_signup/README/","prevSlug":"/FE-React-VDOM/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}