{"componentChunkName":"component---src-templates-blog-template-js","path":"/OS(2)-Process/","result":{"data":{"cur":{"id":"ef679d0a-8051-5f57-a48b-1868cb4bba1b","html":"<h1 id=\"process\" style=\"position:relative;\"><a href=\"#process\" aria-label=\"process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process</h1>\n<p>Process는 <strong>실행중인 프로그램</strong>(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 <code class=\"language-text\">CPU virtualization</code>을 해서, <strong>여러 프로그램이 동시에 실행되는 illusion을 만들어준다</strong>. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 <code class=\"language-text\">time sharing</code>이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 <code class=\"language-text\">context switching</code>부터, 고수준의 scheduling과 같은 <code class=\"language-text\">policy</code>까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까?</p>\n<h2 id=\"프로세스-표현하기process-abstraction\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0process-abstraction\" aria-label=\"프로세스 표현하기process abstraction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 표현하기(Process Abstraction)</h2>\n<p>프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태(<code class=\"language-text\">machine state</code>)를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다.</p>\n<ul>\n<li>\n<p>PID (프로세스를 구분하기 위해 프로세스마다 갖는 identifier)</p>\n</li>\n<li>\n<p>memory image(address space, 주소공간)</p>\n<ul>\n<li>code &#x26; static data(상수)</li>\n<li>stack(변수) and heap(동적할당된 변수)</li>\n</ul>\n</li>\n<li>\n<p>레지스터 (CPU context)</p>\n<ul>\n<li>PC(=Instruction Pointer, 현재 실행중임 명령어의 위치를 파악하는데 쓰임)</li>\n<li>stack pointer, frame pointer (함수의 변수와 리턴주소를 저장하는 스택을 관리할 때 쓰임)</li>\n<li>레지스터는 해당 프로세스의 명령어나 데이터가 위치한 어떤 영역을 가리키고 있을 것이다. 하지만, CPU는 담당하는 프로세스를 수시로 바꾸므로(context switching) <strong>실행에 필요한 CPU 레지스터가 가져야할 값을 process에서도 가져야 할 것</strong>이다.</li>\n<li>예를 들어, 100번 명령어까지 A 프로세스가 진행되고 101번이 진행될 차례에서 CPU가 B 프로세스로 넘어갔다고 가정하자. 다시 A 프로세스로 돌아와서 1번 명령어부터 시작하면 안될 것이다. 따라서, 레지스터의 값을 어떠한 형태로 저장해놔야 한다.</li>\n</ul>\n</li>\n<li>\n<p>입출력 정보</p>\n<ul>\n<li>프로세스에서 사용하는 입출력 정보(파일)를 갖고 있어야 한다. 여기에는 표준 입출력(STDIO/Error)과 관련된 파일들도 포함된다.</li>\n</ul>\n</li>\n</ul>\n<p>이렇게 실행중인 프로그램이 갖고 있어야하는 값들을 저장해놓은 자료구조가 <code class=\"language-text\">PCB</code>(Process Control Block)이다. 위에 다룬 내용 이외에도 실행을 위한 프로세스의 정보들이 포함되어 있다.</p>\n<p>즉, Program을 PCB로 추상화하여 관리가 되는 것을 Process라고 볼 수 있다. PCB는 실행중에만 유효하므로, 프로세스를 <strong>실행중인 프로그램</strong>이라고 봐도 무방할 것 같다.</p>\n<h2 id=\"프로그램이-프로세스가-되는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%90%98%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로그램이 프로세스가 되는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로그램이 프로세스가 되는 과정</h2>\n<p>저장공간에 존재하던 프로그램이 더블클릭등으로 실행되면 <strong>OS는 몇가지 작업을 수행</strong>한다. 우선, 내부적으로 프로그램의 실행 파일(<code class=\"language-text\">a.out</code>과 같은)이 실행될 것이다.</p>\n<ol>\n<li>메모리를 할당하고, Memory image를 생성한다.\n<ul>\n<li>code와 정적인 데이터를 메모리에 로드한다</li>\n<li>stack, heap 영역을 만든다</li>\n</ul>\n</li>\n<li>Basic files(STDIN, OUT, ERR)를 open한다.</li>\n<li>실행을 위한 CPU register들을 초기화한다.\n<ul>\n<li>PC는 code의 첫번째 위치를 가리키고 있을 것</li>\n</ul>\n</li>\n</ol>\n<p>그림으로 프로그램이 실행되는 과정을 간단하게 그려보면 아래와 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 107.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADQUlEQVQ4y42Uy29TRxTGf/diO45NHGwnIcUJJQnY4CAIEFryAsKjRQUEBbqt1OcChCqiktzjgECV2qpKoKq6b6VKLFBV8Xd03T+ArhALkFggUHE8B83cSeyESmSkI82dueeb73znAaJ9iG5HdATRCUSHEK0gOkDNQE1jk1U2gOgVRL9G9ENEUyt3/nIHYg468KbzNkTTiAExgT/fgjRGiOr7iOqHierTRPWPmHtVRrTXmWc0juhpRC2ovexG9H1Euxx4TQMPvIMfNM2xBTg0Cyd+BlVY1B7EdCNmwgLu9WxsmJs9uyKiY005GkPc1gIzzyYZvToG9JHqKJDq6AJ6gCxR3T5Ysc4XET3mXhczhWg/opsQLXnwkGgJZl/2cltHufDnEdqL48Al4BBhsotUbi8vFG5o1ToMMuccexDNIroRMfsQPYGYMAY1cPlhOz9pCcgTJqeAb4AJxzaZKXP6N5j7b7cF2rnitJwpp5keQMxQrLFJ8NU/bSzou0CJMGHDvgCMuJATmQrHF20UDtCy2YXosE9Ib5x1t/d6mjKzL4dZ1AFgK2HiC+AMYEPfRjI7yAe/4v5ZXV8mFSfGlOLQPfNvn8O1p1u5oyc5+uMkkKRQTgE54B3ai92cvw9Rvbq2YP/PAlcaqiHjtTNkeiyzT4HPgWmnY3ZzhrN/QLRUjRm82Q3BKl3/UvhdOzjyvU1CP2HilAvV7glsouAXDRGz0+3fynLmGVx7kuee7QQgSBymdV1+aNmlne5u1VqzbJYz3dzPO9AcC7oFKNLWWfRQIaWxgJvu/40ueU3nFWtzxWzPIg9qAede5bmp+0nlqmwabFth5zrE+aVdt63Jsm21k4h+HA8Ce9YIeOySEnDxwR6mbk1zV8uu5uJyq/oS2+WaZI1eKT/KKojJIQ24+iigvRhScPIMAhmromP33syyLBsQ7XSRtYAl4qljhhGzH9FpoqUi1194tRIdBBvOAV8CFR9w8EYCWz4yfnzl4+ljdjOv2/lbIZntB4Z8Ifd5lhC0EjKxtQB2xkCNPGKOMq/DTN4adWEms72sezVfKDhRmwMijTTKXPl3rUewPkBXIm7YnkL0Ezd9bW19p7Dns2C9BF8DhUbcjDtVz5EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"running_process\" title=\"running_process\" src=\"/static/5aefc6e84f527b756ce8f374300cb86c/37523/running_process.png\" srcset=\"/static/5aefc6e84f527b756ce8f374300cb86c/e9ff0/running_process.png 180w,\n/static/5aefc6e84f527b756ce8f374300cb86c/f21e7/running_process.png 360w,\n/static/5aefc6e84f527b756ce8f374300cb86c/37523/running_process.png 720w,\n/static/5aefc6e84f527b756ce8f374300cb86c/00d43/running_process.png 1000w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<h2 id=\"프로세스의-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 상태</h2>\n<p><strong>CPU 가상화를 위해 OS는 Process를 상태에 따라 관리하도록 하며 상태는 지속적으로 변이(transition)된다.</strong> 프로세스의 상태 역시 PCB에 저장될 것이며, 크게 3개로 나눠볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 648px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQ4y42T14rDQAxF5/9/x0/JS0IgJIQUgkkhnfTee9NytMwwWXbNCuQZ7Ksr6Uo27/dbMM7H46H+X3s+n3K/3+X1ejkOYwlPp5Mcj0d17th8Ppfdbifb7VY2m42s12t1iG63m2LP57Ps93slxgwPAjqdjlwuFyWAaLlcSiqVklgsJslkUuLxuCQSCQmCQFqtlsYMBgMlIwlxjpDgUqkk1WpVKpWKpNNpTVAoFJwXi0XJ5/OKG41GSsg9k8noCaG2bLU4HA6qH3oAxsheLpclDEMNgrTb7eo3H+/L5DREE0C0y92KHDWQyWTyQeZa9g2S8Xis1fnvfHISUymD+hlrqAa9ELjX66mGzWZThsOhOoMCSGu0yDsS9vt9xXM2Gg2ZzWbfFQKizcVioS3U63Vpt9v6kZWo1WqqKRWDozq7GdPpVAfE1B1h1OJSGSthlx3S6/UaiTdWH+u0Zjcf4dlF1iiXy0k2m3WVgPFjrMbmr0w2aLVaaVVUiSxoGrUBJqp8jF/K/npo+tvUfcIvTVvlDBEEcmcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"state\"\n        title=\"state\"\n        src=\"/static/2f160f943f3404a15e87ae52c3cf7f7b/3996e/process_state.png\"\n        srcset=\"/static/2f160f943f3404a15e87ae52c3cf7f7b/e9ff0/process_state.png 180w,\n/static/2f160f943f3404a15e87ae52c3cf7f7b/f21e7/process_state.png 360w,\n/static/2f160f943f3404a15e87ae52c3cf7f7b/3996e/process_state.png 648w\"\n        sizes=\"(max-width: 648px) 100vw, 648px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li><strong>Running</strong> : CPU에서 해당 프로세스를 실행중에 있는 상태\n<ul>\n<li>Process는 많지만 한 CPU에서는 하나의 Process만 수행할 수 있다. Running Process로 가는 과정을 <code class=\"language-text\">Scheduling</code>이라고 하며, 이에 대하여 OS의 스케줄링 정책 등이 관여한다.</li>\n</ul>\n</li>\n<li><strong>Ready</strong> : scheduled 되기 위해서 기다리고 있는 상태\n<ul>\n<li>나머지 프로세스들은 Ready 상태로 <code class=\"language-text\">Ready Queue</code>에 들어가 있다. ready queue는 단순하게 하나만 존재하진 않으며 이는 뒤의 스케쥴링에서 자세히 다루도록 한다.</li>\n</ul>\n</li>\n<li><strong>Blocked</strong> : Running이였다가 인터럽트가 발생하여 잠시 CPU가 해당 프로세스에 대한 작업을 중지한 상태\n<ul>\n<li>File IO 등은 CPU 입장에서 매우 매우 시간이 오래 걸리는 작업이다. 따라서 운영체제는 cpu를 효율적으로 사용하기 위해 IO interrupt가 발생하면 이를 catch하여 해당 io작업이 완료될때까지 프로세스를 <code class=\"language-text\">block</code>시킨다.</li>\n<li>io작업이 완료되면 ready queue로 다시 돌아가게 될 것이다.</li>\n</ul>\n</li>\n</ul>\n<p>다음은 OSTEP 책에 나와있는 Process state transition의 예시이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz21TaW+CUBDs//9p9kNtkEsOCzwOReRQuTymmUVIm3aTTR4PdmZ2dnlLkgRKKXRdhyiKwOeqqtC2LaIwRJokaJoGj8cD9/sdz+cT+yyD7/m4Xq/yPN8z3tIXYFPX+Fyvsf74gKHruFwu2Gga3lcrxCrG7XZD3/cYhgGn0wkqUjifzxjHEUM/CKgAysUwSIFtWfBcF47jCGMQBALOQsZc9DOonLWLQrJSDT/e2vYCSBICWqaJqpws4LvdbockjuG5HkzTFJuyNBUwggrgrMAwDOgbXbyr61oUMwnCiJUSAmfrwPc8IdA3G/H4FyAVMmzLhm3bk6dNA9d1J1X+BEh76qqSodHzrm1RleXS7h/AMAigaRqOx6O0SALLtKS9uYhWlGUpbeZ5vni5eMh1mQHph2kYoo73ruOIyuDra1qX/R5hGMpq8VsKYF5elolCKiEj2+FErZdvHBInOA7jcqbXJO+7TlaISXLW/tsyF/ZwOCDLsj+tMEhMlaeikF1k8tu5XgB5YHtMMs0E/As4aariOyppr614y6HIdjTNrwmLh6Ls5U1+yFEUheyfrIXnyTkMwuUuTVPZAubO96GiaAGkwm9opI603SW8mwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"process_transition\" title=\"process_transition\" src=\"/static/f53018f749245d534e6c469b460bd325/37523/process_transition.png\" srcset=\"/static/f53018f749245d534e6c469b460bd325/e9ff0/process_transition.png 180w,\n/static/f53018f749245d534e6c469b460bd325/f21e7/process_transition.png 360w,\n/static/f53018f749245d534e6c469b460bd325/37523/process_transition.png 720w,\n/static/f53018f749245d534e6c469b460bd325/302a4/process_transition.png 1080w,\n/static/f53018f749245d534e6c469b460bd325/9685e/process_transition.png 1336w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>Time 3에서 P0에서 I/O interrupt가 발생하였을 때, Blocked 상태가 되며 Ready Queue에서 가장 먼저 있던 P1이 CPU의 점유를 가져가게 된다. 이후, P0의 IO작업이 끝나게 되고 ready queue로 들어가게 되며, P1이 끝나서 다시 CPU의 점유를 P0이 가져오게 된다. 만약 P1이 종료되지 않았더라도, P1의 I/O 작업이나 스케쥴링 정책에 의하여 P0으로 언젠가는 다시 돌아갔을 것이다.</p>\n<h3 id=\"세분화-프로세스의-5가지-상태\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%B6%84%ED%99%94-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%83%81%ED%83%9C\" aria-label=\"세분화 프로세스의 5가지 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(세분화) 프로세스의 5가지 상태</h3>\n<p>위에 상태에 추가적으로 생성되고 아직 ready queue에 들어가지 않은 <strong>New</strong> 상태와, 프로세스가 종료된 <strong>Dead</strong> 상태도 존재한다. 이러한 Process의 상태 역시 운영체제 마다 조금씩 다르니 참고하자.</p>\n<h2 id=\"pcb\" style=\"position:relative;\"><a href=\"#pcb\" aria-label=\"pcb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB</h2>\n<p>OS는 PCB(Process Control Block)이라는 자료구조를 리스트로 관리하여 프로세스에 대한 정보를 갖는다. 운영체제에 따라 PCB의 구현 방법이나 구체적인 이름은 다르지만 공통적으로 갖는 값들은 모두 프로그램의 실행과 프로세스의 관리를 위한 것이다. PCB는 보통 아래의 값들을 갖는다.</p>\n<ul>\n<li>PID</li>\n<li>Process state (Running, Blocked, Ready, …)</li>\n<li>Pointers to other related processes : 부모 프로세스의 정보</li>\n<li>CPU context of the process : running에서 다른 상태로 넘어갈 때, register값들(PC, SP …)을 PCB에 저장해놔야 스케줄링될때 복원할 수 있음</li>\n<li>pointers to memory locations</li>\n<li>pointers to open files</li>\n</ul>\n<p>추가적으로 스케줄링을 위한 Process의 우선순위 등도 PCB에 저장되어야 할 것이다.</p>\n<h1 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h1>\n<p>운영체제는 CPU를 <code class=\"language-text\">가상화</code>하여 multiple process를 동시에 실행하는 착각을 갖게 해준다. 시간을 잘게 쪼개서 여러 프로세스들을 돌아가며 실행하여(time sharing) 여러 프로그램들이 동시에 실행되는 것 처럼 보이는 것이다.</p>\n<p>따라서 개발자들은 한 프로그램을 운영체제가 어떻게 지원해주는지만 알면 될 것이다. OS는 <code class=\"language-text\">PCB</code>와 같은 자료구조를 통해 Process를 추상화하여 제공하며, Process는 CPU가 해당 Process를 어떻게 관리 하고 있는지에 따라 <code class=\"language-text\">state</code>가 바뀌게 된다. 실행중인 process는 OS의 <code class=\"language-text\">scheduler</code>에 의하여 관리된다.</p>\n<p>다음 포스트에서는 OS에서 Process를 다루기 위해 제공해주는 Process API(주로 system call)와 Process가 실행되는 과정에 대하여 구체적으로 공부해보도록 하자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"Process Process는 실행중인 프로그램(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 을 해서, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 부터, 고수준의 scheduling과 같은 까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까? 프로세스 표현하기(Process Abstraction) 프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태()를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다. PID (프로세스를 구분하기 위해 프로세…","frontmatter":{"date":"June 28, 2023","title":"(OS) 운영체제 복습 [2. Process Abstraction]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(2)-Process/"}},"next":{"id":"84137e27-ee51-5a2b-8271-d1e61c57eda6","html":"<p>운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자!</p>\n<h1 id=\"von-neumann-architecture\" style=\"position:relative;\"><a href=\"#von-neumann-architecture\" aria-label=\"von neumann architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Von Neumann Architecture</h1>\n<blockquote>\n<p>폰 노이만 구조</p>\n</blockquote>\n<p>컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 <code class=\"language-text\">CPU</code>로부터 <strong>fetch, decode, execute, writeback의 과정</strong>을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 <code class=\"language-text\">Memory</code>에 올라가(load)있어야하며, CPU는 <code class=\"language-text\">Program Counter</code> 레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다.</p>\n<p>이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 <code class=\"language-text\">폰 노이만 구조</code>라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 <u>실행하기 위해서는 메모리에 로드가 되어야 한다</u>는 것을 알 필요가 있다.</p>\n<h1 id=\"cpu\" style=\"position:relative;\"><a href=\"#cpu\" aria-label=\"cpu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU</h1>\n<blockquote>\n<p>Central Processing Unit</p>\n<p>중앙 처리 장치</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACCklEQVQoz5XPz2/SYBgH8P1LXjTxNg56NzFedZId8EcwWyjOaKLBZByMB9Q5tBFNxLk0HY65EUfbrGMrIOOXRJK+Rmgrc5SkIO8ovwrPAkUjGo1+8+TJN0/ez+GdgD9n89X7NVJYI4VoKMdRSbOLaeXHg4m/YDEtSXlVyquKqKJU6cN2Qcqr+8XyP2FJkqI70UwyU6/XVeWb/aQ3vi5ijH/F1WoVY6xpGh6mVqsBAPM6OTtJzk6SaeZTqVq+fspHzoVKeqkF7TGsVWryRxVjXPlSl/JqWamY2GEhHRZyL4xeaktzp589vbGeaCRYYMew7bjn6olF17mlO2f8l44t3D774mecDKM3yobDQmbDGYyxALExvECseOy0x04/uDYo/nvhwZ/zhbeh4OYGpxUOuBaPC6newd5vuGcMVjzJAx+DmBGL9/YTAFBTFebrE0ZexkhkmwwuRA4R12g0BnhIBtjI+oxdd9s3w+dskezl5vOZbuy+Ia50U14+NcXz59urN/mcrbN1qxNxdQT3Tu6KkfWNcA8hEJERCAoyJciUEQj2Pxf7RamHkCBTkZTX2I4IMgUiMmfUTdxkOZ0K6BTNsvMsO69TgdY7ppvNtXaF7xfavOsUrVP0FutuM9wIP4ZFAhwEOKfAOt2fJsBJgNMP/rvgsoLVClYCHMPtNOcCXHwED0dY7x/Cf8YkR1CrjNHuddQ8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cpu_architecture\"\n        title=\"cpu_architecture\"\n        src=\"/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png\"\n        srcset=\"/static/c9124f66758e84c155c133f783a2c728/e9ff0/cpu_architecture.png 180w,\n/static/c9124f66758e84c155c133f783a2c728/f21e7/cpu_architecture.png 360w,\n/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png 720w,\n/static/c9124f66758e84c155c133f783a2c728/7527b/cpu_architecture.png 754w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>CPU는 명령어를 해석하고 실행하는 장치이며, 이를 수행하기 위해 많은 Unit들이 존재한다. 주요 구성은 다음과 같다.</p>\n<ul>\n<li>\n<p>Control Unit</p>\n<p>decoder를 통해 binary코드의 명령어를 해석하고, 이에 적절한 제어 신호(메모리에서 레지스터로 가져오기, 연산, 쓰기)를 발생시킨다. 또한, 명령어의 실행 순서를 결정한다.</p>\n</li>\n<li>\n<p>Arithmetic &#x26; Logic Unit(ALU)</p>\n<p>연산 명령에 대하여 연산을 수행한다. 모든 연산은 atomic하며, 산술연산(ex 덧셈)과 논리연산(ex AND)으로 구분되어 수행된다.</p>\n</li>\n<li>\n<p>Register</p>\n<p>CPU가 갖는 <u>임시 저장소</u>. 연산을 수행하거나, 명령어를 fetch하는 것들이 각각의 레지스터에서 일어난다. 다음 명령어의 위치를 가리키고 있는 <code class=\"language-text\">Program Counter</code>(PC), 데이터를 보관하기 위한 <code class=\"language-text\">Data Register</code>와 주소를 저장하기 위한 <code class=\"language-text\">Address Register</code>, 실행 중인 명령어를 가져오는 <code class=\"language-text\">Instruction Register</code>, 메모리에 저장하거나 가져올 때 사용하는 <code class=\"language-text\">Memory Address Register</code>, <code class=\"language-text\">Memory Buffer Register</code> 등이 있다.</p>\n</li>\n</ul>\n<p>CPU가 다른 기기들과 주고 받는 정보는 크게 3가지로 나눌 수 있다.</p>\n<ul>\n<li>Control</li>\n<li>Address</li>\n<li>Data</li>\n</ul>\n<p>따라서 이는 위의 그림처럼 각각의 역할을 수행하는 버스를 통하여 주변 장치와 연결을 한다.</p>\n<p>CPU는 한번에 처리할 수 있는 데이터의 크기에 따라 오늘날 32bit, 64bit 컴퓨터로 나뉜다. 32비트 주소 체계는 2^32개의 주소를 담을 수 있다. 메모리는 한 주소당 1Byte를 갖으므로 2^32Byte = 4GB 정도의 데이터를 가리킬 수 있는 것이다. 따라서 32비트 컴퓨터는 최근에 사용되지 않는다.</p>\n<h2 id=\"interrupt\" style=\"position:relative;\"><a href=\"#interrupt\" aria-label=\"interrupt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt</h2>\n<p>CPU는 매우 빠르다.! 하지만, 주변 장치의 증가로 매우 느린 I/O 작업이 늘어나게 되면서 기존의 polling 방식은 성능이 낮아졌다. 이는 CPU가 IO device의 상태를 주기적으로 검사하여 데이터를 처리하는 방식으로, CPU의 본래 역할(fetch, decode, execute)에 I/O까지 수행하게 되어 매우 느리다. I/O가 수행될때까지 기다려야하기 때문이다.</p>\n<p>Interrupt 방식은 IO작업을  CPU가 기다리지 않고 다른 곳(입출력 관리자)에 위임하고, 완료되면 Interrupt 신호를 발생시키는 것이다. CPU는 I/O가 수행되는 동안 다른 작업들을 수행하면 되고, interrupt가 발생하면 지금 하던 작업을 멈추고 가져와진 데이터로 작업을 이어가면 된다.</p>\n<h3 id=\"direct-memory-accessdma\" style=\"position:relative;\"><a href=\"#direct-memory-accessdma\" aria-label=\"direct memory accessdma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Direct Memory Access(DMA)</h3>\n<p>기본적으로 Memory에 대한 접근 권한은 CPU만 갖고 있다. 따라서 장치들이 interrupt를 발생시켜 CPU가 메모리에 작업을 하도록 전송할 것이지만, 이것은 느리다. 따라서 I/O 수행시 <strong>장치들이 직접 메모리에 접근할 수 있다면 CPU를 더 효율적으로 사용할 수 있을 것</strong>이다. <code class=\"language-text\">DMA Controller</code>에게 CPU가 메모리에 대한 정보를 제공하고, 입출력 장치와 메모리 간의 직접적인 연결을 수행할 수 있도록 한다.</p>\n<p>DMA를 통해 메모리를 관리한다면, 메모리 구조가 복잡해질 수 있다.(CPU가 사용하는 영역과 입출력 장치가 사용하는 영역들의 혼재) 따라서 메모리를 OS 영역, CPU 영역, 입출력 작업 영역 등으로 분리하여 관리하는 방법을 <code class=\"language-text\">MMIO</code> (Memory Mapped I/O) 기법이라고 한다.</p>\n<p>DMA를 통해 메모리에 접근하면 여러 장치들(CPU 포함)이 동시에 메모리에 접근하려는 순간이 생긴다. 이때, CPU의 작업속도가 훨씬 빠르므로 CPU가 메모리 접근 순서를 양보하는데, 이를 <code class=\"language-text\">cycle stealing</code> 이라고 한다.</p>\n<h2 id=\"parallel-processing\" style=\"position:relative;\"><a href=\"#parallel-processing\" aria-label=\"parallel processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Processing</h2>\n<p>CPU의 성능을 향상시키기 위해 CPU의 클럭을 높이거나, 캐시의 크기를 늘리는 방법이 가장 대표적이다. 하지만, 클럭을 높이면 저항이 많아져 발열이 증가하게 되므로 이러한 하드웨어적인 향상에는 비용등의 현실적인 제약이 있다. 따라서, <strong>CPU 코어를 여러개 두어 병렬적으로 처리</strong>하는 기법들이 소프트웨어적으로 고려되고 있다.</p>\n<p>CPU가 명령어를 실행하는 작업은 크게 (Fetch, Decode, Execute, Write)의 4개의 순서대로 별도의 위치에서 이루어진다. 이때, 한 코어에서 작업을 나누어 병렬로 처리하는 <code class=\"language-text\">Pipeline</code>기법이라고 하고, 여러 코어에서 동시에 작업을 수행하는 것을 <code class=\"language-text\">Super-scalar</code>기법이라고 한다.</p>\n<h1 id=\"memory\" style=\"position:relative;\"><a href=\"#memory\" aria-label=\"memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory</h1>\n<blockquote>\n<p>저장 장치</p>\n</blockquote>\n<p>폰노이만 구조에서, CPU는 명령어를 메모리에서부터 가져와서 실행한다. 메모리는 프로그램과 데이터를 저장하는 공간으로, R/W가 모두 가능한 RAM과 Read Only Memory인 ROM으로 구분된다.</p>\n<ul>\n<li>\n<p>RAM (Random Access Memory)</p>\n<p>주소를 통하여 메모리 공간에 접근하므로, 모든 공간에의 접근 시간이 동일하다. 램은 전력이 끊겼을 때 데이터가 지워지냐 여부에 따라, 휘발성과 비휘발성으로 나뉜다.</p>\n<ul>\n<li>\n<p>휘발성</p>\n<p>DRAM(일정 시간이 지나면 데이터가 사라져 주기적 재생 필요. 보통 우리가 <strong>주기억장치로 사용</strong>함. 시금치 램 같은 것들), SRAM(빠르고 안정적이지만 비싸서 <strong>캐시, 레지스터</strong> 등에 사용됨)</p>\n</li>\n<li>\n<p>비휘발성</p>\n<p>전원이 해제되어도 데이터가 사라지지 않지만, 속도가 느리고 비용이 비싸다. flash memory는 usb처럼 주변 장치로 사용되기도 하지만, 어느정도 사용횟수가 제한되어 있다. HDD와 SSD는 보조 기억장치로 많이 활용 된다. <u>보조 기억장치에는 OS를 포함한 프로그램, 각종 파일들을 저장</u>할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ROM (Read Only Memory)</p>\n<p>데이터를 보관할 수 있지만, 한번 저장하면 바꿀 수 없다. (CD-ROM 이라고 하는 이유!) 하지만 전력과 무관하게 데이터가 저장되므로, 메인보드의 BIOS(부팅시 초기화를 담당하는 프로그램) 등이 ROM으로 저장되어 있다. ROM은 보통 제조 과정에서 프로그래밍되어 고정되지만, 지우거나 쓸 수 있는 EPROM등도 존재하긴 하지만 많이 쓰이진 않는다.</p>\n</li>\n</ul>\n<h2 id=\"저장장치-계층-구조\" style=\"position:relative;\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"저장장치 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>저장장치 계층 구조</h2>\n<p>돈이 많다면 모든 저장장치를 속도가 빠른 캐시 메모리나 레지스터로 구성하겠지만, 현실적으로 불가능하다. 이에 컴퓨터는 보통 속도와 용량의 trade-off에 따라 적절하게 계층구조를 두고 구성되어 있다.</p>\n<ul>\n<li>register</li>\n<li>cache</li>\n<li>memory</li>\n<li>ssd/hdd</li>\n</ul>\n<p>계층을 두고 데이터를 관리하면 데이터가 중복되어 저장될텐데, <strong>일관성을 유지하는 것이 핵심</strong> 이라고 볼 수 있다. 따라서, 각 계층 간 데이터 이동에는 전략이 있으므로 참고한다. 보통 memory와 보조기억장치 간의 이동을 제외하고는 개발자가 관여할 수 없을 것이다.</p>\n<h2 id=\"부팅\" style=\"position:relative;\"><a href=\"#%EB%B6%80%ED%8C%85\" aria-label=\"부팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부팅</h2>\n<p>application은 운영체제에 의하여 메모리에 적재되어 실행된다. 운영체제도 프로그램인데, 어떻게 메모리에 올라갈까? 이는 <code class=\"language-text\">부팅</code>의 과정과 관련있다. 컴퓨터의 전원을 켜면 BIOS-ROM에 저장된 BIOS(Basic I/O System)프로그램이 실행된다.</p>\n<p>바이오스는 하드웨어를 점검하고(POST라고 함), 이상이 없다면 미리 설정된 부팅 순서에 따라 부트 장치(flash memory, HDD, SSD 등)를 선택한다.</p>\n<p>해당 부팅 장치에서 MBR(Master Boot Record) 또는 UEFI(Unified Extensible Firmware Interface) 로더가 로드된다. 이를 통하여 부팅 가능한 부트로더의 위치를 찾아서 실행된다.</p>\n<p>부트로더는 운영체제의 위치를 찾아 초기화하여 메모리에 올려서 실행되게 된다! 부팅 끝</p>","frontmatter":{"date":"June 27, 2023","title":"(OS) 운영체제 복습 [1. 컴퓨터 구조 skim]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(1)-computer-architecture/"}},"prev":{"id":"2c803dde-8b03-5489-ae45-f640fcdf8b24","html":"<p>OS는 <code class=\"language-text\">system call</code>이라는 함수들로 Process를 생성/제어할 수 있는 API(Application Programming Interface)를 제공한다. 시스템 콜을 통하여 우리는 하드웨어에 대한 권한을 일부 부여받을 수 있게 된다.</p>\n<h2 id=\"system-call\" style=\"position:relative;\"><a href=\"#system-call\" aria-label=\"system call permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>System call</h2>\n<ul>\n<li>OS에서 <code class=\"language-text\">kernel mode</code>에 들어왔을 때 사용할 수 있는 함수. 즉, system call은 일반 함수와 다른 높은 권한을 갖는 함수라고 볼 수 있다.</li>\n<li>H/W에 직접 접근하는 등의 민감한 작업들은 오직 <code class=\"language-text\">privilege level</code>에서만 가능하므로 system call을 사용해야 한다.</li>\n<li>IO 작업과 같은<code class=\"language-text\">blocking</code>해주는 system call들은 process를 blocked상태로 descheduled 시키게 될 것이다. 즉, 하드웨어의 동작에 긴밀하게 연관되어 있다고 볼 수 있다.</li>\n</ul>\n<h3 id=\"should-we-rewrite-programs-for-each-os\" style=\"position:relative;\"><a href=\"#should-we-rewrite-programs-for-each-os\" aria-label=\"should we rewrite programs for each os permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Should we rewrite programs for each OS?</h3>\n<p>시스템 콜은 운영체제마다 조금씩 다르다. 하지만, 거의 모든 현대의 운영체제는 <code class=\"language-text\">POSIX API</code>라는 <strong>시스템 콜의 표준이 존재하므로, OS마다 다른 프로그램을 작성할 필요는 없을 것</strong>이다.</p>\n<p>또한, 시스템 개발자를 제외한 대부분의 application 개발자들은 programming langauge 안에서 개발하게 되는데, 이 경우에 내부적으로 각 언어별로 system call들을 추상화하여 제공하므로 대부분의 상황에서는 system call을 직접 사용할 일이 없다.</p>\n<p>예를 들어, C언어의 <code class=\"language-text\">printf</code> 역시 STDOUT이라는 특정 file을 열어서 I/O를 수행하는 것이므로 <code class=\"language-text\">write</code>이라는 system call을 호출될 것이지만 <strong>C언어 내부적으로 시스템 콜을 호출하도록 구현되어 있으므로 시스템 콜을 직접 다루는 일은 많지 않을 것</strong>이다.</p>\n<h2 id=\"process-related-system-calls\" style=\"position:relative;\"><a href=\"#process-related-system-calls\" aria-label=\"process related system calls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process related system calls</h2>\n<p>unix 계열에서 사용하는 프로세스의 생성과 관리와 관련된 system call들을 알아보자.</p>\n<h3 id=\"fork\" style=\"position:relative;\"><a href=\"#fork\" aria-label=\"fork permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fork()</h3>\n<p>새로운 child process를 생성하는 시스템 함수이다. 프로세스와 관련된 가장 중요한 시스템 함수이다.</p>\n<ul>\n<li><strong>모든 프로세스는 parent에서 fork되어 생성된다</strong>.</li>\n<li>fork()의 리턴값에 따라 부모 프로세스와 자식 프로세스를 구분할 수 있다. (자식 : 0, 부모 : 자식 프로세스의 PID)</li>\n<li>운영체제는 시작될 때, init process를 만들고, 이는 모든 프로세스의 조상(ancestor)프로세스이다.</li>\n</ul>\n<p><code class=\"language-text\">fork</code> 함수가 불리면, <strong>부모 프로세스의 memory image를 복사하여 새로운 프로세스(부모와 다른 PID할당)가 생성</strong>된다. 또한, 새로 생성된 PCB는 OS의 process list에 append될 것이다. 이때 <u>자식 프로세스의 메모리 이미지는 부모와 같으므로 <code class=\"language-text\">fork()</code> 이후부터 각자 독립적으로 실행될 것</u>이다.</p>\n<p>보통, fork()의 리턴값으로 부모와 자식을 구분하여 독립적인 프로세스가 분기적으로 실행할 수 있도록 구현한다. 예시를 보자!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJElEQVQoz5WSaY+CQAyG+f8/kQ+inHKDoFxCzdOkhHXXmG3STOd6j8440zRJXdeaXddJ0zQ6Pp9PIbZt07T6Wzht24rv++J5nsRxrDV5v9/3Qwb6KY9kjqma51mWZdGkRqHltzgqV8CiKOR2uwlqGfu+17GqKm2FEazruqcJ+KXw8Xjo5Hq9Sp7nUpalWgeIPcCpIRjHUfeNCDGAHtvicIFiGAZJ01SyLNMEACWAopw1I6NF75Z3QFgILIVhKEmS6EUuQQYRI21hHRem6s9XPirENlbs62ARhaxBdjqdxHVdVYmbKIrkcrloMofoh0JU2MNYD81mEAQKwBmIz+ezgrAPBsJokQKikA9O2uvxDwFkn0uQsE9w8aNl7HHAWAD8T7x/8hcMtFXtoYUvXAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fork\"\n        title=\"fork\"\n        src=\"/static/68b0984ed9791d57b606c73fb56256ab/37523/fork.png\"\n        srcset=\"/static/68b0984ed9791d57b606c73fb56256ab/e9ff0/fork.png 180w,\n/static/68b0984ed9791d57b606c73fb56256ab/f21e7/fork.png 360w,\n/static/68b0984ed9791d57b606c73fb56256ab/37523/fork.png 720w,\n/static/68b0984ed9791d57b606c73fb56256ab/302a4/fork.png 1080w,\n/static/68b0984ed9791d57b606c73fb56256ab/07a9c/fork.png 1440w,\n/static/68b0984ed9791d57b606c73fb56256ab/536c7/fork.png 1480w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 코드를 실행하면 다음과 같은 상황이 벌어질 것이다. 동그라미친 번호는 위 코드의 line을 의미한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVQoz53RWy/DQRQE8B+CqFvTuqfirih1pwmCEG8SiWff/2vIyrT5p4kH5uVk95ydmTPL7xhJfcZJ5X4ME6hh1D+whQds5tzELq4xPWRgIDCHRuoCFlFPbwl3IWjhFj1c4iViO/jCR59wH+8ZfMUbuiGdiVgR2cAV2tiL00762xH/wQrW8mg+RPXKOmW1yco2tQhNYXY4o08c4R6rUT9Ndr3MFILluDhL/zhRlA9bx2N//jBEN7F8ENJG3FYDbyXLTgi7qeXDzvPuz7jAUyIaTwQDfAP01g598L+mFgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fork_visulize\"\n        title=\"fork_visulize\"\n        src=\"/static/c395d74898e2a9cb1515022b727d07cb/37523/fork_visulize.png\"\n        srcset=\"/static/c395d74898e2a9cb1515022b727d07cb/e9ff0/fork_visulize.png 180w,\n/static/c395d74898e2a9cb1515022b727d07cb/f21e7/fork_visulize.png 360w,\n/static/c395d74898e2a9cb1515022b727d07cb/37523/fork_visulize.png 720w,\n/static/c395d74898e2a9cb1515022b727d07cb/302a4/fork_visulize.png 1080w,\n/static/c395d74898e2a9cb1515022b727d07cb/07a9c/fork_visulize.png 1440w,\n/static/c395d74898e2a9cb1515022b727d07cb/dd13c/fork_visulize.png 2572w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>fork의 리턴 값을 이용하여 부모/자식 프로세스의 실행 분기를 결정할 수 있다. 하지만 자식 프로세스 역시 생성 이후에 OS의 process list에 들어가 <strong>scheduling되므로, 두 프로세스의 실행 순서는 알 수 없다</strong>. 따라서 실행 순서를 보장하고 싶을 경우에 사용할 수 있는 시스템 함수가 있는데…</p>\n<h3 id=\"wait\" style=\"position:relative;\"><a href=\"#wait\" aria-label=\"wait permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>wait()</h3>\n<p>부모 프로세스에서 자식 프로세스가 종료될 때까지 기다리도록 하는 시스템 함수이다. 프로세스는 명시적으로 <code class=\"language-text\">exit()</code>을 통하여 종료하거나, 메인 함수가 종료시 암묵적으로 exit() 시스템 함수가 실행된다. 하지만, exit()가 실행된다고 해서 process list에서 없어지는 것은 아니고 zombie process로 남게 된다. 따라서, <code class=\"language-text\">wait()</code> 시스템콜을 통하여 exit된 child process를 정리해주는 작업을 수행한다. (wait을 통하여 cleanup을 부모 프로세스가 해줘야 함)</p>\n<h4 id=\"부모-프로세스가-먼저-종료된다면\" style=\"position:relative;\"><a href=\"#%EB%B6%80%EB%AA%A8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%A8%BC%EC%A0%80-%EC%A2%85%EB%A3%8C%EB%90%9C%EB%8B%A4%EB%A9%B4\" aria-label=\"부모 프로세스가 먼저 종료된다면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부모 프로세스가 먼저 종료된다면?</h4>\n<p>위의 경우에서 부모인 100번 프로세스가 먼저 종료된다면 어떻게 될까? 위에서 언급했다시피 모든 프로세스의 조상은 <code class=\"language-text\">init</code> process이고, <strong>init 프로세스가 고아가 된 child process를 정리</strong>해줄 것이다.</p>\n<p>그렇다면 wait은 왜 필요한가? 자식이 종료될때까지 기다리므로 <strong>실행 순서를 보장</strong>해주게 된다. 또한, zombie process는 언젠가 없어지겠지만 남아있다면 메모리 낭비가 되므로 제때 치워주는 것이 좋다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJUlEQVQoz4WSiY6DMAxE8///iCj3TbmPFnD1LKUCabtYsmIcezzjYLqukyAIxPd9ieNY4yiKZBgGwY7jULfxnRkAwzBUkKIoJE1T/X4+n7Lv+wX0l5+HKWCSJNK2rYzjKH3f63n2O2bnezNNkyzLohIBYwAxQMQM4puabdvk/X7L6/X61hBfGAKCwTLPc5WK5LIsFWSeZwUmb9Wwmr8AcVPXtSbYF/vjUWgAAEAUAEQOMGrI/3wUGrF1XfWVLYOmab5SObMsU+ae5yl7CHBHH0NRwkougEyHMWsA0O4U5w4w13V1NY/HQ9VwOo6jw6gzLN0aYFYuTVVVKTPy1NFgmXOyQ2q5g+Flh/b1cGLYIYVmapBpgW3Nucf+s4ZCjEL8v4XfGQw/nPFTArvKxIgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wait\"\n        title=\"wait\"\n        src=\"/static/b86435c25fe63f7ed7d10281291baa22/37523/wait.png\"\n        srcset=\"/static/b86435c25fe63f7ed7d10281291baa22/e9ff0/wait.png 180w,\n/static/b86435c25fe63f7ed7d10281291baa22/f21e7/wait.png 360w,\n/static/b86435c25fe63f7ed7d10281291baa22/37523/wait.png 720w,\n/static/b86435c25fe63f7ed7d10281291baa22/302a4/wait.png 1080w,\n/static/b86435c25fe63f7ed7d10281291baa22/c65fa/wait.png 1434w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 코드에서, 부모 프로세스는 16번째줄에서 자식이 종료될 때까지 기다리게 된다. 이후, 자식이 종료되면 wait에서 리턴을 받아 실행되고, 부모 프로세스 역시 종료될 것이다. 결과는 아래와 같이 <strong>두 프로세스 간의 실행 순서가 보장될 것</strong>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">hello world<span class=\"token punctuation\">(</span>pid:29266<span class=\"token punctuation\">)</span> \nhello, I am child <span class=\"token punctuation\">(</span>pid:29267<span class=\"token punctuation\">)</span> \nhello, I am parent of <span class=\"token number\">29267</span> <span class=\"token punctuation\">(</span>wc:29267<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>pid:29266<span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"exec\" style=\"position:relative;\"><a href=\"#exec\" aria-label=\"exec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>exec()</h3>\n<p>fork된 프로세스를 <strong>다르게 실행하기 위하여 사용</strong>하는 시스템 함수이다. fork된 코드를 항상 분기에 따라서 나눈다면 프로세스 구조가 복잡해질 수록 관리가 어려울 것이다. 따라서, 기존 실행되던 환경을 손쉽게 가져오되 전혀 다른 내용을 수행할 수 있도록 하기 위해 <code class=\"language-text\">exec()</code>함수가 필요하다. exec 함수를 통하여 자식은 새로운 메모리 이미지를 갖고 수행된다.</p>\n<h4 id=\"why-exec\" style=\"position:relative;\"><a href=\"#why-exec\" aria-label=\"why exec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>why exec()?</h4>\n<p>fork()만으로는 관리가 어렵다는 것을 깨달았을 것이다. 그치만, fork()이후에 굳이 exec()으로 프로세스를 실행하는 이유는, 프로세스의 계층 구조를 만들어 서 자식 프로세스의 종료 이후 memory cleanup 등에 있어 용이하여 관리가 편하기 때문이다. 또한, <strong>fork를 통하여 Process를 단순하게 복사하므로 새로 만드는 것보다 비용이 저렴</strong>하다. (fork는 프로세스를 로드하고 초기화하여 실행하는 것보다 훨씬 빠르다)</p>\n<p>exec() 함수는 수행되는 방법에 따라 다양한 함수가 제공되며 인자도 다양하니, 궁금하면 <a href=\"https://man7.org/linux/man-pages/man3/exec.3.html\">찾아보도록</a> 하자.</p>\n<h3 id=\"exit\" style=\"position:relative;\"><a href=\"#exit\" aria-label=\"exit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>exit()</h3>\n<p>프로세스를 종료하기 위한 시스템 함수이다. 보통 메인 함수가 끝나면 암묵적으로 수행되며, 인자에 따라서 종료 상태 여부를 결정할 수 있다.</p>\n<h2 id=\"how-does-a-shell-work\" style=\"position:relative;\"><a href=\"#how-does-a-shell-work\" aria-label=\"how does a shell work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How does a shell work?</h2>\n<p>system calls를 이해했다면, 우리가 자주 사용하는 shell(terminal, bash, zshrc …)프로그램이 어떤 원리로 돌아가는지 알아볼 수 있다.</p>\n<ol>\n<li>OS는 시작시 init 프로세스를 만든다.</li>\n<li>init 프로세스는 <code class=\"language-text\">bash</code>와 같은 shell 프로세스를 만든다.</li>\n<li>shell process는 명령어를 입력받는다.</li>\n<li>입력받은 명령어를 실행하기 위해 **fork()**를 하고, 해당 명령어의 코드를 **exec()**한다. 그 동안, 부모 프로세스인 shell은 자식 프로세스가 종료될 때까지 <strong>wait</strong>한다.</li>\n<li>자식 프로세스의 종료 상태에 따라 상태를 출력하고, 다음 입력을 받는다.</li>\n</ol>\n<p><code class=\"language-text\">ls</code> 명령어를 입력받는다고 해보자. shell은 child process를 fork하고, ls 프로그램을 exec한다. ls가 종료될때까지 shell은 기다리고, 수행이 완료되면 ls는 종료되고 부모인 shell은 다시 입력을 받게 될 것이다.</p>\n<p><code class=\"language-text\">ls > output.txt</code>와 같은 pipelining의 경우에는 <code class=\"language-text\">ls</code>를 수행하기 전, <code class=\"language-text\">STDOUT</code>을 사용자의 화면이 아닌 output.txt로 바꿔준 이후에 exec을 수행하도록 할 것이다. 이와 같이 shell에는 많은 system call들이 내부적으로 구현되어 있다.</p>\n<blockquote>\n<p>와 재밌다!</p>\n</blockquote>\n<p>시스템 콜은 OS를 통하여 H/W에 좀 더 직접적으로 접근할 수 있게 해주고, 그 결과 프로세스를 어느정도 제어할 수 있다. 하지만, 모든 프로세스가 시스템 콜을 남발하여 CPU를 독점하도록 하면 안될 것이다.</p>\n<p>위의 지적을 생각해보면서 다음에는 OS가 프로세스를 실행하는 구체적인 과정과, system call이 수행될 때의 과정을 좀 더 자세히 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"July 15, 2023","title":"(OS) 운영체제 복습 [3. Process API]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(3)- Process API/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(2)-Process/","nextSlug":"/OS(1)-computer-architecture/","prevSlug":"/OS(3)- Process API/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}