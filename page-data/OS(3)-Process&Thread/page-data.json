{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(3)-Process&Thread/",
    "result": {"data":{"cur":{"id":"a8425bb2-6f5d-5eac-bccb-ceb12e551d10","html":"<h1 id=\"process\" style=\"position:relative;\"><a href=\"#process\" aria-label=\"process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process</h1>\n<p>Process는 <strong>실행중인 프로그램</strong>(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 <code class=\"language-text\">CPU virtualization</code>을 만들어, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다.</p>\n<p>짧은 시간으로 나누어 여러 Process를 수행하도록 하는 방법을 <code class=\"language-text\">time sharing</code>이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 <code class=\"language-text\">context switching</code>부터, 고수준의 scheduling과 같은 <code class=\"language-text\">policy</code>까지 갖고 있다.</p>","excerpt":"Process Process는 실행중인 프로그램(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 을 만들어, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다. 짧은 시간으로 나누어 여러 Process를 수행하도록 하는 방법을 이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 부터, 고수준의 scheduling과 같은 까지 갖고 있다.","frontmatter":{"date":"June 28, 2023","title":"(OS) 운영체제 복습 [3. Process & Thread]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(3)-Process&Thread/"}},"next":{"id":"328e4644-a010-5a01-a36b-43fec5db2009","html":"<p>운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자!</p>\n<h1 id=\"von-neumann-architecture\" style=\"position:relative;\"><a href=\"#von-neumann-architecture\" aria-label=\"von neumann architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Von Neumann Architecture</h1>\n<blockquote>\n<p>폰 노이만 구조</p>\n</blockquote>\n<p>컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 <code class=\"language-text\">CPU</code>로부터 <strong>fetch, decode, execute, writeback의 과정</strong>을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 <code class=\"language-text\">Memory</code>에 올라가(load)있어야하며, CPU는 <code class=\"language-text\">Program Counter</code> 레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다.</p>\n<p>이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 <code class=\"language-text\">폰 노이만 구조</code>라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 <u>실행하기 위해서는 메모리에 로드가 되어야 한다</u>는 것을 알 필요가 있다.</p>\n<h1 id=\"cpu\" style=\"position:relative;\"><a href=\"#cpu\" aria-label=\"cpu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU</h1>\n<blockquote>\n<p>Central Processing Unit</p>\n<p>중앙 처리 장치</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACoUlEQVQoz23R3U+SURzAcf+XbrvoplqrddPa2tq66rqbttYqc26WaFipmb1oolZSusTAlwaai3gVQYOHF8FHEQRFBeRlLITx9gDPyznnVwirizoXv6vzOd+zc5rgn0UIAQAkIPUEpeg3Tb80GafdOplTNbwq69Fv2fcBAOPanqb/4drkOD4cSCT3M/G9dCZVCLhijm87yXA2Hk39CTQwOT4JY0KAABwPILHDhHZ+eUVrLzPlZCjbfGaMWtgGguqygXmBLzHFYqFUZAr5XL6QK+ZzBQBsnqObT0vvnnrvNG1HcbT72szAbaUXNtIkDceFGmbZajyU3nUlY3s/g2uH27ZY2J8kgKwL3geXJkQXJzXWVarqbD//eeSeOgB+B3bWrgm4hkuF0v1zY7dOvu26Iu+8PHXjhOTpdTkAsqi8bRcmO87KdU47FfX0XZ06cO4c8Rma0EAA18u8gFWjVpn4u0xikA8YPokWdVOUAORoP2Z2m0y2H8GI2w9JEnZAPhivZmnY/FsGvgDFBAQ8FtD4cnpY1xIuIGAMEdqWk2qS0gO3coP3InqO8WlSxQhdWYIKg+sPhhIG1v6CU7/Wptod9EO02MdGvvApK4S+2iOdevpO1Cz2J16BV4r9H7IH42u7rRBdInWMPZu8Qsl/lBu8I279IEhnkGsd+fxA+VxrE0v6rtjMu4BzFnR2rLdmVnTrRgk4thrlkovKqmaZZZPS/cTsGGK1hqLNwgS3BLt7mRpY8PSEVhRu6xirNTA6TcKiMhofcw5X458VoGoBcT+MtoCoA3p6QdILg/OgHobxVhC3QdcjeC6C7j4Y7oU3z2DoJrTIQdXAZVwqCQUWVXjEcYitIKaKygLmWVTlEStgjkNVDlVZVGZRmUPVCmLKuPQb/wJXool93Z1D2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cpu_architecture\"\n        title=\"cpu_architecture\"\n        src=\"/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png\"\n        srcset=\"/static/c9124f66758e84c155c133f783a2c728/e9ff0/cpu_architecture.png 180w,\n/static/c9124f66758e84c155c133f783a2c728/f21e7/cpu_architecture.png 360w,\n/static/c9124f66758e84c155c133f783a2c728/37523/cpu_architecture.png 720w,\n/static/c9124f66758e84c155c133f783a2c728/7527b/cpu_architecture.png 754w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>CPU는 명령어를 해석하고 실행하는 장치이며, 이를 수행하기 위해 많은 Unit들이 존재한다. 주요 구성은 다음과 같다.</p>\n<ul>\n<li>\n<p>Control Unit</p>\n<p>decoder를 통해 binary코드의 명령어를 해석하고, 이에 적절한 제어 신호(메모리에서 레지스터로 가져오기, 연산, 쓰기)를 발생시킨다. 또한, 명령어의 실행 순서를 결정한다.</p>\n</li>\n<li>\n<p>Arithmetic &#x26; Logic Unit(ALU)</p>\n<p>연산 명령에 대하여 연산을 수행한다. 모든 연산은 atomic하며, 산술연산(ex 덧셈)과 논리연산(ex AND)으로 구분되어 수행된다.</p>\n</li>\n<li>\n<p>Register</p>\n<p>CPU가 갖는 <u>임시 저장소</u>. 연산을 수행하거나, 명령어를 fetch하는 것들이 각각의 레지스터에서 일어난다. 다음 명령어의 위치를 가리키고 있는 <code class=\"language-text\">Program Counter</code>(PC), 데이터를 보관하기 위한 <code class=\"language-text\">Data Register</code>와 주소를 저장하기 위한 <code class=\"language-text\">Address Register</code>, 실행 중인 명령어를 가져오는 <code class=\"language-text\">Instruction Register</code>, 메모리에 저장하거나 가져올 때 사용하는 <code class=\"language-text\">Memory Address Register</code>, <code class=\"language-text\">Memory Buffer Register</code> 등이 있다.</p>\n</li>\n</ul>\n<p>CPU가 다른 기기들과 주고 받는 정보는 크게 3가지로 나눌 수 있다.</p>\n<ul>\n<li>Control</li>\n<li>Address</li>\n<li>Data</li>\n</ul>\n<p>따라서 이는 위의 그림처럼 각각의 역할을 수행하는 버스를 통하여 주변 장치와 연결을 한다.</p>\n<p>CPU는 한번에 처리할 수 있는 데이터의 크기에 따라 오늘날 32bit, 64bit 컴퓨터로 나뉜다. 32비트 주소 체계는 2^32개의 주소를 담을 수 있다. 메모리는 한 주소당 1Byte를 갖으므로 2^32Byte = 4GB 정도의 데이터를 가리킬 수 있는 것이다. 따라서 32비트 컴퓨터는 최근에 사용되지 않는다.</p>\n<h2 id=\"interrupt\" style=\"position:relative;\"><a href=\"#interrupt\" aria-label=\"interrupt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt</h2>\n<p>CPU는 매우 빠르다.! 하지만, 주변 장치의 증가로 매우 느린 I/O 작업이 늘어나게 되면서 기존의 polling 방식은 성능이 낮아졌다. 이는 CPU가 IO device의 상태를 주기적으로 검사하여 데이터를 처리하는 방식으로, CPU의 본래 역할(fetch, decode, execute)에 I/O까지 수행하게 되어 매우 느리다. I/O가 수행될때까지 기다려야하기 때문이다.</p>\n<p>Interrupt 방식은 IO작업을  CPU가 기다리지 않고 다른 곳(입출력 관리자)에 위임하고, 완료되면 Interrupt 신호를 발생시키는 것이다. CPU는 I/O가 수행되는 동안 다른 작업들을 수행하면 되고, interrupt가 발생하면 지금 하던 작업을 멈추고 가져와진 데이터로 작업을 이어가면 된다.</p>\n<h3 id=\"direct-memory-accessdma\" style=\"position:relative;\"><a href=\"#direct-memory-accessdma\" aria-label=\"direct memory accessdma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Direct Memory Access(DMA)</h3>\n<p>기본적으로 Memory에 대한 접근 권한은 CPU만 갖고 있다. 따라서 장치들이 interrupt를 발생시켜 CPU가 메모리에 작업을 하도록 전송할 것이지만, 이것은 느리다. 따라서 I/O 수행시 <strong>장치들이 직접 메모리에 접근할 수 있다면 CPU를 더 효율적으로 사용할 수 있을 것</strong>이다. <code class=\"language-text\">DMA Controller</code>에게 CPU가 메모리에 대한 정보를 제공하고, 입출력 장치와 메모리 간의 직접적인 연결을 수행할 수 있도록 한다.</p>\n<p>DMA를 통해 메모리를 관리한다면, 메모리 구조가 복잡해질 수 있다.(CPU가 사용하는 영역과 입출력 장치가 사용하는 영역들의 혼재) 따라서 메모리를 OS 영역, CPU 영역, 입출력 작업 영역 등으로 분리하여 관리하는 방법을 <code class=\"language-text\">MMIO</code> (Memory Mapped I/O) 기법이라고 한다.</p>\n<p>DMA를 통해 메모리에 접근하면 여러 장치들(CPU 포함)이 동시에 메모리에 접근하려는 순간이 생긴다. 이때, CPU의 작업속도가 훨씬 빠르므로 CPU가 메모리 접근 순서를 양보하는데, 이를 <code class=\"language-text\">cycle stealing</code> 이라고 한다.</p>\n<h2 id=\"parallel-processing\" style=\"position:relative;\"><a href=\"#parallel-processing\" aria-label=\"parallel processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Processing</h2>\n<p>CPU의 성능을 향상시키기 위해 CPU의 클럭을 높이거나, 캐시의 크기를 늘리는 방법이 가장 대표적이다. 하지만, 클럭을 높이면 저항이 많아져 발열이 증가하게 되므로 이러한 하드웨어적인 향상에는 비용등의 현실적인 제약이 있다. 따라서, <strong>CPU 코어를 여러개 두어 병렬적으로 처리</strong>하는 기법들이 소프트웨어적으로 고려되고 있다.</p>\n<p>CPU가 명령어를 실행하는 작업은 크게 (Fetch, Decode, Execute, Write)의 4개의 순서대로 별도의 위치에서 이루어진다. 이때, 한 코어에서 작업을 나누어 병렬로 처리하는 <code class=\"language-text\">Pipeline</code>기법이라고 하고, 여러 코어에서 동시에 작업을 수행하는 것을 <code class=\"language-text\">Super-scalar</code>기법이라고 한다.</p>\n<h1 id=\"memory\" style=\"position:relative;\"><a href=\"#memory\" aria-label=\"memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory</h1>\n<blockquote>\n<p>저장 장치</p>\n</blockquote>\n<p>폰노이만 구조에서, CPU는 명령어를 메모리에서부터 가져와서 실행한다. 메모리는 프로그램과 데이터를 저장하는 공간으로, R/W가 모두 가능한 RAM과 Read Only Memory인 ROM으로 구분된다.</p>\n<ul>\n<li>\n<p>RAM (Random Access Memory)</p>\n<p>주소를 통하여 메모리 공간에 접근하므로, 모든 공간에의 접근 시간이 동일하다. 램은 전력이 끊겼을 때 데이터가 지워지냐 여부에 따라, 휘발성과 비휘발성으로 나뉜다.</p>\n<ul>\n<li>\n<p>휘발성</p>\n<p>DRAM(일정 시간이 지나면 데이터가 사라져 주기적 재생 필요. 보통 우리가 <strong>주기억장치로 사용</strong>함. 시금치 램 같은 것들), SRAM(빠르고 안정적이지만 비싸서 <strong>캐시, 레지스터</strong> 등에 사용됨)</p>\n</li>\n<li>\n<p>비휘발성</p>\n<p>전원이 해제되어도 데이터가 사라지지 않지만, 속도가 느리고 비용이 비싸다. flash memory는 usb처럼 주변 장치로 사용되기도 하지만, 어느정도 사용횟수가 제한되어 있다. HDD와 SSD는 보조 기억장치로 많이 활용 된다. <u>보조 기억장치에는 OS를 포함한 프로그램, 각종 파일들을 저장</u>할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ROM (Read Only Memory)</p>\n<p>데이터를 보관할 수 있지만, 한번 저장하면 바꿀 수 없다. (CD-ROM 이라고 하는 이유!) 하지만 전력과 무관하게 데이터가 저장되므로, 메인보드의 BIOS(부팅시 초기화를 담당하는 프로그램) 등이 ROM으로 저장되어 있다. ROM은 보통 제조 과정에서 프로그래밍되어 고정되지만, 지우거나 쓸 수 있는 EPROM등도 존재하긴 하지만 많이 쓰이진 않는다.</p>\n</li>\n</ul>\n<h2 id=\"저장장치-계층-구조\" style=\"position:relative;\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"저장장치 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>저장장치 계층 구조</h2>\n<p>돈이 많다면 모든 저장장치를 속도가 빠른 캐시 메모리나 레지스터로 구성하겠지만, 현실적으로 불가능하다. 이에 컴퓨터는 보통 속도와 용량의 trade-off에 따라 적절하게 계층구조를 두고 구성되어 있다.</p>\n<ul>\n<li>register</li>\n<li>cache</li>\n<li>memory</li>\n<li>ssd/hdd</li>\n</ul>\n<p>계층을 두고 데이터를 관리하면 데이터가 중복되어 저장될텐데, <strong>일관성을 유지하는 것이 핵심</strong> 이라고 볼 수 있다. 따라서, 각 계층 간 데이터 이동에는 전략이 있으므로 참고한다. 보통 memory와 보조기억장치 간의 이동을 제외하고는 개발자가 관여할 수 없을 것이다.</p>\n<h2 id=\"부팅\" style=\"position:relative;\"><a href=\"#%EB%B6%80%ED%8C%85\" aria-label=\"부팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부팅</h2>\n<p>application은 운영체제에 의하여 메모리에 적재되어 실행된다. 운영체제도 프로그램인데, 어떻게 메모리에 올라갈까? 이는 <code class=\"language-text\">부팅</code>의 과정과 관련있다. 컴퓨터의 전원을 켜면 BIOS-ROM에 저장된 BIOS(Basic I/O System)프로그램이 실행된다.</p>\n<p>바이오스는 하드웨어를 점검하고(POST라고 함), 이상이 없다면 미리 설정된 부팅 순서에 따라 부트 장치(flash memory, HDD, SSD 등)를 선택한다.</p>\n<p>해당 부팅 장치에서 MBR(Master Boot Record) 또는 UEFI(Unified Extensible Firmware Interface) 로더가 로드된다. 이를 통하여 부팅 가능한 부트로더의 위치를 찾아서 실행된다.</p>\n<p>부트로더는 운영체제의 위치를 찾아 초기화하여 메모리에 올려서 실행되게 된다! 부팅 끝</p>","frontmatter":{"date":"June 27, 2023","title":"(OS) 운영체제 복습 [2. 컴퓨터 구조 skim]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(2)-computer-architecture/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(3)-Process&Thread/","nextSlug":"/OS(2)-computer-architecture/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}