{"componentChunkName":"component---src-templates-blog-template-js","path":"/Alg-LC-3/","result":{"data":{"cur":{"id":"833b0fc7-e393-5ac3-900a-23654561e0b4","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. <a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\">링크</a></p>\n<p>나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다.</p>\n<ul>\n<li>bbbbb -> b</li>\n<li>abcabcbb -> abc or bca or cab</li>\n<li>pwwkew -> wke or kew</li>\n<li>dvdf -> vdf</li>\n</ul>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ol>\n<li>\n<p>Brute Force</p>\n<p>단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다.</p>\n<p>s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, <u>substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다</u></p>\n</li>\n<li>\n<p>Set 이용하여 개선</p>\n<p>처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 <code class=\"language-text\">O(len(substr))</code>만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어서 <code class=\"language-text\">O(1)</code>에 처리가 가능하기 때문이다. (하지만, 해당문자까지 제거하는 과정은 최악의 경우 substr만큼 소요될 것이다)</p>\n</li>\n</ol>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n?)</p>\n<p>1번 방법은 n회의 루프동안 substr의 크기만큼 탐색해야하므로 <code class=\"language-text\">O(n^2)</code>만큼 소요된다.</p>\n<p>2번 방법은 탐색하는 시간이 줄어들지만, 중복이 있을 때 제거하는 remove 연산의 수행횟수에 따라 O(n)에 근사한 속도가 나올 것이다. set의 remove는 평균적으로 O(1)에 가능하지만 (드물지만 최악의 경우) O(n)까지도 될 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>set의 크기는 substr에 비례하므로 최대 O(n)의 공간 복잡도를 갖는다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        substr <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n        longestLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> end <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># check repeat</span>\n            <span class=\"token comment\"># print(substr, s[end])</span>\n            ind <span class=\"token operator\">=</span> substr<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> ind <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                longestLen <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                substr <span class=\"token operator\">=</span> substr<span class=\"token punctuation\">[</span>ind<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\">#print('after:',substr)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                substr <span class=\"token operator\">+=</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        substr_set <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        strt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        longestLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> end <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(strt,end,s[strt],s[end], substr_set)</span>\n            <span class=\"token keyword\">while</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span> <span class=\"token keyword\">in</span> substr_set<span class=\"token punctuation\">:</span>\n                substr_set<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>strt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                strt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            substr_set<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            longestLen <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr_set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> longestLen</code></pre></div>\n<p>속도는 1번이 64ms, 2번 방법이 57ms로 더 빠르지만 메모리는 0.2MB 더 많이 사용하는 것을 확인할 수 있다.</p>\n<p>여러 값 중 어떠한 값이 있는지 확인하는 방법을 선형 탐색과 해시 테이블로 했을 때의 차이라고 보면 될 것이다.</p>","excerpt":"Intuition 문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. 링크 나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다. bbbbb -> b abcabcbb -> abc or bca or cab pwwkew -> wke or kew dvdf -> vdf Approach Brute Force 단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다. s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다 Set 이용하여 개선 처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어…","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 3. Longest Substring Without Repeating Characters","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-3/"}},"next":{"id":"b207f215-d203-5091-b441-0dc404142c60","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 두개의 Singly Linked List를 하나로 merge하는 문제이다. <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>둘 중 하나가 빈 배열이라면, 나머지를 그대로 리턴한다.</p>\n<p>둘 다 원소가 있는 링크드 리스트라면, 더 작은 원소를 붙이고, 더 작은 원소가 있던 링크드 리스트는 다음 노드를 가리키도록 갱신한다. 이를 반복한다.</p>\n<p>반복문 이후에 원소가 존재하는 리스트가 남아있다면, 결과 리스트에 이어붙여서 리턴해준다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n+m) => n,m 은 각각 두 링크드 리스트의 크기</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>기존 LinkedList를 head와 current를 이용하여 가리키도록 하였으므로, 공간복잡도는 크기에 따라 달라지지 않을 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> list1<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> list1 <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> list2\n        <span class=\"token keyword\">elif</span> list2 <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> list1\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># merge into sorted array</span>\n            <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> list2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                head <span class=\"token operator\">=</span> list1\n                list1 <span class=\"token operator\">=</span> list1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                head <span class=\"token operator\">=</span> list2\n                list2 <span class=\"token operator\">=</span> list2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            current <span class=\"token operator\">=</span> head\n            <span class=\"token keyword\">while</span> list1 <span class=\"token keyword\">and</span> list2<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> list2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># list1이 다음으로 연결되는 경우</span>\n                    current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list1\n                    list1 <span class=\"token operator\">=</span> list1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                    current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list2\n                    list2 <span class=\"token operator\">=</span> list2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token comment\"># list가 남아있는 경우, current에 이어 붙여줌</span>\n            <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list1\n            <span class=\"token keyword\">elif</span> list2<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list2\n            <span class=\"token keyword\">return</span> head</code></pre></div>\n<p>결과 linkedlist는 head에서부터 시작한다. 그리고 루프를 돌며 list1와 list2 중 더 작은 값을 current에 이어주면 된다.</p>","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 21. Merge Two Sorted Lists","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-21/"}},"prev":{"id":"276625a8-66ba-5e44-b07a-5fa0c6b71f4a","html":"<p>35번.</p>\n<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 배열에서 특정 값의 위치를 찾는다. <a href=\"https://leetcode.com/problems/search-insert-position/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>정렬된 배열에서 값을 찾는 문제는 <code class=\"language-text\">Binary Search</code>(이분탐색) 알고리즘을 이용하면 편하게 풀 수 있다. 이분탐색은 정렬된 배열에서 특정 조건을 만족시키는 원소의 인덱스를 찾는데 O(log(n))에 해결할 수 있다.</p>\n<p>이분탐색의 알고리즘은 다음과 같다.</p>\n<ul>\n<li>\n<p>처음과 끝을 가리킨다. 처음은 가장 작은 값, 끝은 가장 큰 값일 것이다.</p>\n</li>\n<li>\n<p>처음과 끝 중간값을 target과 비교한다.</p>\n</li>\n<li>\n<p>target이 더 크다면 오른쪽으로 시야를 옮기고, 더 작다면 왼쪽으로 시야를 옮긴다. (시야를 옮긴다는 것은 처음이나 끝 값을 중간값+-1로 옮김을 의미)</p>\n</li>\n<li>\n<p>처음과 끝 값이 cross가 될때까지 이를 반복한다. 그 값이 중요 포인트가 될 것이다.</p>\n</li>\n</ul>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(log(n))</p>\n<p>이분탐색은 2부분으로 나눠서 탐색하는 것이므로 log_2(n)만큼의 시간이 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>배열이 크다고 해서 추가적인 공간 소비는 없다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">searchInsert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        strt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        end <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> strt <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">:</span>\n            mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>strt <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">//</span><span class=\"token number\">2</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> target<span class=\"token punctuation\">:</span>\n                end <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                strt <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> strt</code></pre></div>\n<p>해당 경우에는 무조건 target이 존재하므로 strt를 리턴하면 될 것이다. 만약 아니라면 조건문과 return 문을 수정할 필요가 있다.</p>\n<hr>\n<p>74번.</p>\n<h1 id=\"intuition-1\" style=\"position:relative;\"><a href=\"#intuition-1\" aria-label=\"intuition 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 matrix에서 target이 존재하는지 여부를 판단하는 문제이다. <a href=\"https://leetcode.com/problems/search-a-2d-matrix/\">링크</a></p>\n<h1 id=\"approach-1\" style=\"position:relative;\"><a href=\"#approach-1\" aria-label=\"approach 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>위의 문제와 다른점은 2차원 배열이라는 것과, 값이 존재하지 않을 수 있다는 것이다.</p>\n<p>depth가 1인 루프로 만들기 위해 전체 순서를 이용하여 row, col 위치를 확정짓도록 구현하였다. (그럼 위의 binary search 문제와 거의 유사해진다)</p>\n<h1 id=\"complexity-1\" style=\"position:relative;\"><a href=\"#complexity-1\" aria-label=\"complexity 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(m) => m 은 matrix 크기이다</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n</li>\n</ul>\n<h1 id=\"code-1\" style=\"position:relative;\"><a href=\"#code-1\" aria-label=\"code 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">searchMatrix</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        row_size <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">)</span>\n        col_size<span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        strt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        end <span class=\"token operator\">=</span> col_size <span class=\"token operator\">*</span> row_size <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> strt <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">:</span>\n            mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>strt<span class=\"token operator\">+</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span>\n            row <span class=\"token operator\">=</span> mid <span class=\"token operator\">//</span> col_size\n            col <span class=\"token operator\">=</span> mid <span class=\"token operator\">%</span> col_size\n            <span class=\"token comment\"># print(row, col, matrix[row][col])</span>\n            <span class=\"token keyword\">if</span> matrix<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>col<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">:</span>\n                end <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> matrix<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>col<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">:</span>\n                strt <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></code></pre></div>\n<p>여기서 while loop를 하나만 돌기 위하여 matrix를 <code class=\"language-text\">flatten</code>한 것과 같이 인덱스를 구하여 진행하였다.</p>","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 35. Search Insert Position, 74. Search a 2D Matrix","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-35&74/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-3/","nextSlug":"/Alg-LC-21/","prevSlug":"/Alg-LC-35&74/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}