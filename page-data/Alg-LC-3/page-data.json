{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-3/",
    "result": {"data":{"cur":{"id":"833b0fc7-e393-5ac3-900a-23654561e0b4","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. <a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\">링크</a></p>\n<p>나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다.</p>\n<ul>\n<li>bbbbb -> b</li>\n<li>abcabcbb -> abc or bca or cab</li>\n<li>pwwkew -> wke or kew</li>\n<li>dvdf -> vdf</li>\n</ul>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ol>\n<li>\n<p>Brute Force</p>\n<p>단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다.</p>\n<p>s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, <u>substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다</u></p>\n</li>\n<li>\n<p>Set 이용하여 개선</p>\n<p>처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 <code class=\"language-text\">O(len(substr))</code>만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어서 <code class=\"language-text\">O(1)</code>에 처리가 가능하기 때문이다. (하지만, 해당문자까지 제거하는 과정은 최악의 경우 substr만큼 소요될 것이다)</p>\n</li>\n</ol>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n?)</p>\n<p>1번 방법은 n회의 루프동안 substr의 크기만큼 탐색해야하므로 <code class=\"language-text\">O(n^2)</code>만큼 소요된다.</p>\n<p>2번 방법은 탐색하는 시간이 줄어들지만, 중복이 있을 때 제거하는 remove 연산의 수행횟수에 따라 O(n)에 근사한 속도가 나올 것이다. set의 remove는 평균적으로 O(1)에 가능하지만 (드물지만 최악의 경우) O(n)까지도 될 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>set의 크기는 substr에 비례하므로 최대 O(n)의 공간 복잡도를 갖는다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        substr <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n        longestLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> end <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># check repeat</span>\n            <span class=\"token comment\"># print(substr, s[end])</span>\n            ind <span class=\"token operator\">=</span> substr<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> ind <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                longestLen <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                substr <span class=\"token operator\">=</span> substr<span class=\"token punctuation\">[</span>ind<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\">#print('after:',substr)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                substr <span class=\"token operator\">+=</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        substr_set <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        strt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        longestLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> end <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(strt,end,s[strt],s[end], substr_set)</span>\n            <span class=\"token keyword\">while</span> s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span> <span class=\"token keyword\">in</span> substr_set<span class=\"token punctuation\">:</span>\n                substr_set<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>strt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                strt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            substr_set<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            longestLen <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>longestLen<span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>substr_set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> longestLen</code></pre></div>\n<p>속도는 1번이 64ms, 2번 방법이 57ms로 더 빠르지만 메모리는 0.2MB 더 많이 사용하는 것을 확인할 수 있다.</p>\n<p>여러 값 중 어떠한 값이 있는지 확인하는 방법을 선형 탐색과 해시 테이블로 했을 때의 차이라고 보면 될 것이다.</p>","excerpt":"Intuition 문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. 링크 나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다. bbbbb -> b abcabcbb -> abc or bca or cab pwwkew -> wke or kew dvdf -> vdf Approach Brute Force 단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다. s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다 Set 이용하여 개선 처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어…","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 3. Longest Substring Without Repeating Characters","categories":"ALG","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-3/"}},"next":{"id":"8fe1d79e-afca-5825-b14c-e9c8484a4a7f","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 숫자 배열에서 index1와 index2의 원소의 합이 target이 되도록 하는 인덱스 쌍을 찾는 문제이다. <a href=\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ol>\n<li>\n<p>Brute Force</p>\n<p>for loop를 두개 돌면서, 합이 target이 되도록 하는 i와 j를 찾는 방법을 고려해볼 수 있다.</p>\n<p>하지만 이 방법은 <code class=\"language-text\">O(n^2)</code>이 걸릴 것이다. (실제로 시간초과가 난다)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 시간초과</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># find two index that sum of elements is equivalent to target</span>\n        <span class=\"token comment\"># numbers are non-decreasing order list</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                result <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> numbers<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> result <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> result <span class=\"token operator\">></span> target<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">continue</span></code></pre></div>\n<p>배열의 크기가 <code class=\"language-text\">3*10^4</code>까지 가므로, 최악의 경우 <code class=\"language-text\">9*10^8</code> 이 걸린다… 이를 줄이기 위해 투 포인터를 도입해볼 수 있다.</p>\n</li>\n<li>\n<p>Two Pointer</p>\n<p>배열이 정렬되어 있으므로, 전수탐색하지 않아도 된다. i&#x3C;=j 라면 nums[i] &#x3C;= nums[j] 임을 이용하자!</p>\n<ul>\n<li>nums[i] + nums[j]가 target보다 크다면, 값을 줄이기 위해 j를 앞당기고,</li>\n<li>target보다 작다면 i를 뒤로 보내면 될 것이다.</li>\n</ul>\n<p>물론, target보다 큰 경우에 i를 앞으로 보내도 되지만 그렇게 되면 경우의 수가 많아지므로 <strong>가장 큰 값을 내는 조합인 양 끝값으로 시작하여 방향을 고정할 수 있을 것이다</strong>.</p>\n</li>\n</ol>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>i, j를 양끝에서부터 최악의 경우 가운데에서 만나므로 <code class=\"language-text\">O(n)</code>에 처리 가능하다.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>추가적인 메모리는 배열의 크기와 무관하므로 공간 복잡도는 <code class=\"language-text\">O(1)</code>이라고 볼 수 있다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># find two index that sum of elements is equivalent to target</span>\n        <span class=\"token comment\"># numbers are non-decreasing order list</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span>\n        left <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        right <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n            result <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> numbers<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> result <span class=\"token operator\">></span> target<span class=\"token punctuation\">:</span>\n                right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> result <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>left<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>정렬 조건을 이용하면 조합에 있어서 더 효율적인 방법을 고려할 수 있으므로 유념하자!</p>","frontmatter":{"date":"August 27, 2023","title":"(Alg) LeetCode Top Interview 150 - 167. Two Sum II - Input Array Is Sorted","categories":"ALG","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-167/"}},"prev":{"id":"6d3838d9-493d-5c76-9a54-a6ec6a49a57f","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Singly Linked List(next만 존재)로 십진수 숫자를 표현할 때, 두 숫자를 더한 결과를 Linked List로 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/add-two-numbers\">링크</a></p>\n<p>주의할 점으로는, 숫자는 작은 자리부터 거꾸로 표현이 되어있다는 것이다. 예를 들어, 123은 3->2->1로 표현되어 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>컴퓨터 구조에서 배운 가산기와 비슷하게 더하기 연산을 구현해볼 수 있다. 올림이 발생하는 경우에 다음 자릿수로 1을 넘겨주면 된다. 이를 재귀적으로 수행하면 될 것이다.</p>\n<p>추가적으로 두 list의 길이가 다른 경우에도 고려해야하는데, 더 짧은 list의 경우에는 더할 것이 없기 때문에 0으로 처리하였다. 짧은 리스트의 값이 남아있지 않더라도 올림수가 있을 수 있으므로, 위의 연산은 끝까지 수행해줘야한다.</p>\n<p>더 긴 리스트 끝까지 수행했을 때에도 올림수가 남아있다면 (ex 9999 + 1 => <u>1</u>0000) 1을 추가적으로 1을 연결해주는 작업도 필요할 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(max(n,m)) => n,m 은 각각 두 링크드 리스트의 크기</p>\n</li>\n<li>\n<p>Space complexity: O(max(n,m))</p>\n<p>새로운 링크드 리스트는 두 배열의 크기정도이다. 결과 리스트의 각 원소들은 더한 값으로 새로 만들어지므로 별도의 공간이 필요하다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">addTwoNumbers</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        up <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        head <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n        current <span class=\"token operator\">=</span> head\n        <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">or</span> l2<span class=\"token punctuation\">:</span>\n            val1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n            val2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n            val <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>val1 <span class=\"token operator\">+</span> val2 <span class=\"token operator\">+</span> up<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">10</span>\n            up <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>val1 <span class=\"token operator\">+</span> val2 <span class=\"token operator\">+</span> up<span class=\"token punctuation\">)</span><span class=\"token operator\">//</span><span class=\"token number\">10</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>val1<span class=\"token punctuation\">,</span> val2<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> up<span class=\"token punctuation\">)</span>\n            new_node <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> head <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                head <span class=\"token operator\">=</span> new_node\n                current <span class=\"token operator\">=</span> head\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 기존 링크드 리스트에 추가</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> new_node\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n            l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n        <span class=\"token keyword\">if</span> up <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 마지막 하나 남은 경우</span>\n            current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> head</code></pre></div>\n<p>주의할 점으로는, 배열의 값이 없는 경우 <code class=\"language-text\">val1 = l1.val if l1 else 0</code>과 같이 판단하였는데 <code class=\"language-text\">val1 = l1.val if l1.val else 0</code>로 하면 NoneType에서의 접근 에러가 나오므로 l1자체가 NoneType인지를 판단해야한다.</p>","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 2. Add Two Numbers","categories":"ALG","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-2/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-3/","nextSlug":"/Alg-LC-167/","prevSlug":"/Alg-LC-2/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}