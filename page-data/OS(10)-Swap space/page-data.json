{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(10)-Swap space/",
    "result": {"data":{"cur":{"id":"e7a643ea-3297-52e9-9cef-f79a8a963286","html":"<p>현대의 많은 시스템들은 64bit 주소 체계를 사용하고 있는데, 여러 프로세스들이 동시에 실행되기에 16GB정도의 메모리는 매우 부족하다. 그렇지만 우리는 아무렇지 않게 여러 프로세스를 띄워놓고 사용하고 있다. 과연 <strong>운영체제는 어떻게 이런 물리 메모리의 공간 부족을 해결하고 가상화된 물리 메모리를 프로세스에게 제공</strong>할까?</p>\n<p>오늘은 이러한 메모리 공간 부족을 극복하는 방법에 대하여 알아보자.</p>\n<h1 id=\"swap-space\" style=\"position:relative;\"><a href=\"#swap-space\" aria-label=\"swap space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap Space</h1>\n<p>OS는 disk(HDD, SSD)를 이용한다! Process에서 활성화된 영역만 메모리에 남기고 필요없는 메모리 공간은 <code class=\"language-text\">swap out</code> 하여 보조 저장장치의 <strong>swap space</strong>에 저장한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABYUlEQVQoz3WQy8qBURSGvzuQqVtxDUrMpMxNXISJ+kouwEQpkkwcJgwMPsoh5UxO5ThwKCHl9Giv/v8v9dv1tvberfX0vkvj50ynU5bLJev1WnQ4HJjNZux2O/r9PtvtVvper5fo29F6vZ7A0uk02WyWZrPJcDgUmKqlUgm/308sFvsAfpPWarVkMJfLkclkBDgej/+ghUJBgJFI5MPJfy4FqC6Px4PFYsFms5Fol8tFIh+PR1lDu91mMpmw3+85n8/cbjcZvl6vnE4n7ve7/Elk1aCUz+cpl8viqFgsitN6vS5Ou90uq9VKwGqfXq8Xm82Gruskk0kCgYC8PR4PmoqqoiUSCVKpFPF4nGg0imEYNBoN1EoqlYqAOp0O1WoVq9WK2WzG5XIRDAZxOBxYLBZMJhPa8/kUh4PBQKTcqDoajZjP5+JMxfqNq1bi8/mw2+2Ew2FqtRqhUAin04nb7eYNurPeYwf3c0kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"swap_space\"\n        title=\"swap_space\"\n        src=\"/static/a592d7946e1673ed3a19a6ea93a9dc58/37523/swap_space_!.png\"\n        srcset=\"/static/a592d7946e1673ed3a19a6ea93a9dc58/e9ff0/swap_space_!.png 180w,\n/static/a592d7946e1673ed3a19a6ea93a9dc58/f21e7/swap_space_!.png 360w,\n/static/a592d7946e1673ed3a19a6ea93a9dc58/37523/swap_space_!.png 720w,\n/static/a592d7946e1673ed3a19a6ea93a9dc58/302a4/swap_space_!.png 1080w,\n/static/a592d7946e1673ed3a19a6ea93a9dc58/cf8e5/swap_space_!.png 1402w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>swap space는 보조 저장장치에 존재하는 공간으로, 프로세스의 주소공간을 의미한다. 하지만 보조 저장장치는 속도가 매우 느리므로, 해당 공간에는 사용되지 않지만 나중에 필요할 수 있는 Page를 메인 메모리로부터 <code class=\"language-text\">Swap out</code>  한다. 이에 해당 Page가 필요한 경우에 다시 메인 메모리로 <code class=\"language-text\">Swap in</code> 하여 사용한다.</p>\n<p>Swap Space를 통하여 OS는 각 프로세스들에게 **큰 가상 메모리가 있는 것 같은 환상(Virtualization)**을 줄 수 있다. 이렇게 Page 단위로 부족한 공간을 disk에 저장하고(swap out), 가져오는(swap in) 방법을 <code class=\"language-text\">Demand Paging</code>이라고 한다.</p>\n<p>이제 구체적으로 Swapping이 어떠한 방식으로 이루어지는지 알아보자. 이를 위해서는 앞서 언급한 Page Table의 <strong>PTE</strong>의 구성을 복기해 볼 필요가 있다.</p>\n<h2 id=\"swapping\" style=\"position:relative;\"><a href=\"#swapping\" aria-label=\"swapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swapping</h2>\n<p>PTE는 Page Table에서 가상 주소 공간과 실제 물리 주소 공간을 매핑해주며, 이에 해당 페이지에 대한 추가적인 정보를 비트로 기록한다고 했었다. 그중 <strong>Present Bit</strong>은 해당 Page가 메인 메모리에 있는지 swap space에 있는지를 구분한다.</p>\n<p>따라서 Address Translation이 일어날 때, MMU가 present bit을 읽어오고, present하다면 바로 translation을 수행하며 아니라면 <strong>Page Fault</strong>를 발생시킨다. 이에 OS는 Page Fault Handling 작업을 아래와 같이 수행한다. (즉, Page Fault에 대한 처리는 주로 소프트웨어적으로 일어난다)</p>\n<ul>\n<li>CPU를 커널 모드로 전환한다.</li>\n<li>OS는 해당 페이지를 disk에서부터 가져온다. (I/O를 수행할 동안 해당 Process는 block될 것이다)\n<ul>\n<li>disk에서 페이지의 위치 역시 Page Table에 보통 보관한다고 한다</li>\n</ul>\n</li>\n<li>OS는 그동안 다른 Process로 context switching을 한다.</li>\n<li>disk로부터 해당 page가 다 읽어와지면, OS는 Page Table을 업데이트하고(present) blocking되어 있던 프로세스의 상태를 ready로 바꿔준다.</li>\n<li>해당 프로세스가 다시 스케줄된다면, Page Fault가 발생한 명령어부터 다시 실행한다.(이때는 Page Fault 발생없이 진행될 것임)</li>\n</ul>\n<h2 id=\"만약-memory에-여유-공간이-없을때-page-fault가-발생한다면\" style=\"position:relative;\"><a href=\"#%EB%A7%8C%EC%95%BD-memory%EC%97%90-%EC%97%AC%EC%9C%A0-%EA%B3%B5%EA%B0%84%EC%9D%B4-%EC%97%86%EC%9D%84%EB%95%8C-page-fault%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4%EB%A9%B4\" aria-label=\"만약 memory에 여유 공간이 없을때 page fault가 발생한다면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>만약 Memory에 여유 공간이 없을때, Page Fault가 발생한다면?</h2>\n<p>Page Fault 발생시, 메모리의 여유 공간(free space)를 찾아 해당 공간에 swap in 시킬 것이다. 하지만, 메모리에 여유 공간이 없다면 어떻게 할까?</p>\n<p>가장 간단한 아이디어로는 기존 page 중 하나를 swap out하고, 그곳에 disk의 page를 swap in 하는 방법이 있을 것이다. 하지만 이 방법은 효율적이지 않다. (최악의 경우 수많은 IO작업과 메모리 접근이 일어나기 때문)</p>\n<p>따라서 이러한 일이 일어나지 않도록 OS는 항상 memory 공간을 여유있게 관리하도록 <strong>교체 정책</strong>이 존재한다. 보통 최댓값(HW, High Watermark)와 최솟값(LW, Low Watermark)을 설정하고, <u>여유 공간의 크기가 LW보다 작아지면 free space를 확보하는 Background Thread를 실행</u>한다고 한다. 해당 쓰레드는 여유공간이 HW에 이를때까지 페이지를 제거하고, 백그라운드에서 페이지 스왑과 관련된 일을 처리하므로 <code class=\"language-text\">Swap Demon</code> 혹은 <code class=\"language-text\">Page daemon</code>이라고도 불린다.</p>\n<p>추가적으로, 동시에 여러 페이지들을 clustering(or grouping)하여 교체하면 디스크 성능(탐색과 회전 지연 시간)에 도움이 된다고 한다.</p>\n<h3 id=\"tip--background\" style=\"position:relative;\"><a href=\"#tip--background\" aria-label=\"tip  background permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tip : Background</h3>\n<p>disk에 변경 내용을 즉시 반영하는 것은 overhead가 큰 작업이다. 이에 보통, <strong>메모리에 buffer를 두고 버퍼에 변경 내용을 우선 적용한 뒤에 background로 disk에 한번에 반영하는 것이 더 효율적</strong>이다. 이러한 백그라운드 작업은 시스템이 idle할 때 수행되므로 하드웨어 자원을 더 잘 활용할 수 있을 것이다.!</p>\n<h1 id=\"page-replacement-policy-페이지-교체-정책\" style=\"position:relative;\"><a href=\"#page-replacement-policy-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"page replacement policy 페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Replacement Policy (페이지 교체 정책)</h1>\n<p>페이지를 어떠한 기준으로 swap out(혹은 evict 라고도 함) 해야할까? scheduling과 마찬가지로, 여러 종류의 정책이 존재하고 미래는 예측 불가하므로 각 방법의 장단점이 존재할 것이다.</p>\n<ul>\n<li>FIFO : 가장 먼저 접근했던 페이지를 교체한다</li>\n<li>LRU/LFU : 가장 오래전에, 혹은 가장 적은 빈도로 사용한 페이지를 교체한다</li>\n</ul>\n<p>이러한 교체 정책을 **최적 교체 정책(Optimal Replacement Policy)**와 비교하면 장단점을 비교할 수 있을 것이다. 최적 교체 정책은 구현은 불가능에 가깝지만, 일어난 일들을 보고 최적 상태를 결정할 수 있고, 이를 다른 교체 정책과 비교해볼 수 있을 것이다.</p>\n<h2 id=\"lru를-구현하는-방법\" style=\"position:relative;\"><a href=\"#lru%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"lru를 구현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU를 구현하는 방법</h2>\n<p>LRU 정책은 과거를 보고 미래를 예측하는 형식으로, 지역성의 원칙을 이용한 대표적인 정책이므로 대체적으로 hit율이 높다.</p>\n<p>하지만 OS는 모든 메모리 접근에 관여하지는 않는다. 따라서, LRU를 구현하기 위해서는 추가적인 operation이 필요하고 이것은 비용이 들 것이다. 이에 MMU에서 PTE의 <code class=\"language-text\">access bit</code>(혹은 use bit)을 두어 LRU를 근사하게 구현할 수 있다. 주기적으로 use bit를 지우고, replacement 수행시 use bit를 보고 해당 page가 접근되지 않았다면 swap out 하면 될 것이다! (물론 실제로는 더 복잡할 것)</p>\n<h1 id=\"memory-access시에-일어나는-일\" style=\"position:relative;\"><a href=\"#memory-access%EC%8B%9C%EC%97%90-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC\" aria-label=\"memory access시에 일어나는 일 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory Access시에 일어나는 일</h1>\n<p>그렇다면, Swap Space를 고려한 메모리 가상화(가상주소가 물리주소로 전환되는 과정)가 어떻게 일어나는지  총정리 해보자.</p>\n<ul>\n<li>CPU는 code 또는 data 영역에 있는 데이터의 VA를 가져온다\n<ul>\n<li>이미 해당 명령어 내용이 CPU cache에 있다면 굳이 메모리에 접근하지 않는다</li>\n<li>cache miss시 main memory에 접근하기 위해 아래를 수행한다</li>\n</ul>\n</li>\n<li>MMU(Memory Management Unit, 프로세서 칩 안에 보통 있음)는 VA를 PA로 전환해주는데, 우선 TLB를 확인한다\n<ul>\n<li>TLB hit이 발생하면, PA로 바로 전환하여 CPU에게 메모리 주소를 전달한다</li>\n<li>miss가 발생하면, MMU는 Page Table에 접근하기 위하여 main memory에 접근한다\n<ul>\n<li>해당 Page Table의 VA를 통하여 해당하는 PTE를 본다</li>\n<li>present하다면, memory에 바로 접근한다</li>\n<li>valid하지만 present하지 않다면, page fault가 발생하고 OS는 page fault handling(swap 공간에서 메모리로 가져옴)을 수행하고, 이후 다시 기존 load 명령어를 재실행 할 것이다</li>\n<li>invalid하다면 OS는 illegal access에 대한 오류를 발생시킨다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"현대의 많은 시스템들은 64bit 주소 체계를 사용하고 있는데, 여러 프로세스들이 동시에 실행되기에 16GB정도의 메모리는 매우 부족하다. 그렇지만 우리는 아무렇지 않게 여러 프로세스를 띄워놓고 사용하고 있다. 과연 운영체제는 어떻게 이런 물리 메모리의 공간 부족을 해결하고 가상화된 물리 메모리를 프로세스에게 제공할까? 오늘은 이러한 메모리 공간 부족을 극복하는 방법에 대하여 알아보자. Swap Space OS는 disk(HDD, SSD)를 이용한다! Process에서 활성화된 영역만 메모리에 남기고 필요없는 메모리 공간은  하여 보조 저장장치의 swap space에 저장한다.  swap space는 보조 저장장치에 존재하는 공간으로, 프로세스의 주소공간을 의미한다. 하지만 보조 저장장치는 속도가 매우 느리므로, 해당 공간에는 사용되지 않지만 나중에 필요할 수 있는 Page를 메인 메모리로부터   한다. 이에 해당 Page가 필요한 경우에 다시 메인 메모리로  하여 사용한다. Sw…","frontmatter":{"date":"November 24, 2023","title":"(OS) 운영체제 복습 [10. Demand Paging - Swap Space]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(10)-Swap space/"}},"next":{"id":"e08fbfa3-135f-57f0-8191-3c0897ac61ae","html":"<p>저번시간에는 메모리 가상화에서 Paging 기법에 대하여 배웠다.</p>\n<p><strong>고정된 크기의 Page로 주소 공간을 분할하고, 이를 물리 메모리의 남는 자리에 배치하여 가상 주소공간과 물리 주소공간을 Page Table을 통하여 매칭하는 방법</strong>이다.</p>\n<p>하지만, page table은 기본적으로 memory 공간에 있으므로 시간적으로 느려져 주소를 전환하는 <code class=\"language-text\">MMU</code>에 <code class=\"language-text\">TLB</code>라는 캐시를 두어 하드웨어적으로 속도를 향상시킬 수 있는 방법이 제안되었다.</p>\n<p>또한 page table 자체의 크기(+대부분은 invalid/unused 상태인채로 비어있음)도 무시할 수 없으므로 이를 줄일 수 있는 방법이 제안되었는데, 오늘은 그 방법에 대하여 다뤄보자.</p>\n<h1 id=\"1-bigger-pages\" style=\"position:relative;\"><a href=\"#1-bigger-pages\" aria-label=\"1 bigger pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Bigger Pages</h1>\n<p>가장 간단한 방법으로는 Page Frame 자체의 크기를 늘리는 방법이다. 이를 통해 Page Table Entry(PTE)의 갯수를 줄여 Page Table의 크기를 줄일 수 있을 것이다.</p>\n<p>32bit address space에서, Page Frame의 크기를 4KB에서 16KB로 늘린다고 가정해보자. 16KB = 2^14B이므로, 주소 공간을 18비트(VPN, virtual page number), 14비트(offset, 페이지 내부에서의 위치)로 나눌 수 있을 것이다. PTE의 크기를 4B라고 했을 때, Page table의 크기는 4B*2^18 = 2^20B = 1MB가 될 것이다.</p>\n<p><strong>즉, Page Frame의 크기를 n배로 커질수록 Page Table의 크기는 1/n로 작아진다.</strong></p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>그럼 페이지의 크기를 크게 하는 것이 능사일까? 절대 아니다!</p>\n<p>Page이전에, 연속적인 하나의 물리 공간을 제공하는 경우에는 <strong>internal fragment</strong>(내부 단편화), 즉 사용되지 않는 공간을 할당하여 낭비가 생기는 문제가 생겨 많은 프로세스가 실행되기에 어렵다.</p>\n<p>이에 실제 사용되는 컴퓨터 시스템에서는 4KB 또는 8KB의 페이지 크기를 채택한다고 한다.</p>\n<h1 id=\"2-hybrid-approach--paging--segmentation\" style=\"position:relative;\"><a href=\"#2-hybrid-approach--paging--segmentation\" aria-label=\"2 hybrid approach  paging  segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Hybrid Approach : Paging + Segmentation</h1>\n<p>Page의 크기는 고정하면서, Page Table의 크기를 줄이는 방법에 대하여 알아보자. 가장 간단한 방법은 기존 <code class=\"language-text\">Segmentation</code>기법과 <code class=\"language-text\">Paging</code>기법을 결합하는 방법이다.</p>\n<p>프로세스의 메모리 공간은 크게 code, heap, stack 영역으로 구성되는데, <strong>각각을 하나의 Page Table로 할당</strong>한다. 따라서 하드웨어적으로 3개의 base register와 bound register가 필요하고, 이는 <u>Page Table의 시작점과 범위를 가리킬 것</u>이다.</p>\n<p>이 방법은 전체 영역을 하나의 Page Table로 두는 대신, segment 단위로 page table을 두므로 stack과 heap사이의 큰 빈 영역을 사용하지 않는 효과를 볼 수 있다.</p>\n<p>예컨대 32비트 주소공간에서 가상 주소는 다음과 같이 처리될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAW0lEQVQI102NSwoAIQxDvf/BXHkGRYt/PUMkgYFZhKYvKXW1VvTe0VrDGEOeSimJrbXE55ya7JNxv/finIO9N0op4s7MdMgiRZ9zRghBpX9GxRjFPvEJ+957ZQ+6JpLvbA+UnwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hybrid\"\n        title=\"hybrid\"\n        src=\"/static/3f040b7b522862642412379ead8a9309/37523/hybrid.png\"\n        srcset=\"/static/3f040b7b522862642412379ead8a9309/e9ff0/hybrid.png 180w,\n/static/3f040b7b522862642412379ead8a9309/f21e7/hybrid.png 360w,\n/static/3f040b7b522862642412379ead8a9309/37523/hybrid.png 720w,\n/static/3f040b7b522862642412379ead8a9309/302a4/hybrid.png 1080w,\n/static/3f040b7b522862642412379ead8a9309/07a9c/hybrid.png 1440w,\n/static/3f040b7b522862642412379ead8a9309/0f586/hybrid.png 1498w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>상위 2비트의 Segment 영역은</p>\n<ul>\n<li>00 : unused</li>\n<li>01 : code</li>\n<li>10 : heap</li>\n<li>11 : stack</li>\n</ul>\n<p>영역을 의미한다고 하면 모든 세그먼트를 처리할 수 있게 된다.</p>\n<p>상위 2비트로 어떤 segment인지 결정하고, 이에 해당하는 base&#x26;bound register를 얻는다. 이를 통하여 VPN을 PFN으로 변환하여 물리 주소를 얻고, 유효한 범위인지 확인하는 방법으로 address translation이 이루어질 것이다.</p>\n<p>이 방법을 이용하는 경우, Page Table의 크기는 사용되는 공간만큼만 필요하고 이를 bound register로 검증할 수 있으므로 메모리 절약에 큰 효과가 있을 것이다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<ol>\n<li>\n<p>external fragment</p>\n<p>해당 방법은 Page의 크기는 같지만, Page Table의 크기가 달라진다. 따라서, 외부 단편화가 발생할 수 있다.</p>\n</li>\n<li>\n<p>heap공간의 특징</p>\n<p>heap공간은 stack과 다르게 순서대로 데이터가 쌓이지 않고, memory 관리에 의하여 sparse하게 데이터가 저장되고 우리는 각 변수별 포인터를 갖고 있는다. 이러한 <strong>sparse used 구조는 page table의 낭비</strong>를 일으킬 수 있다.</p>\n<p>stack의 경우에는 런타임에서 LIFO 형태로 순서대로 쌓이므로 Stack Pointer를 두기에 이러한 단편화를 고려하지 않아도 된다.</p>\n</li>\n</ol>\n<h1 id=\"3-multi-level-page-table\" style=\"position:relative;\"><a href=\"#3-multi-level-page-table\" aria-label=\"3 multi level page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Multi Level Page Table</h1>\n<p>기존에 address translation에 대한 정보를 담는 PTE가 저장되어 있는 방법을 <code class=\"language-text\">Linear Page Table</code>이라고 한다. 이를 트리 구조로 표현한 것이 <code class=\"language-text\">Multi Level Page Table</code>이다. (이에 기존 방법은 Single level PT라고도 부른다)</p>\n<p>핵심은 Page Frame 여러개를 하나의 묶음으로 놓고, 이것들을 관리하는 outer page table인 <code class=\"language-text\">Page Directory</code>를 두어 관리하는 것이다. 기존에는 여러 page frame을 하나의 page table로 두었지만, 이 방법은 몇개의 page frame을 하나의 묶음으로 보아 이 묶음을 Page Table에서 관리하는 것이라고 보면 된다.</p>\n<p>간단하게 말해, Page Table을 Paging한다고 보면 된다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABZklEQVQoz22Si66CQAxE+f+PI0EwCEZF5KX4RFDxQc3pzZq9CZs0q7QznWnX6ftedrudbLdbjfv9Lua8Xi+pqkr2+73e5B+Ph+aGYRgNpygKOZ/PkiSJnE4nadtW3u+3RpqmUte1ULPZbLTudrspcOwo4eFwEAIi1KLKqEQNTSDpuk6/GULq8jzX227iYMX3fVkulxKGodoz4KZpZD6fq9IgCLTx5XLRxjRyXVeVg4eH705ZllqcZZms12stIMEhZ5qgBsuoRg2OPM/TcYBjZAhx6A4IMEHCEGJ9tVrJbDaT6XSqOQjJQ04TMNwoxLoSxnGsm0YJoOfz+Rv05/PR/8yKQB1ANo5txgAWYsahhFEUaQEbtQnHtkkDCM0ywUBIMAYHgsViIcfj8fd8bEI7bEIzInAEs7xer3/vkPlwm/dmZmgrNL+5eaPYm0wm/3CqENlY5gPbQjqAMcu2UjbKssDhileCsy949kVqSNTjAwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mlpt\"\n        title=\"mlpt\"\n        src=\"/static/564f32ebea90426036bb5165c262ce59/37523/mlpt.png\"\n        srcset=\"/static/564f32ebea90426036bb5165c262ce59/e9ff0/mlpt.png 180w,\n/static/564f32ebea90426036bb5165c262ce59/f21e7/mlpt.png 360w,\n/static/564f32ebea90426036bb5165c262ce59/37523/mlpt.png 720w,\n/static/564f32ebea90426036bb5165c262ce59/302a4/mlpt.png 1080w,\n/static/564f32ebea90426036bb5165c262ce59/07a9c/mlpt.png 1440w,\n/static/564f32ebea90426036bb5165c262ce59/a2792/mlpt.png 1462w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 그림은 Linear Page Table과 2-level Page Table의 구조를 비교해볼 수 있는 그림이다. 한 Page에 4개의 PTE가 들어가는 상황으로 가정하자. (실제로는 한 Page에 더 많은 PTE가 들어갈 것임)</p>\n<p>기존 Linear에서는 16개의 PTE중 5개만 사용중이므로, 11개는 할당되었지만 invalid하여 낭비되는 상태이다.</p>\n<p><strong>이에 PTE를 담는 Page를 Entry로 두어 Page Directory에서는 사용중인 Page만 관리하는 것</strong>이 <code class=\"language-text\">Multi Level Page Table</code> 방식이다.</p>\n<p>위의 예시에서, 12,13,15,86번 Page Frame이 Process를 위해 사용중이고, Page Table Entry를 위하여 201,204번 Page Frame이 사용중이다. Page Table Entry를 위한 Page Frame을 Page Directory에서 관리하고, 해당 Page Frame에서는 실제 PTE를 갖고 있도록 한다. 이를 통하여 Page Directory는 <strong>사용하지 않는 Page Table의 공간을 줄일 수 있다</strong>.</p>\n<p>좀 헷갈릴 수도 있어 다시 정리해보면,</p>\n<p>Page Table의 크기를 줄이기 위해 (PTE도 역시 특정 Page Frame에서 관리되므로) <strong>사용중인 PTE가 있는 Page Frame만 Page Directory라는 곳에서 관리하는 것</strong>이다.</p>\n<h2 id=\"address-translation\" style=\"position:relative;\"><a href=\"#address-translation\" aria-label=\"address translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address Translation</h2>\n<p>그렇다면 2-level 에서는 주소 변환이 어떻게 이루어질까?</p>\n<p>간단하게 14비트 주소 체계의 예시를 보자. <u>페이지의 크기는 64B이고, 16KB의 address space를 갖고, PTE는 4B라고 가정</u>하자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAqklEQVQY052QuQqGMBCE8/5vZiEEUopiiAd45BAtLHR+ZsEUYvUHlpmdfGwOdd83WNd1gWvbNpRliZSS9Mwf5s1WVQVjDM7zzKxa1xWsZVlE53lG3/ei3vu8Rz9NU/bMh2GAcy5nVNW2LZqmAZUAvbVWhhJmFmOU/XEc0XWd6LvIkFecypOfm/JmIQR5OiE+/TiOnLH/qn3fhVf8A601iqJAXdfimfGv/lk/uOp6+r52FR0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mlpt-translation\"\n        title=\"mlpt-translation\"\n        src=\"/static/32a7c0c7045800c96d7d39a90d26d9b0/37523/mlpt-translation.png\"\n        srcset=\"/static/32a7c0c7045800c96d7d39a90d26d9b0/e9ff0/mlpt-translation.png 180w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/f21e7/mlpt-translation.png 360w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/37523/mlpt-translation.png 720w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/2c5fd/mlpt-translation.png 1006w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그렇다면 64=2^6, 즉 6비트의 offset이 필요하고, 나머지 8비트는 VPN에 필요하다. 각 Page에는 16개의 PTE가 들어있을 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 118.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADLUlEQVQ4y62VWU8iURCF/f8PQBB/gCgkRGPcQE1AcAERQYIKgiwqooiICqKCW02+mtxmCcm8TCeXNNXV5546dW711O/vr3x9fen6/v7Wxf3Pz498fn7Ky8uLdDodabfb8vr6Kh8fH/L29ibdbldj5hm5XFOtVksikYgEg0E5PT2V3d1d2djYkGw2qwCPj48K8P7+Lo1GQxKJhObXajWNAcym5Ckg6KlUShNLpZKk02m9v7u7052fnp70xV6vJ/f393J4eCjb29v6nBjPyLMAQScpFovJxcWFgvH/4eFBYH95eSn1el3Z5fN5Ze/3++Xs7ExjAFerVc1XwOfnZwWIRqNSKBQUEJZXV1eavLS0pCBbW1syNzcnTqdTZmZmxOv1yubmpgQCAVlbW5Obm5sBw6OjI4nH48qQ8o+Pj4WNAFxYWJD19XVl5Xa7xeFwyPT0tN4TA2x5eVlZTiw5mUwqQ8SmJPQ6ODjQHF6en5+X2dlZZQYJ3tvb25Pb29tByTyg5PPzcwXd399XvbAEOtJlGgCLUCgk4XBYtTUWGukyf9ANUDQEEAnYcbzL6MRmWAtwYgBO7DJlwQpQSqZcknK5nFQqFW0S+i4uLmqjeIdYuVxWEuRPLBnATCajDGgKAIiPZjTC5XJpp9GSGA1bWVkZ7bIR12gI4HCXDSDNoMuAYiEDSJevr68HJwUArEJpLIDRDVA0Q1MWDaFcn8+nRxVHGP0tDeU/XgyaKX6YLOOLuHnGhUU4ggwFmA9PGJOvDBlXTBUWZmbhP0aY2ZUczurOzo7KQwMwPDIZUAvwXyVwmfk4fgHGZiMlk1wsFtXIlEJTTk5OtCmYmmOF8KYpWIRhwUwkxjM83Gw2/zIEEABMSpCxRDJlo9m4bex2u9hsNvXksA+t4QAgunA2AQSc/zAEEGPzIqwAYdIwvjwejzUbV1dXB8YGEFYYEy9xDyBnlJLxJOxZxAFh0RDegQiSWUcPQL4fUDZnF5am2+jKEOj3+/oJQFM04xQRw07m26OAdArHm10QGpZcgA1/pNgUdpwSGANmPlJWU8xn1BiaDYwHYQYoTA1bdIXpcByTAw7gH34XvanvfzIEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"usage\" title=\"usage\" src=\"/static/0748a417567f8bcc40cbceea6e619f87/9516f/mlpt_usage.png\" srcset=\"/static/0748a417567f8bcc40cbceea6e619f87/e9ff0/mlpt_usage.png 180w,\n/static/0748a417567f8bcc40cbceea6e619f87/f21e7/mlpt_usage.png 360w,\n/static/0748a417567f8bcc40cbceea6e619f87/9516f/mlpt_usage.png 538w\" sizes=\"(max-width: 538px) 100vw, 538px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>여기서 6개의 Page(0,1,4,5,254,255번)가 valid하고(사용중), 나머지는 비어있는 공간이라고 가정하자.</p>\n<h3 id=\"in-linear-page-table\" style=\"position:relative;\"><a href=\"#in-linear-page-table\" aria-label=\"in linear page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>in linear page table</h3>\n<p>기존 방법이라면, 사용 여부와 상관없이 Page Table을 저장하기 위해 2^8*4B = 2^10B = 1KB가 고정적으로 필요하다. PTE는 2^8=256개를 모두 사용한다.</p>\n<p>상위 8비트에 해당하는 PFN으로 교체를 하여 물리 주소 14비트를 얻을 수 있을 것이다.</p>\n<h3 id=\"in-multi-level-page-table\" style=\"position:relative;\"><a href=\"#in-multi-level-page-table\" aria-label=\"in multi level page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>in multi level page table</h3>\n<p>한 Page는 16개의 PTE를 담을 수 있으므로, 이를 구분하기 위해서 상위 4비트(2^4=16)를 Page Directory Index로 사용한다. 그렇다면 다음 상위 4비트는 한 페이지 내부에서 Page Table Index를 의미할 것이다.</p>\n<p>상위 4비트로 나누면, 0000인 부분과 1111인 부분만 사용중이고, 이는 각각 100번과 101번 Page Frame에 있다고 가정하자. 그렇다면 Page Directory는 다음과 같이 표현 가능할 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVQ4y42T3Y6CQAyF5/0fzzsVEbggQoLGH1BQ7OZrcszE3VltMpmhpz1z2g7heDzaZrOxtm1tuVxa13V2uVxsu91anudW17UVRWFlWfoifrfbOV5VlS/87MQGkrIs86DFYuEgwGq1sqZpHLter6/kYRgcExEx5/PZ1uu17fd7C6fTyR0Yiff73fq+dyXP59N9GKqFQzrPs59Zins8HhYAWBiBOG+3m5MSyBkbx9GmaXKcZDB8LAwMX4idkHAj31KATwkiRC07cbpQqgMAK1aIAtoQK8T3lULdLIUkQHw4HNwnQvUQnDjUxITEucJ3QpXMLvL3HooQEl34ItSkVHLcQ5WHqTXgqZJ/Eb4PJVYoxSlC5fw5ZeT/V3I8ZeUmp5wq+ZPC5JRTQyFG7ZGaj0P5hvBjyTDHzlQP9U0Sb1SKJIZ/3wlJiJPin56z2qFe0yfi9UzUf73NH49I33HFkFrOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"pagedirectory\"\n        title=\"pagedirectory\"\n        src=\"/static/cac38a41dd8b88208b6b912e413594bc/37523/pagedirectory.png\"\n        srcset=\"/static/cac38a41dd8b88208b6b912e413594bc/e9ff0/pagedirectory.png 180w,\n/static/cac38a41dd8b88208b6b912e413594bc/f21e7/pagedirectory.png 360w,\n/static/cac38a41dd8b88208b6b912e413594bc/37523/pagedirectory.png 720w,\n/static/cac38a41dd8b88208b6b912e413594bc/302a4/pagedirectory.png 1080w,\n/static/cac38a41dd8b88208b6b912e413594bc/1628f/pagedirectory.png 1232w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Page Directory에는 2개의 PFN만 사용중이고, 해당 Page에는 PTE가 각각 4개, 2개 저장되어 있는 모습일 것이다.</p>\n<p><strong>기존에는 256개의 PTE를 모두 할당하였는데, 이렇게 계층화한다면 2*16개의 PTE만 할당해도 되며, 16칸의 Page Directory의 영역만 있어도 될 것</strong>이다.</p>\n<p>물리주소로 변환하는 과정을 살펴보자. 예를 들어, 스택 영역의 11 1111 1000 0000가상주소를 변환한다고 했을 때,</p>\n<ol>\n<li><strong>상위 4비트(1111)는 Page Directory의 Index</strong>이므로, Page Directory의 1111, 즉 15번째(마지막) 주소, 즉 101번 페이지에 해당 PTE가 존재함을 의미한다.</li>\n<li><strong>다음 4비트(1110)는 Page Table의 Index</strong>이므로, 101번째 Page에 있는 1110번째, 즉 14번째 주소에 해당 물리 주소가 존재함을 의미한다. 즉, 55(0011 0111)번째 Page에 해당 가상 주소가 매핑된다.</li>\n<li>offset은 그대로 간다.</li>\n</ol>\n<p>따라서, 가상주소 <code class=\"language-text\">11 1111 1000 0000</code>은 <code class=\"language-text\">00 1101 1100 0000</code>으로 변환된다! 가상 주소의 VPN은 실제 물리 페이지 번호에 매핑되고, 여기서는 해당 물리 페이지의 위치는 110111번째에 존재함을 Page Directory와 Page Table을 통하여 알 수 있다.</p>\n<h2 id=\"단점-1\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-label=\"단점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<p>실제 64비트 주소 공간을 효율적으로 사용하기 위해 4-level이 넘는 Page Table을 사용한다고 한다. 이에 복잡도가 증가할 수 있는데, 이로 인해 발생할 수 있는 문제점은 memory 접근 횟수가 많아진다는 점이다.</p>\n<p><strong>TLB miss가 난다면, 계층의 깊이만큼 memory에 access 해야하므로 느려질 것</strong>이다.</p>\n<p>오늘은 Page Table의 크기를 줄이기 위한 방법에 대하여 알아보았다. <strong>Page Table의 크기는 줄일수록 시간의 손해가 발생하거나(여러번의 memory 접근), 공간을 효율적으로 사용하지 못하는(fragment) 문제가 발생할 수</strong> 있다. 하지만 메모리 가상화를 통하여 얻는 이점(Process는 물리주소를 신경쓰지 않고, 독립적인 메모리 공간을 보장 받음)이 치명적이므로 메모리 가상화를 포기할 수는 없다.</p>\n<p>따라서 Page Table의 크기를 줄이는 것이 아니라, <strong>disk에 저장</strong>하는 <code class=\"language-text\">swap</code> 이라는 기법이 존재한다. 이에 대하여 다음에 알아보도록 하자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"November 18, 2023","title":"(OS) 운영체제 복습 [9-2. Multi Level Page Table]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(9-2)-Multilevel Page Table/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(10)-Swap space/","nextSlug":"/OS(9-2)-Multilevel Page Table/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}