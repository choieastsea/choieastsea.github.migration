{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(9-1)-Paging/",
    "result": {"data":{"cur":{"id":"8869d9e9-0598-5a31-9918-2c90927ba1e3","html":"<p>오늘은 <code class=\"language-text\">Paging</code> 기술에 대하여 알아보자. 저번까지 우리는 <code class=\"language-text\">base and bound</code> 방식으로 프로세스에게 메모리 가상화를 제공하고, <code class=\"language-text\">MMU</code>에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 <strong>internal fragment가 많이 발생</strong>하여 <code class=\"language-text\">segmentation</code>에 대하여도 알아보았다.</p>\n<p>segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 <strong>고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안</strong>된다.</p>\n<h1 id=\"paging\" style=\"position:relative;\"><a href=\"#paging\" aria-label=\"paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Paging</h1>\n<p>memory address를 여러개의 (비교적 작은) 고정된 크기의 <code class=\"language-text\">pages</code>로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 <strong>고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에 배치하는 것</strong>이다.</p>\n<p>예를 들어, Process의 address space는 아래와 같이 page로 나뉘어 물리 공간에 존재하게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+ElEQVQ4y4WT2W6jQBBF/f9/lEkyL85jlMiKwQ7xztpNAyaAV8wZVdvKMsqCdEVLiFt3qe5tNhuSJCFNU7TWxHFM0zT89HRd9y16URRxdfWH6+trbm//cnNzy3K5RGn9NigIAoIwJAwjtNI/DuvJT47jMBgMeHh4xHVHyJB1UWCMoa4r2ralPR5pTyeOwLE7cTge2W637HY7Cznv93t6osD3fZ6fn3FHI3vWYj/LSNKUsq7fx7ctXVlyUAlFEFA1jY1HINFJXL31eo3WitVqZS2KqrXjYCYTMt/nNY7p8hyCgC6OIc9oJAqlqKrqE6FE0yuKwpYhhFEckpqU0nXJ+n3yuzs2j490xpzLuAjdRBFmtaK+EAmhWA7D8Gx5Op0yHA4t5vM5KgxJ8xxdFJR5fibUmk5r8Dy2kwkmjr8mlNaExPM8XNdlsViglLKl5L5PlSRny/f3dP0+PD1RuS6pfKtrS1bX9WfLwjyZTvEDnyiOKB2H1/EYM5tSjkZ07giaxloWNHGEuZSy+ZChVZgoxWw2YzweMxw6Vq20W2QZhefxuli8ZcfpZJe32W3Z7ffW5v/oKXUu5OXlxZKufJ/U8zCDAWa5tGsjJMhN+NjMd4udZZnNTEjlbdKUaj5HK2WLqavq1+v26eqJzMPh8AbZ9vaLu/urtIvCf5ou22MG1zpkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"page\"\n        title=\"page\"\n        src=\"/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png\"\n        srcset=\"/static/9362b1135cf233e4857c9d4480f3d9a7/e9ff0/page.png 180w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/f21e7/page.png 360w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png 720w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/33e10/page.png 844w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>오른쪽은 가상 공간을 의미하며, 왼쪽은 실제 address space(AS)의 page가 물리적인 공간의 page frame에 배치되는 것을 의미한다.</p>\n<p>이렇게 고정된 크기의 페이지를 배치함으로써 external fragment를 줄일 수 있지만, page의 크기가 고정이므로 internal fragement가 존재할 수 있다. (하지만 하나로 배치하는 것보다는 적을 것임)</p>\n<h1 id=\"page-table\" style=\"position:relative;\"><a href=\"#page-table\" aria-label=\"page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table</h1>\n<p>위의 그림을 보면, virtual page는 physical page frame에 매칭이 된다. 이러한 매핑 정보는 <code class=\"language-text\">Page Table</code>에 저장하여 translation에 사용한다.</p>\n<p>예를 들어, page table에 3,7,5,2의 배열의 형태로 저장되어 있다면 해당 4개의 가상 페이지의 실제 page frame number가 3,7,5,2임을 의미한다. page table 역시 메모리 구조에 존재해야하므로 OS의 memory 공간에 저장되어, <code class=\"language-text\">MMU</code>가 접근할 수 있도록 한다. OS는 <code class=\"language-text\">context switch</code>가 일어날 때, page table의 값을 업데이트하여 관리할 것이다. (기존 PT는?)</p>\n<h2 id=\"page-table-entrypte\" style=\"position:relative;\"><a href=\"#page-table-entrypte\" aria-label=\"page table entrypte permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table Entry(PTE)</h2>\n<p>page table은 보통 배열의 형태로 존재하는데, 각 원소를 page table entry(PTE)라고 부른다. PTE의 인덱스는 VPN(virtual page number)를 의미하고, 값은 PFN(Page Frame Number), 즉 물리적인 위치를 포함한다.</p>\n<p>PFN 말고도 해당 Page Frame에 대한 추가적인 정보가 비트의 형태로 존재하는데, 다음과 같다.</p>\n<ul>\n<li>Valid Bit : 해당 page가 프로세스에 의해 사용되었는지? 가능한 address space에 비하여 실제 사용하는 페이지 수는 한정적이므로 유효한 페이지인지를 기록</li>\n<li>Protection Bits : R/W 권한</li>\n<li>Present Bit : page가 memory에 존재하는지 (swap space에 있는지?)</li>\n<li>Dirty Bit : 메모리에 적재된 이후에 해당 page가 변경된 적이 있는지</li>\n<li>Accessed Bit : 최근에 해당 page가 접근된적 있는지</li>\n</ul>\n<p>이러한 PTE의 값은 다음에 자세히 알아보자.</p>\n<h2 id=\"address-translation-in-hw\" style=\"position:relative;\"><a href=\"#address-translation-in-hw\" aria-label=\"address translation in hw permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address translation in H/W</h2>\n<p>가상 주소는 MMU에서 Page Table의 값에 따라 실제 물리 주소로 변경된다. 그 과정을 간단하게 알아보자.</p>\n<p>한 페이지의 크기가 16B이고, 가상 주소의 크기는 64B라고 가정해보자.</p>\n<p>저 두 단서로만 우리가 알 수 있는 조건은 다음과 같다.</p>\n<ul>\n<li>한 프로세스는 4페이지를 갖는다 (64 / 16 = 4)</li>\n<li>2^6B만큼 주소를 표현할 수 있어야하므로, 주소는 6비트로 표현 가능하다</li>\n<li>가상 주소에서 앞부분은 VPN을 의미하며, 뒷부분은 offset(page 안에서의 오프셋)을 의미하므로, 상위 2비트는 VPN을 의미한다(4개 페이지 존재하므로)</li>\n</ul>\n<p>PA로 변환하기까지의 그림은 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmUlEQVQ4y33U2W4iQQwFUP7/43jhBSHEFgj7DmGnRseSexgyiaXSrXLZt7x1157PZyHwfZHxeFxarVZ1vt/vgdPptDQajbLf7+P8eDwCa0n2Lgw+Pz9Lt9stzWazfHx8xN4Do9Go9Hq9IKRnBxeLRam9vsx4MpnExel0itePx2Ps4Xa7jfX19VWu12vod7tdZXc4HP4SQkTL5bKsVqtwYsjBYgzX63U4u0funPf0P6ZMGEkPMUQgCwTO5/O5DAaDIOr3++V2u/0boaV2DJUA0XA4jNQ4wvl8HukqDXHPD1ZNeY0SmcgyBYiYHpmyXC6XilAzPA5/JCRqqXudTie6S34j/DVCNYLZRVFqArJ3QkTfCNUt65fDrHtIs4aJs9ksasiGqC3fKuX/dViqIlE7hqKEuowYOntAOWSgNNFlBJQ+JWlw1gxk0rR/1W02m2rYc9DzvppDrxlmaeagpqPX6ThqlMiTIHV5T/8tZWFnN6VnYO1lYJgRqKPle2ZrOQui9v6nye86h7XdbscjGmbZZ+Pq9XpkloHw+QOs+IEATb9oaAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png\"\n        srcset=\"/static/1298585682d7000b228ce325b1aa32a9/e9ff0/VA.png 180w,\n/static/1298585682d7000b228ce325b1aa32a9/f21e7/VA.png 360w,\n/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png 720w,\n/static/1298585682d7000b228ce325b1aa32a9/4ef49/VA.png 890w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 VPN은 MMU에서 PFN(Page Frame Number)로 대체되어 물리 주소 값은 PFN + offset로 구성될 것이다.</p>\n<p>예를 들어 가상 주소가 010101이라면, 해당 주소는 프로세스의 1번째 페이지 중 5번째(0101 = 5)에 위치해있을 것이다. 0번째 페이지의 실제 위치는 Page Table의 0번째 줄을 보면 알 수 있다.</p>\n<p>이를 통하여 하나의 Page Table에는 4개의 <code class=\"language-text\">PTE</code>가 존재한다는 것도 유추할 수 있다. 또한, 물리주소의 PFN이 3비트인 것으로 보아, 해당 시스템에서는 가능한 Page Frame이 8(2^3)개 라는 것도 유추할 수 있다.</p>\n<h2 id=\"page-table의-단점은-없는가\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%80-%EC%97%86%EB%8A%94%EA%B0%80\" aria-label=\"page table의 단점은 없는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 단점은 없는가</h2>\n<p>정리하면, 메모리 주소가 변환되는 과정은 다음과 같을 것이다.</p>\n<ul>\n<li>CPU에서 코드, 데이터 등이 위치한 가상 주소를 보고 요청한다.</li>\n<li>MMU는 VA를 PA로 바꿔준다.\n<ul>\n<li>memory에 위치한 Page Table을 보고, VPN을 PFN으로 바꾸어 Physical Address를 얻는다</li>\n<li>실제 메모리에 접근하여 코드나 데이터를 fetch해온다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"속도-overhead\" style=\"position:relative;\"><a href=\"#%EC%86%8D%EB%8F%84-overhead\" aria-label=\"속도 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속도 overhead</h3>\n<p>이와 같이, 실제 물리 주소를 접근하는 과정에서 VA를 PA로 바꾸고, 이 과정에서 overhead는 발생할 수밖에 없다. Page Table역시 메모리에 존재하므로, 메모리에 두번씩이나 접근해야하는데 이는 썩 좋은 방법은 아닌 것 같다.</p>\n<h3 id=\"공간-overhead\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84-overhead\" aria-label=\"공간 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간 overhead</h3>\n<p>또한 페이지 테이블의 크기는 작지 않다. 과거 자주 쓰이던 32bit 주소 체계에서는 보통 20bit은 VPN, 12bit는 offset으로 구성된다. 이 경우, Page Table Entry(PTE)의 갯수는 프로세스 하나당 2^20개가 필요하다. 보통 한 PTE에 4B를 차지한다고 한다면 4*2^20Byte, 즉 하나의 프로세스 당 주소 변환을 위하여 2^22 = 4MB의 공간이 필요하게 된다.</p>\n<p>최근 사용하는 64비트 주소 공간에 대하여 생각하면 페이지 테이블 하나만 저장하기 위해 GB 단위 이상을 사용해야할 것이다…</p>\n<p>그렇다면, 이를 개선할 방법은 없을까?! 속도를 개선하기 위해서는 VA-PA 쌍을 캐싱해두는 방법이 있다. 사이즈를 개선하기 위한 방법은 다음에 알아보고, 우선 caching을 통하여 속도를 개선하는 <code class=\"language-text\">TLB</code>에 대하여 알아보자.</p>\n<h1 id=\"translation-lookaside-buffer-tlb\" style=\"position:relative;\"><a href=\"#translation-lookaside-buffer-tlb\" aria-label=\"translation lookaside buffer tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Translation Lookaside Buffer (TLB)</h1>\n<p><code class=\"language-text\">MMU</code>에서 <code class=\"language-text\">PTE</code>를 일부 캐싱해놓는 곳을 <code class=\"language-text\">TLB</code>라고 한다. (TLB는 MMU의 일부이다) 자주 참조되는 PTE를 저장해놓는 소형 <u>하드웨어 캐시</u>로, <code class=\"language-text\">address-translation-cache</code>라고도 불린다.</p>\n<p>기본적으로 VA에서 PA로 전환하는 과정에서 memory가 아닌 <code class=\"language-text\">TLB</code>를 먼저 보고, TLB hit이 발생한다면 page table에 접근하지 않아도 된다! 하지만, TLB miss가 발생한다면 메모리에 다시 접근해야하므로 **지역성(locality)에 근거한 캐시 정책(LRU 등)**이 활용될 수 있을 것이다.</p>\n<p>또한 TLB는 MMU에 존재하는 캐시이므로, <code class=\"language-text\">context switching</code>이 발생하는 경우에는 기존 entry를 비활성화하고, 새로운 page table의 PTE로 교체해야할 것이다. 이를 위해 <code class=\"language-text\">TLB valid bit</code>를 사용한다. (이는 PTE의 valid bit와 다르다!)</p>\n<h2 id=\"page-table의-크기를-줄이는-방법\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%ED%81%AC%EA%B8%B0%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"page table의 크기를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 크기를 줄이는 방법?</h2>\n<p>TLB는 page table의 단점 중 하나인 시간 overhead는 줄일 수 있는 HW적인 방법이다. 하지만, 공간 overhead를 줄이기 위해서는 어떻게 해야할까?</p>\n<p>가장 간단한 해결책은 <strong>page 하나의 크기를 늘리고, entry를 줄여 page table의 크기 자체를 줄일 수 있을 것</strong>이다. 페이지가 n배 커질수록, page table의 크기는 1/n배로 줄어들 것이다.</p>\n<p>하지만, 이는 앞서 연속된 하나의 주소 공간을 제공하던 방법과 마찬가지로 <code class=\"language-text\">internal fragmentation</code>(내부 단편화)의 문제가 발생하여 메모리 공간 부족이 나타날 수 있다.</p>\n<p>이를 해결할 수 있는 몇가지 방법이 있는데, paging과 segmentation을 결합한 <code class=\"language-text\">hybrid approach</code>, 그리고 <code class=\"language-text\">multi-level page table</code>기법이 제안된다. 이는 다음에 자세히 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"오늘은  기술에 대하여 알아보자. 저번까지 우리는  방식으로 프로세스에게 메모리 가상화를 제공하고, 에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 internal fragment가 많이 발생하여 에 대하여도 알아보았다. segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안된다. Paging memory address를 여러개의 (비교적 작은) 고정된 크기의 로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에…","frontmatter":{"date":"October 30, 2023","title":"(OS) 운영체제 복습 [9-1. Paging]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(9-1)-Paging/"}},"next":{"id":"dbf838fa-a84b-5baa-8fd9-b484a510bf52","html":"<p>MMU에서 Virtual Address에서 Physical Address로 변환되는 메커니즘을 간단한 함수의 실행과 함께 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span>\n\tx <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 함수가 실행되는 프로세스를 생각하면 OS는 아래와 같은 address space를 제공할 것이다. (프로세스마다 기본적으로 16KB만큼을 할당해준다고 가정하자)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 296.6666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAA7CAYAAAB7c6ruAAAACXBIWXMAABYlAAAWJQFJUiTwAAADwUlEQVRYw9WY107rQBCG8/4vA5FAcAGIqoQuWoDQe++9ztE3R7+12diJUy7OWWlke8u/U3dnXNjf37fd3V0rlUrG+/v7u93e3trj46Pd3Nw4XV9f2/39vRNjd3d39vT0lPRBzPv8/LTC2dmZnZ+f28rKis3Pz9v09LRtb2/b2tqabWxseN/i4qLNzc3ZwsKCXV1dJfOen5/t9/fXaGzw+vpqBQvaxcWFTU5O2t7ens3OzjooQHC+vr7ufQDSvr+/w6X28vLyF/Dj48MgxICzqakp29zctKWlJX/OzMw48NHRkU1MTLgkcL6zs2Nvb2/1gOgHHfb19TnI6emp64l+RLq8vLSTkxNfQB9jx8fHhqrQWR0gOvj5+XEuaRgjFIcx2tfXl/eLK/r5lg7ZvE6HNEQPARFbhuJ9aGjIDg4OXBVwqcZGDoiITMBt6MQFAGVHLIcRWIjBEB+iD8/gyRzEZZw1BfRzeHjoXAjw4eEh2RG/bESA8US/vKeKLL210hKRsRQEOg0OZT0ULtIiGSUeS4yytbXlvlUsFl0fUAgYWnp1ddXnpgEmbiMd4F8sbMQh85py2HUdYmVchwMA59bpAefsGpJUEvcBhDu521SrVQ+9sbExH4BDNmECvgXhc7gSrjUyMuLRJN+UP3KgAF4nss4/AMQtm8A9UoyPj7uO0bnGtIFzKMVKb0xkR02G2IRYHhwctJ6eHn9nU8aYz+ZIVQMoa7E4BoTQqdyGhTq5IQCxgwNK1CzA8OiXEUKwlgBjLgGKwaTDhoC6lOKFWdSQQ53WeQA1p8Yo7QKG4w0B84gcjzUFTHObLLA6P0wTOQswra8pYBaHWRwLMLdjNwJrO1I68sOsSFGUpEVLy5HCOzEMJzwB4L2tSOHJWcdJQxbGkwwCAIHmjhQlnpzo5XLZU7rR0VHPE0lNGGvbD1kESdxY5LYjpWuO3SxSWnLs/z9Scjt2XsN07U4Jr4CO75RQgo7vlFgdHV8B8Sn070RKHMMdRQqLOMZ0bOmQrQPMk32pFu7v77fe3t7UdK6GwxCQCQDExxQJJ3Uyma4STiWlnOJJwhkXiYDFKTGTWUwtPTAwkABovCYlZlfybIrC5eVl54zaWPkzxGI24OSmruFdfwLCMQdULNKpiyiu1lsqK5qVt6F+w5ZZ+FQqFZefi4cSl1wa9qmHsZwaRmEepQWGiDer+UUAUTNzTcqqKJoJalgWg6Fb9acCdqs0SwBVMsCR/IoiUf8UeIr4Tuur+W/DnxBqj+HhYf8vwwT9/chLUhF6/gOys5fZzublKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png\"\n        srcset=\"/static/23122becc17c9e94b52ff2a3983884a3/e9ff0/VA.png 180w,\n/static/23122becc17c9e94b52ff2a3983884a3/f21e7/VA.png 360w,\n/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png 436w\"\n        sizes=\"(max-width: 436px) 100vw, 436px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>x 변수는 stack영역에 저장되고, 컴파일된 명령어는 code 영역에 존재할 것이다. 이 과정에서 Address Translation이 어떤 식으로 이루어질지 생각해보자.</p>\n<h1 id=\"dynamic-relocation\" style=\"position:relative;\"><a href=\"#dynamic-relocation\" aria-label=\"dynamic relocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Relocation</h1>\n<p>이러한 주소의 배치는 프로세스 실행 이후에 address space가 변경될 수 있으니, dynamic relocation(동적 재배치)라고 불린다.</p>\n<h2 id=\"base-and-bound-하드웨어-기반\" style=\"position:relative;\"><a href=\"#base-and-bound-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B8%B0%EB%B0%98\" aria-label=\"base and bound 하드웨어 기반 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>base and bound (하드웨어 기반)</h2>\n<p>가장 단순한 방법으로는 위의 <strong>프로세스의 메모리 공간을 그대로 연속적인 하나의 물리적 공간에 매핑시키는 방법</strong>이 있을 것이다. 16KB가 연속적으로 남는 공간을 찾아서 그곳에 프로세스의 공간을 할당하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 143.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAADM0lEQVRIx42V505qURCFef9n8B8J0WDAoCRKIKBiw9ARFRsWilJERbHh3HxzM+QcDhpOsrMLe69Zs6bge3t7k1arJf1+X+z7/v6Wr6+vucbPz4++sdnXbDYlHo9LoVDQg+FwKNvb23JwcCD7+/u/Dn7n3vn5ub4bj8f/AY2VWXh6epKdnR2pVqtSLBalVCpNRrlcdq2z2awcHx+7AQGyYYC7u7tSqVTk5ORETk9P9REzIKw5r9VqksvldD0XYCQSEb/fL8vLyxIIBCQYDEooFJLFxUVZWlrSPfcA9gCyIRBOQDRC21QqJZubmxKLxVSzRCIhyWRStra2JJPJKPOZGtoHIKJjmcs22JsEtieQHpefn5/1kEA8Pj7K6+urssD6PFEmeC5AALB4eHgog8FAAblIJPP5vLJgtrUNMgCjnijPcpncYibZYY0h1ra3cX9/L1dXV+7Eng4KEmC12+0KSX99fa3j9vZWGo3GZH54eND15eWlG3A6sU1T2PCA6BJtJEmn07KysqIu8/vd3d0EEFJgTPLQNDDAXq8n7XZb3YINs+2pfc6cgPbN1BBAXDaATqejgzOnAafLaIo0Pn4kcdfW1hRgNBppROv1ulxcXOgDNCXqRJY95wQDw5aHvCWdfACwQWjWtDMeoRHGiDBVsbCwoGXIXZgaW1jxjrsQ8bhM+4IdQOiIKxhYX19XBpxZClmkPz4+VFfy2RMUEhuweT8YAwjTs7Mzb7eBoZUW7YlqsGqhfik1ZnSkicD+8/NTc5a7M10mHWD68vKibEl6XOfh+/u7DrTGfbSHITO5qgz5bwCANbMBkkLMlOLe3p5GFAOck6+s0RBw0oos0LSJRqMSDodVWCIGdR4fHR3pTP+jsa6urmonJ40slZjRH2B1GXegzLBKQSOsYxWDRBRWdkbK4C4ELLGZ0ffPSiHPAOMxwJyhpRlyVgrEYOqJ8nRzoPGiH/oQbdyHCUactexqX781ByJnzRQZ+NdDJ/INtk6Gk24z7bJpaK6ZdtZorfECiIaeBkveYQkQwk/ukcQ3NzeTRsA8PShPPIGt6y+ADEejjY0NLSM+wNDnr4Ec3LMyNYb/ACBSX4dpGsZ3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseandbound\"\n        title=\"baseandbound\"\n        src=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png\"\n        srcset=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/e9ff0/baseandbound.png 180w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/f21e7/baseandbound.png 360w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 경우, 두개의 레지스터 값만 유지한다면 간단하게 VA와 PA간 변환이 가능하다. 해당 프로세스는 32KB에서 시작하고, address space의 크기는 16KB이므로, <code class=\"language-text\">base</code> 레지스터에 32KB, <code class=\"language-text\">bound</code> 레지스터에 16KB의 값을 갖고 있도록 하자. <u>각각 시작주소와 프로세스 주소 공간의 크기를 의미</u>한다.</p>\n<p>그렇다면 <code class=\"language-text\">MMU</code>(Memory Management Unit)에서  <code class=\"language-text\">PA = base + VA</code>로 변환해줄 수 있을 것이다. 만약 VA가 bound인 16KB보다 크거나 0보다 작다면 에러가 발생하도록 하면 된다.</p>\n<h3 id=\"role-of-hardware-in-translation\" style=\"position:relative;\"><a href=\"#role-of-hardware-in-translation\" aria-label=\"role of hardware in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of hardware in translation</h3>\n<p>주소 변환에서 하드웨어의 역할이 무엇인지 정리해보자.</p>\n<ul>\n<li>CPU는 <code class=\"language-text\">privileged mode</code> (<code class=\"language-text\">kernel mode</code>)를 제공해야 운영체제가 접근권한을 갖도록 할 수 있다.</li>\n<li>하드웨어는 base &#x26; bound 레지스터를 제공하며, CPU당 한쌍이 필요하다. 이를 통해 <strong>주소 변환과 범위 검사를 수행</strong>하며 <strong>오류 발생시에는 예외를 발생</strong>시킨다. 또한 <strong>레지스터 값을 변경하는 특권 명령어를 제공</strong>해야한다. 프로세스마다 각 레지스터 값들은 다르므로, 변경이 필요하며 이는 특권 모드에서 일어나야하기 때문이다.</li>\n</ul>\n<h3 id=\"role-of-os-in-translation\" style=\"position:relative;\"><a href=\"#role-of-os-in-translation\" aria-label=\"role of os in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of OS in translation</h3>\n<p>그렇다면 운영체제에서 <code class=\"language-text\">dynamic relocation</code>을 지원하기 위해 해줘야 할 일은 뭐가 있을지 알아보자.</p>\n<ul>\n<li>프로세스가 실행될 수 있는 유휴 메모리 공간인 <code class=\"language-text\">free list</code>를 관리한다. 위의 예시에서는 16<del>32KB, 48</del>64KB 영역이 free list에 있을 것이다.</li>\n<li>프로세스가 시작할 때 메모리 공간을 할당해주고, 종료할 때 이를 정리해준다.</li>\n<li>context switching 발생시, <code class=\"language-text\">PCB</code>에 실행중인 CPU의 <code class=\"language-text\">base</code>와 <code class=\"language-text\">bound</code> 레지스터 값을 저장해주거나 이전 레지스터 값을 복원해줘야 한다.</li>\n<li>하드웨어 예외 발생시, error handler를 통하여 조치를 취해야 한다. 보통 OS는 해당 프로세스를 종료함으로써 자원을 보호한다.</li>\n</ul>\n<h2 id=\"segmentation\" style=\"position:relative;\"><a href=\"#segmentation\" aria-label=\"segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segmentation</h2>\n<p>base and bound 방법은 비교적 간단하지만 내부 단편화(<code class=\"language-text\">internal fragment</code>)가 발생할 수 있다는 단점이 있다. 위의 그림들을 보면 프로세스에게 할당이 되었지만 사용중이지 않은 heap ~ stack 사이의 빈 영역이 존재하는데, base and bound 방법은 이러한 내부 단편화가 일어날 수 밖에 없는 구조이다. 고정 크기를 각각의 프로세스에 할당하므로 <strong>한 메모리에서 실제 사용하는 용량에 비해 실행시킬 수 있는 프로세스의 수는 적을 것</strong>이다.</p>\n<p>예를 들어, 32bit 주소 공간을 갖는 체계에서 하나의 프로세스는 무려 2^32byte = 4GB의 공간이 필요하게 된다… 하지만 실질적으로 프로세스에서 필요한 메모리의 크기는 MB단위일 것인데, 불필요한 부분들이 너무 많아 지게 된다.</p>\n<p>따라서 address space를 보통 <strong>heap, stack, code segment로 나누고, 이렇게 생긴 여러개의 (base, bound)를 MMU에 각각 두어 일반화</strong>한 방식인 <code class=\"language-text\">segmentation</code>이 제안된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVQ4y52U2W/aQBCH/Z9XfWikSonI2b72oXlppVZV1CoVRwI0AQJJzH0Ggy/A2AYCGDDHr5oFEwdVSuhIox0f++3M7MxwuiZAEhKQa/eQa3dMpdodVIlHNsNDFCXY9gTtdhuGYTAlW9d19Pv99TPZnU4HXD75C9HAe8SD+7i59DCNBz2IBvbQUEog6Xa7yOVyyOfzKJfLqFQqKBQKGI1G0DQN6XQalmWxQ7hyzoew14PrwAmuA8eIXJzgyn+M6MUxTENaAwkiiiKD0OrYqqqiVqthMpmg1WqBK2V9CP7eQ9h75NJDRAJHMHVxCex0GFCWZQwGAwYgHY/HDFiv15+AhfQ5Yhe7SIQOEQ8eME2EDhC73EdTrWCxWHpYLBYZhEKjVRCENZBs27ZZ+JwqlyEKt5DrPBQxyVSiC6rzeKgUWd5M02SrJElrYLVaZV65gc1mE5xtT1lY8xkwHtsYj2w4MpksbQqTAI1GA4+Pjyx/BKGbJSAdRN7SwVyjrUM2TIiajlxVQFlSIOsmpLaOXn+wPGw+Z+twOEQqlUKpVGJAnueRzWZZ7qbTKWazGbirwgM+R5L4Gs/gkzeM03AcXxJZnEZ4NMwuAy0okSshuPPsth3hur0e+pYFtaVBlBWmbbODgWWhpWksL46H7s2btqPct5sUdn6G8NEfxaE3gt3zP/jgj7J3iVwRiiSyUDY3bqrznfueyODNWQgeXww7P/x4d3aJXV8Mb8+CEDRjGZpr00vCVZQmbmsK7usKQnwGkWwR93UVd4IEo9t7Ft5roNzYsp4SPp0Czqb5HFPbfhbqqzwcroDu3xerMGmK0KVs5aG1AlIdUeWTOrdKBUzT5V+3/CKQirbX67G+pTYiCB2ydciWK4duoVKhb+7i3crDzZ//20NqcIJSc9NKQ5NsyiX1ayaT2S6H9BPNumQyycY6NTuNdBrnlEvK6TYh/wVtti9w5MDjCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"segmentation\"\n        title=\"segmentation\"\n        src=\"/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png\"\n        srcset=\"/static/99d8bbe29d2c10911c0c29ed5429333e/e9ff0/segmentation.png 180w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/f21e7/segmentation.png 360w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png 720w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/302a4/segmentation.png 1080w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/525d3/segmentation.png 1090w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리 공간을 코드, 힙, 스택의 3개의 segment로 분할하고, 각각 base, bound, 순방향 증가 여부(<u>스택의 경우, 역방향으로 증가하므로</u>)를 기록하여 segmentation을 간단하게 구현할 수 있다. 순방향 증가 여부의 경우, translation 과정에서 stack영역은 반대 방향이므로 다르게 계산해줄 필요가 있으므로 알 필요가 있다.</p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>하지만 이 방법은 내부 단편화는 줄일 수 있어도, 각 segment 사이의 작은 빈 공간이 많이 존재하게 되는 외부 단편화 (<code class=\"language-text\">external fragment</code>)가 발생할 수 있다는 단점이 존재한다. 이를 해결하기 위해 물리 메모리를 한 곳으로 몰아서 압축하는 방법이 제안되기도 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFklEQVQ4y22UV4uyMRCF/f+/QfBKEKzghcJe2MCCdS14Ifburr3XWZ5ZRvaDLxCSTE7OnDnJ+zqez6dcLhdhtDaZTGQwGMjxeHzH2L9er//g5vO59Ho92W6375gDEATr9VpqtZp8fn5KOp2WXC4nxWJRyuWytNtteTweb1yj0ZBKpSKZTEZxpVJJz9Xr9V9CQKvVSmKxmESjUfH5fOJ0OiUUCkkkElFilIEBm0wmFRcIBMTlconX65WPjw9JJBK/hAaMx+MK8vv94na7lRhS1EC4XC61vFQqJcFgUPfBeTweCYfDGnfgH15Mp1OVns/ntRcKBVWWzWal2WxqyYvFQnFYgxUkolQ6a0bH7XaTzWajKhnpo9FIfcIzFLEHoeFer5f8ryHOcTqdZDabydfXlxwOB71ZlEAKGbHdbqc3TCXsQU7jLAkQRePs20P8YQ6YBNwsAMA2gvv+/n4TWjWcswTqIWQAUYmKbrcr1WpV+v2+xuj3+/2N+/sW/zYlJLuVzCHArDudjgJQw3g+nzVOyVhAxxI68/1+r8lUIdJ5NraBEhLYQfbt8uzNMrKG0OIkc2A6PrCwDdY8FZ6IxVA4Ho9Vpb0G7BkOh3oWYiVEoV0KqghyCFIIWVOKXQo4U0eCVqulI5Uood0yHQ9pEPNzsJ8BHkII0V9CVGGRla2EBPhjsIDAvm1IIaICymUOzmwwESSwOZfyA811WsxGLfJSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compact\"\n        title=\"compact\"\n        src=\"/static/3491ec2ae9efa9381131014955213c91/37523/compact.png\"\n        srcset=\"/static/3491ec2ae9efa9381131014955213c91/e9ff0/compact.png 180w,\n/static/3491ec2ae9efa9381131014955213c91/f21e7/compact.png 360w,\n/static/3491ec2ae9efa9381131014955213c91/37523/compact.png 720w,\n/static/3491ec2ae9efa9381131014955213c91/84ee5/compact.png 1076w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 파편화된 외부 미사용 공간들을 압축하는 방법은 overhead가 큰 연산이므로 비용이 많이 든다. 이에 운영체제는 (미사용) 공간을 관리하는 알고리즘을 이용할 수 있는데, <code class=\"language-text\">best-fit</code>, <code class=\"language-text\">worst-fit</code>, <code class=\"language-text\">first-fit</code>, <code class=\"language-text\">buddy algorithm</code>등이 존재하며 압축을 최소화하면서 상황에 맞게 최선의 방법을 선택할 수 있을 것이다.</p>\n<p>또한 segmentation은 유연하지 못하다는 단점이 있다. 힙, 스택, 코드의 3 영역으로 나눈다고 해도 각각은 모두 연속적으로 존재해야하므로 유연성이 떨어진다. 이에 <code class=\"language-text\">Fine-grained</code> 와 <code class=\"language-text\">Coarse-grained</code> segmentation이 제안되는데, 조각이 많아진다면 유연성은 증가하지만 레지스터값들이 그만큼 늘어나므로 관리가 어려워질 수 있다.</p>\n<p>다음에는 이에 해결책이 될 수 있는 <code class=\"language-text\">Paging</code> 기법에 대하여 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"October 29, 2023","title":"(OS) 운영체제 복습 [8. Mechanism of Address Translation]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}},"prev":{"id":"e08fbfa3-135f-57f0-8191-3c0897ac61ae","html":"<p>저번시간에는 메모리 가상화에서 Paging 기법에 대하여 배웠다.</p>\n<p><strong>고정된 크기의 Page로 주소 공간을 분할하고, 이를 물리 메모리의 남는 자리에 배치하여 가상 주소공간과 물리 주소공간을 Page Table을 통하여 매칭하는 방법</strong>이다.</p>\n<p>하지만, page table은 기본적으로 memory 공간에 있으므로 시간적으로 느려져 주소를 전환하는 <code class=\"language-text\">MMU</code>에 <code class=\"language-text\">TLB</code>라는 캐시를 두어 하드웨어적으로 속도를 향상시킬 수 있는 방법이 제안되었다.</p>\n<p>또한 page table 자체의 크기(+대부분은 invalid/unused 상태인채로 비어있음)도 무시할 수 없으므로 이를 줄일 수 있는 방법이 제안되었는데, 오늘은 그 방법에 대하여 다뤄보자.</p>\n<h1 id=\"1-bigger-pages\" style=\"position:relative;\"><a href=\"#1-bigger-pages\" aria-label=\"1 bigger pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Bigger Pages</h1>\n<p>가장 간단한 방법으로는 Page Frame 자체의 크기를 늘리는 방법이다. 이를 통해 Page Table Entry(PTE)의 갯수를 줄여 Page Table의 크기를 줄일 수 있을 것이다.</p>\n<p>32bit address space에서, Page Frame의 크기를 4KB에서 16KB로 늘린다고 가정해보자. 16KB = 2^14B이므로, 주소 공간을 18비트(VPN, virtual page number), 14비트(offset, 페이지 내부에서의 위치)로 나눌 수 있을 것이다. PTE의 크기를 4B라고 했을 때, Page table의 크기는 4B*2^18 = 2^20B = 1MB가 될 것이다.</p>\n<p><strong>즉, Page Frame의 크기를 n배로 커질수록 Page Table의 크기는 1/n로 작아진다.</strong></p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>그럼 페이지의 크기를 크게 하는 것이 능사일까? 절대 아니다!</p>\n<p>Page이전에, 연속적인 하나의 물리 공간을 제공하는 경우에는 <strong>internal fragment</strong>(내부 단편화), 즉 사용되지 않는 공간을 할당하여 낭비가 생기는 문제가 생겨 많은 프로세스가 실행되기에 어렵다.</p>\n<p>이에 실제 사용되는 컴퓨터 시스템에서는 4KB 또는 8KB의 페이지 크기를 채택한다고 한다.</p>\n<h1 id=\"2-hybrid-approach--paging--segmentation\" style=\"position:relative;\"><a href=\"#2-hybrid-approach--paging--segmentation\" aria-label=\"2 hybrid approach  paging  segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Hybrid Approach : Paging + Segmentation</h1>\n<p>Page의 크기는 고정하면서, Page Table의 크기를 줄이는 방법에 대하여 알아보자. 가장 간단한 방법은 기존 <code class=\"language-text\">Segmentation</code>기법과 <code class=\"language-text\">Paging</code>기법을 결합하는 방법이다.</p>\n<p>프로세스의 메모리 공간은 크게 code, heap, stack 영역으로 구성되는데, <strong>각각을 하나의 Page Table로 할당</strong>한다. 따라서 하드웨어적으로 3개의 base register와 bound register가 필요하고, 이는 <u>Page Table의 시작점과 범위를 가리킬 것</u>이다.</p>\n<p>이 방법은 전체 영역을 하나의 Page Table로 두는 대신, segment 단위로 page table을 두므로 stack과 heap사이의 큰 빈 영역을 사용하지 않는 효과를 볼 수 있다.</p>\n<p>예컨대 32비트 주소공간에서 가상 주소는 다음과 같이 처리될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAW0lEQVQI102NSwoAIQxDvf/BXHkGRYt/PUMkgYFZhKYvKXW1VvTe0VrDGEOeSimJrbXE55ya7JNxv/finIO9N0op4s7MdMgiRZ9zRghBpX9GxRjFPvEJ+957ZQ+6JpLvbA+UnwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hybrid\"\n        title=\"hybrid\"\n        src=\"/static/3f040b7b522862642412379ead8a9309/37523/hybrid.png\"\n        srcset=\"/static/3f040b7b522862642412379ead8a9309/e9ff0/hybrid.png 180w,\n/static/3f040b7b522862642412379ead8a9309/f21e7/hybrid.png 360w,\n/static/3f040b7b522862642412379ead8a9309/37523/hybrid.png 720w,\n/static/3f040b7b522862642412379ead8a9309/302a4/hybrid.png 1080w,\n/static/3f040b7b522862642412379ead8a9309/07a9c/hybrid.png 1440w,\n/static/3f040b7b522862642412379ead8a9309/0f586/hybrid.png 1498w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>상위 2비트의 Segment 영역은</p>\n<ul>\n<li>00 : unused</li>\n<li>01 : code</li>\n<li>10 : heap</li>\n<li>11 : stack</li>\n</ul>\n<p>영역을 의미한다고 하면 모든 세그먼트를 처리할 수 있게 된다.</p>\n<p>상위 2비트로 어떤 segment인지 결정하고, 이에 해당하는 base&#x26;bound register를 얻는다. 이를 통하여 VPN을 PFN으로 변환하여 물리 주소를 얻고, 유효한 범위인지 확인하는 방법으로 address translation이 이루어질 것이다.</p>\n<p>이 방법을 이용하는 경우, Page Table의 크기는 사용되는 공간만큼만 필요하고 이를 bound register로 검증할 수 있으므로 메모리 절약에 큰 효과가 있을 것이다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<ol>\n<li>\n<p>external fragment</p>\n<p>해당 방법은 Page의 크기는 같지만, Page Table의 크기가 달라진다. 따라서, 외부 단편화가 발생할 수 있다.</p>\n</li>\n<li>\n<p>heap공간의 특징</p>\n<p>heap공간은 stack과 다르게 순서대로 데이터가 쌓이지 않고, memory 관리에 의하여 sparse하게 데이터가 저장되고 우리는 각 변수별 포인터를 갖고 있는다. 이러한 <strong>sparse used 구조는 page table의 낭비</strong>를 일으킬 수 있다.</p>\n<p>stack의 경우에는 런타임에서 LIFO 형태로 순서대로 쌓이므로 Stack Pointer를 두기에 이러한 단편화를 고려하지 않아도 된다.</p>\n</li>\n</ol>\n<h1 id=\"3-multi-level-page-table\" style=\"position:relative;\"><a href=\"#3-multi-level-page-table\" aria-label=\"3 multi level page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Multi Level Page Table</h1>\n<p>기존에 address translation에 대한 정보를 담는 PTE가 저장되어 있는 방법을 <code class=\"language-text\">Linear Page Table</code>이라고 한다. 이를 트리 구조로 표현한 것이 <code class=\"language-text\">Multi Level Page Table</code>이다. (이에 기존 방법은 Single level PT라고도 부른다)</p>\n<p>핵심은 Page Frame 여러개를 하나의 묶음으로 놓고, 이것들을 관리하는 outer page table인 <code class=\"language-text\">Page Directory</code>를 두어 관리하는 것이다. 기존에는 여러 page frame을 하나의 page table로 두었지만, 이 방법은 몇개의 page frame을 하나의 묶음으로 보아 이 묶음을 Page Table에서 관리하는 것이라고 보면 된다.</p>\n<p>간단하게 말해, Page Table을 Paging한다고 보면 된다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABZklEQVQoz22Si66CQAxE+f+PI0EwCEZF5KX4RFDxQc3pzZq9CZs0q7QznWnX6ftedrudbLdbjfv9Lua8Xi+pqkr2+73e5B+Ph+aGYRgNpygKOZ/PkiSJnE4nadtW3u+3RpqmUte1ULPZbLTudrspcOwo4eFwEAIi1KLKqEQNTSDpuk6/GULq8jzX227iYMX3fVkulxKGodoz4KZpZD6fq9IgCLTx5XLRxjRyXVeVg4eH705ZllqcZZms12stIMEhZ5qgBsuoRg2OPM/TcYBjZAhx6A4IMEHCEGJ9tVrJbDaT6XSqOQjJQ04TMNwoxLoSxnGsm0YJoOfz+Rv05/PR/8yKQB1ANo5txgAWYsahhFEUaQEbtQnHtkkDCM0ywUBIMAYHgsViIcfj8fd8bEI7bEIzInAEs7xer3/vkPlwm/dmZmgrNL+5eaPYm0wm/3CqENlY5gPbQjqAMcu2UjbKssDhileCsy949kVqSNTjAwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mlpt\"\n        title=\"mlpt\"\n        src=\"/static/564f32ebea90426036bb5165c262ce59/37523/mlpt.png\"\n        srcset=\"/static/564f32ebea90426036bb5165c262ce59/e9ff0/mlpt.png 180w,\n/static/564f32ebea90426036bb5165c262ce59/f21e7/mlpt.png 360w,\n/static/564f32ebea90426036bb5165c262ce59/37523/mlpt.png 720w,\n/static/564f32ebea90426036bb5165c262ce59/302a4/mlpt.png 1080w,\n/static/564f32ebea90426036bb5165c262ce59/07a9c/mlpt.png 1440w,\n/static/564f32ebea90426036bb5165c262ce59/a2792/mlpt.png 1462w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 그림은 Linear Page Table과 2-level Page Table의 구조를 비교해볼 수 있는 그림이다. 한 Page에 4개의 PTE가 들어가는 상황으로 가정하자. (실제로는 한 Page에 더 많은 PTE가 들어갈 것임)</p>\n<p>기존 Linear에서는 16개의 PTE중 5개만 사용중이므로, 11개는 할당되었지만 invalid하여 낭비되는 상태이다.</p>\n<p><strong>이에 PTE를 담는 Page를 Entry로 두어 Page Directory에서는 사용중인 Page만 관리하는 것</strong>이 <code class=\"language-text\">Multi Level Page Table</code> 방식이다.</p>\n<p>위의 예시에서, 12,13,15,86번 Page Frame이 Process를 위해 사용중이고, Page Table Entry를 위하여 201,204번 Page Frame이 사용중이다. Page Table Entry를 위한 Page Frame을 Page Directory에서 관리하고, 해당 Page Frame에서는 실제 PTE를 갖고 있도록 한다. 이를 통하여 Page Directory는 <strong>사용하지 않는 Page Table의 공간을 줄일 수 있다</strong>.</p>\n<p>좀 헷갈릴 수도 있어 다시 정리해보면,</p>\n<p>Page Table의 크기를 줄이기 위해 (PTE도 역시 특정 Page Frame에서 관리되므로) <strong>사용중인 PTE가 있는 Page Frame만 Page Directory라는 곳에서 관리하는 것</strong>이다.</p>\n<h2 id=\"address-translation\" style=\"position:relative;\"><a href=\"#address-translation\" aria-label=\"address translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address Translation</h2>\n<p>그렇다면 2-level 에서는 주소 변환이 어떻게 이루어질까?</p>\n<p>간단하게 14비트 주소 체계의 예시를 보자. <u>페이지의 크기는 64B이고, 16KB의 address space를 갖고, PTE는 4B라고 가정</u>하자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAqklEQVQY052QuQqGMBCE8/5vZiEEUopiiAd45BAtLHR+ZsEUYvUHlpmdfGwOdd83WNd1gWvbNpRliZSS9Mwf5s1WVQVjDM7zzKxa1xWsZVlE53lG3/ei3vu8Rz9NU/bMh2GAcy5nVNW2LZqmAZUAvbVWhhJmFmOU/XEc0XWd6LvIkFecypOfm/JmIQR5OiE+/TiOnLH/qn3fhVf8A601iqJAXdfimfGv/lk/uOp6+r52FR0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mlpt-translation\"\n        title=\"mlpt-translation\"\n        src=\"/static/32a7c0c7045800c96d7d39a90d26d9b0/37523/mlpt-translation.png\"\n        srcset=\"/static/32a7c0c7045800c96d7d39a90d26d9b0/e9ff0/mlpt-translation.png 180w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/f21e7/mlpt-translation.png 360w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/37523/mlpt-translation.png 720w,\n/static/32a7c0c7045800c96d7d39a90d26d9b0/2c5fd/mlpt-translation.png 1006w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그렇다면 64=2^6, 즉 6비트의 offset이 필요하고, 나머지 8비트는 VPN에 필요하다. 각 Page에는 16개의 PTE가 들어있을 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 118.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADLUlEQVQ4y62VWU8iURCF/f8PQBB/gCgkRGPcQE1AcAERQYIKgiwqooiICqKCW02+mtxmCcm8TCeXNNXV5546dW711O/vr3x9fen6/v7Wxf3Pz498fn7Ky8uLdDodabfb8vr6Kh8fH/L29ibdbldj5hm5XFOtVksikYgEg0E5PT2V3d1d2djYkGw2qwCPj48K8P7+Lo1GQxKJhObXajWNAcym5Ckg6KlUShNLpZKk02m9v7u7052fnp70xV6vJ/f393J4eCjb29v6nBjPyLMAQScpFovJxcWFgvH/4eFBYH95eSn1el3Z5fN5Ze/3++Xs7ExjAFerVc1XwOfnZwWIRqNSKBQUEJZXV1eavLS0pCBbW1syNzcnTqdTZmZmxOv1yubmpgQCAVlbW5Obm5sBw6OjI4nH48qQ8o+Pj4WNAFxYWJD19XVl5Xa7xeFwyPT0tN4TA2x5eVlZTiw5mUwqQ8SmJPQ6ODjQHF6en5+X2dlZZQYJ3tvb25Pb29tByTyg5PPzcwXd399XvbAEOtJlGgCLUCgk4XBYtTUWGukyf9ANUDQEEAnYcbzL6MRmWAtwYgBO7DJlwQpQSqZcknK5nFQqFW0S+i4uLmqjeIdYuVxWEuRPLBnATCajDGgKAIiPZjTC5XJpp9GSGA1bWVkZ7bIR12gI4HCXDSDNoMuAYiEDSJevr68HJwUArEJpLIDRDVA0Q1MWDaFcn8+nRxVHGP0tDeU/XgyaKX6YLOOLuHnGhUU4ggwFmA9PGJOvDBlXTBUWZmbhP0aY2ZUczurOzo7KQwMwPDIZUAvwXyVwmfk4fgHGZiMlk1wsFtXIlEJTTk5OtCmYmmOF8KYpWIRhwUwkxjM83Gw2/zIEEABMSpCxRDJlo9m4bex2u9hsNvXksA+t4QAgunA2AQSc/zAEEGPzIqwAYdIwvjwejzUbV1dXB8YGEFYYEy9xDyBnlJLxJOxZxAFh0RDegQiSWUcPQL4fUDZnF5am2+jKEOj3+/oJQFM04xQRw07m26OAdArHm10QGpZcgA1/pNgUdpwSGANmPlJWU8xn1BiaDYwHYQYoTA1bdIXpcByTAw7gH34XvanvfzIEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"usage\" title=\"usage\" src=\"/static/0748a417567f8bcc40cbceea6e619f87/9516f/mlpt_usage.png\" srcset=\"/static/0748a417567f8bcc40cbceea6e619f87/e9ff0/mlpt_usage.png 180w,\n/static/0748a417567f8bcc40cbceea6e619f87/f21e7/mlpt_usage.png 360w,\n/static/0748a417567f8bcc40cbceea6e619f87/9516f/mlpt_usage.png 538w\" sizes=\"(max-width: 538px) 100vw, 538px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>여기서 6개의 Page(0,1,4,5,254,255번)가 valid하고(사용중), 나머지는 비어있는 공간이라고 가정하자.</p>\n<h3 id=\"in-linear-page-table\" style=\"position:relative;\"><a href=\"#in-linear-page-table\" aria-label=\"in linear page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>in linear page table</h3>\n<p>기존 방법이라면, 사용 여부와 상관없이 Page Table을 저장하기 위해 2^8*4B = 2^10B = 1KB가 고정적으로 필요하다. PTE는 2^8=256개를 모두 사용한다.</p>\n<p>상위 8비트에 해당하는 PFN으로 교체를 하여 물리 주소 14비트를 얻을 수 있을 것이다.</p>\n<h3 id=\"in-multi-level-page-table\" style=\"position:relative;\"><a href=\"#in-multi-level-page-table\" aria-label=\"in multi level page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>in multi level page table</h3>\n<p>한 Page는 16개의 PTE를 담을 수 있으므로, 이를 구분하기 위해서 상위 4비트(2^4=16)를 Page Directory Index로 사용한다. 그렇다면 다음 상위 4비트는 한 페이지 내부에서 Page Table Index를 의미할 것이다.</p>\n<p>상위 4비트로 나누면, 0000인 부분과 1111인 부분만 사용중이고, 이는 각각 100번과 101번 Page Frame에 있다고 가정하자. 그렇다면 Page Directory는 다음과 같이 표현 가능할 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVQ4y42T3Y6CQAyF5/0fzzsVEbggQoLGH1BQ7OZrcszE3VltMpmhpz1z2g7heDzaZrOxtm1tuVxa13V2uVxsu91anudW17UVRWFlWfoifrfbOV5VlS/87MQGkrIs86DFYuEgwGq1sqZpHLter6/kYRgcExEx5/PZ1uu17fd7C6fTyR0Yiff73fq+dyXP59N9GKqFQzrPs59Zins8HhYAWBiBOG+3m5MSyBkbx9GmaXKcZDB8LAwMX4idkHAj31KATwkiRC07cbpQqgMAK1aIAtoQK8T3lULdLIUkQHw4HNwnQvUQnDjUxITEucJ3QpXMLvL3HooQEl34ItSkVHLcQ5WHqTXgqZJ/Eb4PJVYoxSlC5fw5ZeT/V3I8ZeUmp5wq+ZPC5JRTQyFG7ZGaj0P5hvBjyTDHzlQP9U0Sb1SKJIZ/3wlJiJPin56z2qFe0yfi9UzUf73NH49I33HFkFrOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"pagedirectory\"\n        title=\"pagedirectory\"\n        src=\"/static/cac38a41dd8b88208b6b912e413594bc/37523/pagedirectory.png\"\n        srcset=\"/static/cac38a41dd8b88208b6b912e413594bc/e9ff0/pagedirectory.png 180w,\n/static/cac38a41dd8b88208b6b912e413594bc/f21e7/pagedirectory.png 360w,\n/static/cac38a41dd8b88208b6b912e413594bc/37523/pagedirectory.png 720w,\n/static/cac38a41dd8b88208b6b912e413594bc/302a4/pagedirectory.png 1080w,\n/static/cac38a41dd8b88208b6b912e413594bc/1628f/pagedirectory.png 1232w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Page Directory에는 2개의 PFN만 사용중이고, 해당 Page에는 PTE가 각각 4개, 2개 저장되어 있는 모습일 것이다.</p>\n<p><strong>기존에는 256개의 PTE를 모두 할당하였는데, 이렇게 계층화한다면 2*16개의 PTE만 할당해도 되며, 16칸의 Page Directory의 영역만 있어도 될 것</strong>이다.</p>\n<p>물리주소로 변환하는 과정을 살펴보자. 예를 들어, 스택 영역의 11 1111 1000 0000가상주소를 변환한다고 했을 때,</p>\n<ol>\n<li><strong>상위 4비트(1111)는 Page Directory의 Index</strong>이므로, Page Directory의 1111, 즉 15번째(마지막) 주소, 즉 101번 페이지에 해당 PTE가 존재함을 의미한다.</li>\n<li><strong>다음 4비트(1110)는 Page Table의 Index</strong>이므로, 101번째 Page에 있는 1110번째, 즉 14번째 주소에 해당 물리 주소가 존재함을 의미한다. 즉, 55(0011 0111)번째 Page에 해당 가상 주소가 매핑된다.</li>\n<li>offset은 그대로 간다.</li>\n</ol>\n<p>따라서, 가상주소 <code class=\"language-text\">11 1111 1000 0000</code>은 <code class=\"language-text\">00 1101 1100 0000</code>으로 변환된다! 가상 주소의 VPN은 실제 물리 페이지 번호에 매핑되고, 여기서는 해당 물리 페이지의 위치는 110111번째에 존재함을 Page Directory와 Page Table을 통하여 알 수 있다.</p>\n<h2 id=\"단점-1\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-label=\"단점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<p>실제 64비트 주소 공간을 효율적으로 사용하기 위해 4-level이 넘는 Page Table을 사용한다고 한다. 이에 복잡도가 증가할 수 있는데, 이로 인해 발생할 수 있는 문제점은 memory 접근 횟수가 많아진다는 점이다.</p>\n<p><strong>TLB miss가 난다면, 계층의 깊이만큼 memory에 access 해야하므로 느려질 것</strong>이다.</p>\n<p>오늘은 Page Table의 크기를 줄이기 위한 방법에 대하여 알아보았다. <strong>Page Table의 크기는 줄일수록 시간의 손해가 발생하거나(여러번의 memory 접근), 공간을 효율적으로 사용하지 못하는(fragment) 문제가 발생할 수</strong> 있다. 하지만 메모리 가상화를 통하여 얻는 이점(Process는 물리주소를 신경쓰지 않고, 독립적인 메모리 공간을 보장 받음)이 치명적이므로 메모리 가상화를 포기할 수는 없다.</p>\n<p>따라서 Page Table의 크기를 줄이는 것이 아니라, <strong>disk에 저장</strong>하는 <code class=\"language-text\">swap</code> 이라는 기법이 존재한다. 이에 대하여 다음에 알아보도록 하자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"November 05, 2023","title":"(OS) 운영체제 복습 [9-2. Multi-Level Page Table]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(9-2)-Multilevel Page Table/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(9-1)-Paging/","nextSlug":"/OS(8)-Mechanism of Address Translation/","prevSlug":"/OS(9-2)-Multilevel Page Table/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}