{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(9-1)-Paging/",
    "result": {"data":{"cur":{"id":"8869d9e9-0598-5a31-9918-2c90927ba1e3","html":"<p>오늘은 <code class=\"language-text\">Paging</code> 기술에 대하여 알아보자. 저번까지 우리는 <code class=\"language-text\">base and bound</code> 방식으로 프로세스에게 메모리 가상화를 제공하고, <code class=\"language-text\">MMU</code>에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 <strong>internal fragment가 많이 발생</strong>하여 <code class=\"language-text\">segmentation</code>에 대하여도 알아보았다.</p>\n<p>segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 <strong>고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안</strong>된다.</p>\n<h1 id=\"paging\" style=\"position:relative;\"><a href=\"#paging\" aria-label=\"paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Paging</h1>\n<p>memory address를 여러개의 (비교적 작은) 고정된 크기의 <code class=\"language-text\">pages</code>로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 <strong>고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에 배치하는 것</strong>이다.</p>\n<p>예를 들어, Process의 address space는 아래와 같이 page로 나뉘어 물리 공간에 존재하게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+ElEQVQ4y4WT2W6jQBBF/f9/lEkyL85jlMiKwQ7xztpNAyaAV8wZVdvKMsqCdEVLiFt3qe5tNhuSJCFNU7TWxHFM0zT89HRd9y16URRxdfWH6+trbm//cnNzy3K5RGn9NigIAoIwJAwjtNI/DuvJT47jMBgMeHh4xHVHyJB1UWCMoa4r2ralPR5pTyeOwLE7cTge2W637HY7Cznv93t6osD3fZ6fn3FHI3vWYj/LSNKUsq7fx7ctXVlyUAlFEFA1jY1HINFJXL31eo3WitVqZS2KqrXjYCYTMt/nNY7p8hyCgC6OIc9oJAqlqKrqE6FE0yuKwpYhhFEckpqU0nXJ+n3yuzs2j490xpzLuAjdRBFmtaK+EAmhWA7D8Gx5Op0yHA4t5vM5KgxJ8xxdFJR5fibUmk5r8Dy2kwkmjr8mlNaExPM8XNdlsViglLKl5L5PlSRny/f3dP0+PD1RuS6pfKtrS1bX9WfLwjyZTvEDnyiOKB2H1/EYM5tSjkZ07giaxloWNHGEuZSy+ZChVZgoxWw2YzweMxw6Vq20W2QZhefxuli8ZcfpZJe32W3Z7ffW5v/oKXUu5OXlxZKufJ/U8zCDAWa5tGsjJMhN+NjMd4udZZnNTEjlbdKUaj5HK2WLqavq1+v26eqJzMPh8AbZ9vaLu/urtIvCf5ou22MG1zpkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"page\"\n        title=\"page\"\n        src=\"/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png\"\n        srcset=\"/static/9362b1135cf233e4857c9d4480f3d9a7/e9ff0/page.png 180w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/f21e7/page.png 360w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png 720w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/33e10/page.png 844w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>오른쪽은 가상 공간을 의미하며, 왼쪽은 실제 address space(AS)의 page가 물리적인 공간의 page frame에 배치되는 것을 의미한다.</p>\n<p>이렇게 고정된 크기의 페이지를 배치함으로써 external fragment를 줄일 수 있지만, page의 크기가 고정이므로 internal fragement가 존재할 수 있다. (하지만 하나로 배치하는 것보다는 적을 것임)</p>\n<h1 id=\"page-table\" style=\"position:relative;\"><a href=\"#page-table\" aria-label=\"page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table</h1>\n<p>위의 그림을 보면, virtual page는 physical page frame에 매칭이 된다. 이러한 매핑 정보는 <code class=\"language-text\">Page Table</code>에 저장하여 translation에 사용한다.</p>\n<p>예를 들어, page table에 3,7,5,2의 배열의 형태로 저장되어 있다면 해당 4개의 가상 페이지의 실제 page frame number가 3,7,5,2임을 의미한다. page table 역시 메모리 구조에 존재해야하므로 OS의 memory 공간에 저장되어, <code class=\"language-text\">MMU</code>가 접근할 수 있도록 한다. OS는 <code class=\"language-text\">context switch</code>가 일어날 때, page table의 값을 업데이트하여 관리할 것이다. (기존 PT는?)</p>\n<h2 id=\"page-table-entrypte\" style=\"position:relative;\"><a href=\"#page-table-entrypte\" aria-label=\"page table entrypte permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table Entry(PTE)</h2>\n<p>page table은 보통 배열의 형태로 존재하는데, 각 원소를 page table entry(PTE)라고 부른다. PTE의 인덱스는 VPN(virtual page number)를 의미하고, 값은 PFN(Page Frame Number), 즉 물리적인 위치를 포함한다.</p>\n<p>PFN 말고도 해당 Page Frame에 대한 추가적인 정보가 비트의 형태로 존재하는데, 다음과 같다.</p>\n<ul>\n<li>Valid Bit : 해당 page가 프로세스에 의해 사용되었는지? 가능한 address space에 비하여 실제 사용하는 페이지 수는 한정적이므로 유효한 페이지인지를 기록</li>\n<li>Protection Bits : R/W 권한</li>\n<li>Present Bit : page가 memory에 존재하는지 (swap space에 있는지?)</li>\n<li>Dirty Bit : 메모리에 적재된 이후에 해당 page가 변경된 적이 있는지</li>\n<li>Accessed Bit : 최근에 해당 page가 접근된적 있는지</li>\n</ul>\n<p>이러한 PTE의 값은 다음에 자세히 알아보자.</p>\n<h2 id=\"address-translation-in-hw\" style=\"position:relative;\"><a href=\"#address-translation-in-hw\" aria-label=\"address translation in hw permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address translation in H/W</h2>\n<p>가상 주소는 MMU에서 Page Table의 값에 따라 실제 물리 주소로 변경된다. 그 과정을 간단하게 알아보자.</p>\n<p>한 페이지의 크기가 16B이고, 가상 주소의 크기는 64B라고 가정해보자.</p>\n<p>저 두 단서로만 우리가 알 수 있는 조건은 다음과 같다.</p>\n<ul>\n<li>한 프로세스는 4페이지를 갖는다 (64 / 16 = 4)</li>\n<li>2^6B만큼 주소를 표현할 수 있어야하므로, 주소는 6비트로 표현 가능하다</li>\n<li>가상 주소에서 앞부분은 VPN을 의미하며, 뒷부분은 offset(page 안에서의 오프셋)을 의미하므로, 상위 2비트는 VPN을 의미한다(4개 페이지 존재하므로)</li>\n</ul>\n<p>PA로 변환하기까지의 그림은 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmUlEQVQ4y33U2W4iQQwFUP7/43jhBSHEFgj7DmGnRseSexgyiaXSrXLZt7x1157PZyHwfZHxeFxarVZ1vt/vgdPptDQajbLf7+P8eDwCa0n2Lgw+Pz9Lt9stzWazfHx8xN4Do9Go9Hq9IKRnBxeLRam9vsx4MpnExel0itePx2Ps4Xa7jfX19VWu12vod7tdZXc4HP4SQkTL5bKsVqtwYsjBYgzX63U4u0funPf0P6ZMGEkPMUQgCwTO5/O5DAaDIOr3++V2u/0boaV2DJUA0XA4jNQ4wvl8HukqDXHPD1ZNeY0SmcgyBYiYHpmyXC6XilAzPA5/JCRqqXudTie6S34j/DVCNYLZRVFqArJ3QkTfCNUt65fDrHtIs4aJs9ksasiGqC3fKuX/dViqIlE7hqKEuowYOntAOWSgNNFlBJQ+JWlw1gxk0rR/1W02m2rYc9DzvppDrxlmaeagpqPX6ThqlMiTIHV5T/8tZWFnN6VnYO1lYJgRqKPle2ZrOQui9v6nye86h7XdbscjGmbZZ+Pq9XpkloHw+QOs+IEATb9oaAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png\"\n        srcset=\"/static/1298585682d7000b228ce325b1aa32a9/e9ff0/VA.png 180w,\n/static/1298585682d7000b228ce325b1aa32a9/f21e7/VA.png 360w,\n/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png 720w,\n/static/1298585682d7000b228ce325b1aa32a9/4ef49/VA.png 890w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 VPN은 MMU에서 PFN(Page Frame Number)로 대체되어 물리 주소 값은 PFN + offset로 구성될 것이다.</p>\n<p>예를 들어 가상 주소가 010101이라면, 해당 주소는 프로세스의 1번째 페이지 중 5번째(0101 = 5)에 위치해있을 것이다. 0번째 페이지의 실제 위치는 Page Table의 0번째 줄을 보면 알 수 있다.</p>\n<p>이를 통하여 하나의 Page Table에는 4개의 <code class=\"language-text\">PTE</code>가 존재한다는 것도 유추할 수 있다. 또한, 물리주소의 PFN이 3비트인 것으로 보아, 해당 시스템에서는 가능한 Page Frame이 8(2^3)개 라는 것도 유추할 수 있다.</p>\n<h2 id=\"page-table의-단점은-없는가\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%80-%EC%97%86%EB%8A%94%EA%B0%80\" aria-label=\"page table의 단점은 없는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 단점은 없는가</h2>\n<p>정리하면, 메모리 주소가 변환되는 과정은 다음과 같을 것이다.</p>\n<ul>\n<li>CPU에서 코드, 데이터 등이 위치한 가상 주소를 보고 요청한다.</li>\n<li>MMU는 VA를 PA로 바꿔준다.\n<ul>\n<li>memory에 위치한 Page Table을 보고, VPN을 PFN으로 바꾸어 Physical Address를 얻는다</li>\n<li>실제 메모리에 접근하여 코드나 데이터를 fetch해온다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"속도-overhead\" style=\"position:relative;\"><a href=\"#%EC%86%8D%EB%8F%84-overhead\" aria-label=\"속도 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속도 overhead</h3>\n<p>이와 같이, 실제 물리 주소를 접근하는 과정에서 VA를 PA로 바꾸고, 이 과정에서 overhead는 발생할 수밖에 없다. Page Table역시 메모리에 존재하므로, 메모리에 두번씩이나 접근해야하는데 이는 썩 좋은 방법은 아닌 것 같다.</p>\n<h3 id=\"공간-overhead\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84-overhead\" aria-label=\"공간 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간 overhead</h3>\n<p>또한 페이지 테이블의 크기는 작지 않다. 과거 자주 쓰이던 32bit 주소 체계에서는 보통 20bit은 VPN, 12bit는 offset으로 구성된다. 이 경우, Page Table Entry(PTE)의 갯수는 프로세스 하나당 2^20개가 필요하다. 보통 한 PTE에 4B를 차지한다고 한다면 4*2^20Byte, 즉 하나의 프로세스 당 주소 변환을 위하여 2^22 = 4MB의 공간이 필요하게 된다.</p>\n<p>최근 사용하는 64비트 주소 공간에 대하여 생각하면 페이지 테이블 하나만 저장하기 위해 GB 단위 이상을 사용해야할 것이다…</p>\n<p>그렇다면, 이를 개선할 방법은 없을까?! 속도를 개선하기 위해서는 VA-PA 쌍을 캐싱해두는 방법이 있다. 사이즈를 개선하기 위한 방법은 다음에 알아보고, 우선 caching을 통하여 속도를 개선하는 <code class=\"language-text\">TLB</code>에 대하여 알아보자.</p>\n<h1 id=\"translation-lookaside-buffer-tlb\" style=\"position:relative;\"><a href=\"#translation-lookaside-buffer-tlb\" aria-label=\"translation lookaside buffer tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Translation Lookaside Buffer (TLB)</h1>\n<p><code class=\"language-text\">MMU</code>에서 <code class=\"language-text\">PTE</code>를 일부 캐싱해놓는 곳을 <code class=\"language-text\">TLB</code>라고 한다. (TLB는 MMU의 일부이다) 자주 참조되는 PTE를 저장해놓는 소형 <u>하드웨어 캐시</u>로, <code class=\"language-text\">address-translation-cache</code>라고도 불린다.</p>\n<p>기본적으로 VA에서 PA로 전환하는 과정에서 memory가 아닌 <code class=\"language-text\">TLB</code>를 먼저 보고, TLB hit이 발생한다면 page table에 접근하지 않아도 된다! 하지만, TLB miss가 발생한다면 메모리에 다시 접근해야하므로 **지역성(locality)에 근거한 캐시 정책(LRU 등)**이 활용될 수 있을 것이다.</p>\n<p>또한 TLB는 MMU에 존재하는 캐시이므로, <code class=\"language-text\">context switching</code>이 발생하는 경우에는 기존 entry를 비활성화하고, 새로운 page table의 PTE로 교체해야할 것이다. 이를 위해 <code class=\"language-text\">TLB valid bit</code>를 사용한다. (이는 PTE의 valid bit와 다르다!)</p>\n<h2 id=\"page-table의-크기를-줄이는-방법\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%ED%81%AC%EA%B8%B0%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"page table의 크기를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 크기를 줄이는 방법?</h2>\n<p>TLB는 page table의 단점 중 하나인 시간 overhead는 줄일 수 있는 HW적인 방법이다. 하지만, 공간 overhead를 줄이기 위해서는 어떻게 해야할까?</p>\n<p>가장 간단한 해결책은 <strong>page 하나의 크기를 늘리고, entry를 줄여 page table의 크기 자체를 줄일 수 있을 것</strong>이다. 페이지가 n배 커질수록, page table의 크기는 1/n배로 줄어들 것이다.</p>\n<p>하지만, 이는 앞서 연속된 하나의 주소 공간을 제공하던 방법과 마찬가지로 <code class=\"language-text\">internal fragmentation</code>(내부 단편화)의 문제가 발생하여 메모리 공간 부족이 나타날 수 있다.</p>\n<p>이를 해결할 수 있는 몇가지 방법이 있는데, paging과 segmentation을 결합한 <code class=\"language-text\">hybrid approach</code>, 그리고 <code class=\"language-text\">multi-level page table</code>기법이 제안된다. 이는 다음에 자세히 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"오늘은  기술에 대하여 알아보자. 저번까지 우리는  방식으로 프로세스에게 메모리 가상화를 제공하고, 에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 internal fragment가 많이 발생하여 에 대하여도 알아보았다. segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안된다. Paging memory address를 여러개의 (비교적 작은) 고정된 크기의 로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에…","frontmatter":{"date":"October 30, 2023","title":"(OS) 운영체제 복습 [9-1. Paging]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(9-1)-Paging/"}},"next":{"id":"dbf838fa-a84b-5baa-8fd9-b484a510bf52","html":"<p>MMU에서 Virtual Address에서 Physical Address로 변환되는 메커니즘을 간단한 함수의 실행과 함께 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span>\n\tx <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 함수가 실행되는 프로세스를 생각하면 OS는 아래와 같은 address space를 제공할 것이다. (프로세스마다 기본적으로 16KB만큼을 할당해준다고 가정하자)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 296.6666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAA7CAYAAAB7c6ruAAAACXBIWXMAABYlAAAWJQFJUiTwAAADwUlEQVRYw9WY107rQBCG8/4vA5FAcAGIqoQuWoDQe++9ztE3R7+12diJUy7OWWlke8u/U3dnXNjf37fd3V0rlUrG+/v7u93e3trj46Pd3Nw4XV9f2/39vRNjd3d39vT0lPRBzPv8/LTC2dmZnZ+f28rKis3Pz9v09LRtb2/b2tqabWxseN/i4qLNzc3ZwsKCXV1dJfOen5/t9/fXaGzw+vpqBQvaxcWFTU5O2t7ens3OzjooQHC+vr7ufQDSvr+/w6X28vLyF/Dj48MgxICzqakp29zctKWlJX/OzMw48NHRkU1MTLgkcL6zs2Nvb2/1gOgHHfb19TnI6emp64l+RLq8vLSTkxNfQB9jx8fHhqrQWR0gOvj5+XEuaRgjFIcx2tfXl/eLK/r5lg7ZvE6HNEQPARFbhuJ9aGjIDg4OXBVwqcZGDoiITMBt6MQFAGVHLIcRWIjBEB+iD8/gyRzEZZw1BfRzeHjoXAjw4eEh2RG/bESA8US/vKeKLL210hKRsRQEOg0OZT0ULtIiGSUeS4yytbXlvlUsFl0fUAgYWnp1ddXnpgEmbiMd4F8sbMQh85py2HUdYmVchwMA59bpAefsGpJUEvcBhDu521SrVQ+9sbExH4BDNmECvgXhc7gSrjUyMuLRJN+UP3KgAF4nss4/AMQtm8A9UoyPj7uO0bnGtIFzKMVKb0xkR02G2IRYHhwctJ6eHn9nU8aYz+ZIVQMoa7E4BoTQqdyGhTq5IQCxgwNK1CzA8OiXEUKwlgBjLgGKwaTDhoC6lOKFWdSQQ53WeQA1p8Yo7QKG4w0B84gcjzUFTHObLLA6P0wTOQswra8pYBaHWRwLMLdjNwJrO1I68sOsSFGUpEVLy5HCOzEMJzwB4L2tSOHJWcdJQxbGkwwCAIHmjhQlnpzo5XLZU7rR0VHPE0lNGGvbD1kESdxY5LYjpWuO3SxSWnLs/z9Scjt2XsN07U4Jr4CO75RQgo7vlFgdHV8B8Sn070RKHMMdRQqLOMZ0bOmQrQPMk32pFu7v77fe3t7UdK6GwxCQCQDExxQJJ3Uyma4STiWlnOJJwhkXiYDFKTGTWUwtPTAwkABovCYlZlfybIrC5eVl54zaWPkzxGI24OSmruFdfwLCMQdULNKpiyiu1lsqK5qVt6F+w5ZZ+FQqFZefi4cSl1wa9qmHsZwaRmEepQWGiDer+UUAUTNzTcqqKJoJalgWg6Fb9acCdqs0SwBVMsCR/IoiUf8UeIr4Tuur+W/DnxBqj+HhYf8vwwT9/chLUhF6/gOys5fZzublKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png\"\n        srcset=\"/static/23122becc17c9e94b52ff2a3983884a3/e9ff0/VA.png 180w,\n/static/23122becc17c9e94b52ff2a3983884a3/f21e7/VA.png 360w,\n/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png 436w\"\n        sizes=\"(max-width: 436px) 100vw, 436px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>x 변수는 stack영역에 저장되고, 컴파일된 명령어는 code 영역에 존재할 것이다. 이 과정에서 Address Translation이 어떤 식으로 이루어질지 생각해보자.</p>\n<h1 id=\"dynamic-relocation\" style=\"position:relative;\"><a href=\"#dynamic-relocation\" aria-label=\"dynamic relocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Relocation</h1>\n<p>이러한 주소의 배치는 프로세스 실행 이후에 address space가 변경될 수 있으니, dynamic relocation(동적 재배치)라고 불린다.</p>\n<h2 id=\"base-and-bound-하드웨어-기반\" style=\"position:relative;\"><a href=\"#base-and-bound-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B8%B0%EB%B0%98\" aria-label=\"base and bound 하드웨어 기반 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>base and bound (하드웨어 기반)</h2>\n<p>가장 단순한 방법으로는 위의 <strong>프로세스의 메모리 공간을 그대로 연속적인 하나의 물리적 공간에 매핑시키는 방법</strong>이 있을 것이다. 16KB가 연속적으로 남는 공간을 찾아서 그곳에 프로세스의 공간을 할당하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 143.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAADM0lEQVRIx42V505qURCFef9n8B8J0WDAoCRKIKBiw9ARFRsWilJERbHh3HxzM+QcDhpOsrMLe69Zs6bge3t7k1arJf1+X+z7/v6Wr6+vucbPz4++sdnXbDYlHo9LoVDQg+FwKNvb23JwcCD7+/u/Dn7n3vn5ub4bj8f/AY2VWXh6epKdnR2pVqtSLBalVCpNRrlcdq2z2awcHx+7AQGyYYC7u7tSqVTk5ORETk9P9REzIKw5r9VqksvldD0XYCQSEb/fL8vLyxIIBCQYDEooFJLFxUVZWlrSPfcA9gCyIRBOQDRC21QqJZubmxKLxVSzRCIhyWRStra2JJPJKPOZGtoHIKJjmcs22JsEtieQHpefn5/1kEA8Pj7K6+urssD6PFEmeC5AALB4eHgog8FAAblIJPP5vLJgtrUNMgCjnijPcpncYibZYY0h1ra3cX9/L1dXV+7Eng4KEmC12+0KSX99fa3j9vZWGo3GZH54eND15eWlG3A6sU1T2PCA6BJtJEmn07KysqIu8/vd3d0EEFJgTPLQNDDAXq8n7XZb3YINs+2pfc6cgPbN1BBAXDaATqejgzOnAafLaIo0Pn4kcdfW1hRgNBppROv1ulxcXOgDNCXqRJY95wQDw5aHvCWdfACwQWjWtDMeoRHGiDBVsbCwoGXIXZgaW1jxjrsQ8bhM+4IdQOiIKxhYX19XBpxZClmkPz4+VFfy2RMUEhuweT8YAwjTs7Mzb7eBoZUW7YlqsGqhfik1ZnSkicD+8/NTc5a7M10mHWD68vKibEl6XOfh+/u7DrTGfbSHITO5qgz5bwCANbMBkkLMlOLe3p5GFAOck6+s0RBw0oos0LSJRqMSDodVWCIGdR4fHR3pTP+jsa6urmonJ40slZjRH2B1GXegzLBKQSOsYxWDRBRWdkbK4C4ELLGZ0ffPSiHPAOMxwJyhpRlyVgrEYOqJ8nRzoPGiH/oQbdyHCUactexqX781ByJnzRQZ+NdDJ/INtk6Gk24z7bJpaK6ZdtZorfECiIaeBkveYQkQwk/ukcQ3NzeTRsA8PShPPIGt6y+ADEejjY0NLSM+wNDnr4Ec3LMyNYb/ACBSX4dpGsZ3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseandbound\"\n        title=\"baseandbound\"\n        src=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png\"\n        srcset=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/e9ff0/baseandbound.png 180w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/f21e7/baseandbound.png 360w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 경우, 두개의 레지스터 값만 유지한다면 간단하게 VA와 PA간 변환이 가능하다. 해당 프로세스는 32KB에서 시작하고, address space의 크기는 16KB이므로, <code class=\"language-text\">base</code> 레지스터에 32KB, <code class=\"language-text\">bound</code> 레지스터에 16KB의 값을 갖고 있도록 하자. <u>각각 시작주소와 프로세스 주소 공간의 크기를 의미</u>한다.</p>\n<p>그렇다면 <code class=\"language-text\">MMU</code>(Memory Management Unit)에서  <code class=\"language-text\">PA = base + VA</code>로 변환해줄 수 있을 것이다. 만약 VA가 bound인 16KB보다 크거나 0보다 작다면 에러가 발생하도록 하면 된다.</p>\n<h3 id=\"role-of-hardware-in-translation\" style=\"position:relative;\"><a href=\"#role-of-hardware-in-translation\" aria-label=\"role of hardware in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of hardware in translation</h3>\n<p>주소 변환에서 하드웨어의 역할이 무엇인지 정리해보자.</p>\n<ul>\n<li>CPU는 <code class=\"language-text\">privileged mode</code> (<code class=\"language-text\">kernel mode</code>)를 제공해야 운영체제가 접근권한을 갖도록 할 수 있다.</li>\n<li>하드웨어는 base &#x26; bound 레지스터를 제공하며, CPU당 한쌍이 필요하다. 이를 통해 <strong>주소 변환과 범위 검사를 수행</strong>하며 <strong>오류 발생시에는 예외를 발생</strong>시킨다. 또한 <strong>레지스터 값을 변경하는 특권 명령어를 제공</strong>해야한다. 프로세스마다 각 레지스터 값들은 다르므로, 변경이 필요하며 이는 특권 모드에서 일어나야하기 때문이다.</li>\n</ul>\n<h3 id=\"role-of-os-in-translation\" style=\"position:relative;\"><a href=\"#role-of-os-in-translation\" aria-label=\"role of os in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of OS in translation</h3>\n<p>그렇다면 운영체제에서 <code class=\"language-text\">dynamic relocation</code>을 지원하기 위해 해줘야 할 일은 뭐가 있을지 알아보자.</p>\n<ul>\n<li>프로세스가 실행될 수 있는 유휴 메모리 공간인 <code class=\"language-text\">free list</code>를 관리한다. 위의 예시에서는 16<del>32KB, 48</del>64KB 영역이 free list에 있을 것이다.</li>\n<li>프로세스가 시작할 때 메모리 공간을 할당해주고, 종료할 때 이를 정리해준다.</li>\n<li>context switching 발생시, <code class=\"language-text\">PCB</code>에 실행중인 CPU의 <code class=\"language-text\">base</code>와 <code class=\"language-text\">bound</code> 레지스터 값을 저장해주거나 이전 레지스터 값을 복원해줘야 한다.</li>\n<li>하드웨어 예외 발생시, error handler를 통하여 조치를 취해야 한다. 보통 OS는 해당 프로세스를 종료함으로써 자원을 보호한다.</li>\n</ul>\n<h2 id=\"segmentation\" style=\"position:relative;\"><a href=\"#segmentation\" aria-label=\"segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segmentation</h2>\n<p>base and bound 방법은 비교적 간단하지만 내부 단편화(<code class=\"language-text\">internal fragment</code>)가 발생할 수 있다는 단점이 있다. 위의 그림들을 보면 프로세스에게 할당이 되었지만 사용중이지 않은 heap ~ stack 사이의 빈 영역이 존재하는데, base and bound 방법은 이러한 내부 단편화가 일어날 수 밖에 없는 구조이다. 고정 크기를 각각의 프로세스에 할당하므로 <strong>한 메모리에서 실제 사용하는 용량에 비해 실행시킬 수 있는 프로세스의 수는 적을 것</strong>이다.</p>\n<p>예를 들어, 32bit 주소 공간을 갖는 체계에서 하나의 프로세스는 무려 2^32byte = 4GB의 공간이 필요하게 된다… 하지만 실질적으로 프로세스에서 필요한 메모리의 크기는 MB단위일 것인데, 불필요한 부분들이 너무 많아 지게 된다.</p>\n<p>따라서 address space를 보통 <strong>heap, stack, code segment로 나누고, 이렇게 생긴 여러개의 (base, bound)를 MMU에 각각 두어 일반화</strong>한 방식인 <code class=\"language-text\">segmentation</code>이 제안된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVQ4y52U2W/aQBCH/Z9XfWikSonI2b72oXlppVZV1CoVRwI0AQJJzH0Ggy/A2AYCGDDHr5oFEwdVSuhIox0f++3M7MxwuiZAEhKQa/eQa3dMpdodVIlHNsNDFCXY9gTtdhuGYTAlW9d19Pv99TPZnU4HXD75C9HAe8SD+7i59DCNBz2IBvbQUEog6Xa7yOVyyOfzKJfLqFQqKBQKGI1G0DQN6XQalmWxQ7hyzoew14PrwAmuA8eIXJzgyn+M6MUxTENaAwkiiiKD0OrYqqqiVqthMpmg1WqBK2V9CP7eQ9h75NJDRAJHMHVxCex0GFCWZQwGAwYgHY/HDFiv15+AhfQ5Yhe7SIQOEQ8eME2EDhC73EdTrWCxWHpYLBYZhEKjVRCENZBs27ZZ+JwqlyEKt5DrPBQxyVSiC6rzeKgUWd5M02SrJElrYLVaZV65gc1mE5xtT1lY8xkwHtsYj2w4MpksbQqTAI1GA4+Pjyx/BKGbJSAdRN7SwVyjrUM2TIiajlxVQFlSIOsmpLaOXn+wPGw+Z+twOEQqlUKpVGJAnueRzWZZ7qbTKWazGbirwgM+R5L4Gs/gkzeM03AcXxJZnEZ4NMwuAy0okSshuPPsth3hur0e+pYFtaVBlBWmbbODgWWhpWksL46H7s2btqPct5sUdn6G8NEfxaE3gt3zP/jgj7J3iVwRiiSyUDY3bqrznfueyODNWQgeXww7P/x4d3aJXV8Mb8+CEDRjGZpr00vCVZQmbmsK7usKQnwGkWwR93UVd4IEo9t7Ft5roNzYsp4SPp0Czqb5HFPbfhbqqzwcroDu3xerMGmK0KVs5aG1AlIdUeWTOrdKBUzT5V+3/CKQirbX67G+pTYiCB2ydciWK4duoVKhb+7i3crDzZ//20NqcIJSc9NKQ5NsyiX1ayaT2S6H9BPNumQyycY6NTuNdBrnlEvK6TYh/wVtti9w5MDjCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"segmentation\"\n        title=\"segmentation\"\n        src=\"/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png\"\n        srcset=\"/static/99d8bbe29d2c10911c0c29ed5429333e/e9ff0/segmentation.png 180w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/f21e7/segmentation.png 360w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png 720w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/302a4/segmentation.png 1080w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/525d3/segmentation.png 1090w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리 공간을 코드, 힙, 스택의 3개의 segment로 분할하고, 각각 base, bound, 순방향 증가 여부(<u>스택의 경우, 역방향으로 증가하므로</u>)를 기록하여 segmentation을 간단하게 구현할 수 있다. 순방향 증가 여부의 경우, translation 과정에서 stack영역은 반대 방향이므로 다르게 계산해줄 필요가 있으므로 알 필요가 있다.</p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>하지만 이 방법은 내부 단편화는 줄일 수 있어도, 각 segment 사이의 작은 빈 공간이 많이 존재하게 되는 외부 단편화 (<code class=\"language-text\">external fragment</code>)가 발생할 수 있다는 단점이 존재한다. 이를 해결하기 위해 물리 메모리를 한 곳으로 몰아서 압축하는 방법이 제안되기도 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFklEQVQ4y22UV4uyMRCF/f+/QfBKEKzghcJe2MCCdS14Ifburr3XWZ5ZRvaDLxCSTE7OnDnJ+zqez6dcLhdhtDaZTGQwGMjxeHzH2L9er//g5vO59Ho92W6375gDEATr9VpqtZp8fn5KOp2WXC4nxWJRyuWytNtteTweb1yj0ZBKpSKZTEZxpVJJz9Xr9V9CQKvVSmKxmESjUfH5fOJ0OiUUCkkkElFilIEBm0wmFRcIBMTlconX65WPjw9JJBK/hAaMx+MK8vv94na7lRhS1EC4XC61vFQqJcFgUPfBeTweCYfDGnfgH15Mp1OVns/ntRcKBVWWzWal2WxqyYvFQnFYgxUkolQ6a0bH7XaTzWajKhnpo9FIfcIzFLEHoeFer5f8ryHOcTqdZDabydfXlxwOB71ZlEAKGbHdbqc3TCXsQU7jLAkQRePs20P8YQ6YBNwsAMA2gvv+/n4TWjWcswTqIWQAUYmKbrcr1WpV+v2+xuj3+/2N+/sW/zYlJLuVzCHArDudjgJQw3g+nzVOyVhAxxI68/1+r8lUIdJ5NraBEhLYQfbt8uzNMrKG0OIkc2A6PrCwDdY8FZ6IxVA4Ho9Vpb0G7BkOh3oWYiVEoV0KqghyCFIIWVOKXQo4U0eCVqulI5Uood0yHQ9pEPNzsJ8BHkII0V9CVGGRla2EBPhjsIDAvm1IIaICymUOzmwwESSwOZfyA811WsxGLfJSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compact\"\n        title=\"compact\"\n        src=\"/static/3491ec2ae9efa9381131014955213c91/37523/compact.png\"\n        srcset=\"/static/3491ec2ae9efa9381131014955213c91/e9ff0/compact.png 180w,\n/static/3491ec2ae9efa9381131014955213c91/f21e7/compact.png 360w,\n/static/3491ec2ae9efa9381131014955213c91/37523/compact.png 720w,\n/static/3491ec2ae9efa9381131014955213c91/84ee5/compact.png 1076w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 파편화된 외부 미사용 공간들을 압축하는 방법은 overhead가 큰 연산이므로 비용이 많이 든다. 이에 운영체제는 (미사용) 공간을 관리하는 알고리즘을 이용할 수 있는데, <code class=\"language-text\">best-fit</code>, <code class=\"language-text\">worst-fit</code>, <code class=\"language-text\">first-fit</code>, <code class=\"language-text\">buddy algorithm</code>등이 존재하며 압축을 최소화하면서 상황에 맞게 최선의 방법을 선택할 수 있을 것이다.</p>\n<p>또한 segmentation은 유연하지 못하다는 단점이 있다. 힙, 스택, 코드의 3 영역으로 나눈다고 해도 각각은 모두 연속적으로 존재해야하므로 유연성이 떨어진다. 이에 <code class=\"language-text\">Fine-grained</code> 와 <code class=\"language-text\">Coarse-grained</code> segmentation이 제안되는데, 조각이 많아진다면 유연성은 증가하지만 레지스터값들이 그만큼 늘어나므로 관리가 어려워질 수 있다.</p>\n<p>다음에는 이에 해결책이 될 수 있는 <code class=\"language-text\">Paging</code> 기법에 대하여 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"October 29, 2023","title":"(OS) 운영체제 복습 [8. Mechanism of Address Translation]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}},"prev":{"id":"5b688d70-f6f8-5524-8860-42276db9962f","html":"<p>지난 면접에서 리액트js를 사용한 경험에 대해 이야기를 나누다가 SPA의 단점에 대하여 물어보셨다. 평소에 알고 있던 몇가지에 대하여 이야기했지만, 불분명한 것도 있었고 호기심이 생겨 다시 한번 공부해보며 정리하고자 한다.</p>\n<h1 id=\"spa란\" style=\"position:relative;\"><a href=\"#spa%EB%9E%80\" aria-label=\"spa란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SPA란</h1>\n<p>우선, <code class=\"language-text\">SPA</code>는 Single Page Application의 줄임말로, 웹 서비스에서 하나의 페이지로 서비스를 제공하는 형태의 어플리케이션이다.</p>\n<p>많은 웹사이트들이 SPA 기반으로 만들어져있다고는 하지만, url이 바뀌는 것으로 보아 페이지가 하나만 존재하지는 않은 것 같다. 하지만, 이는 브라우저(client)에서 주소를 처리하는 <code class=\"language-text\">history api</code>를 이용하기에 그렇다.</p>\n<h2 id=\"history-api-와-client-side-routing\" style=\"position:relative;\"><a href=\"#history-api-%EC%99%80-client-side-routing\" aria-label=\"history api 와 client side routing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>history api 와 client side routing</h2>\n<p>기본적으로 browser url 탭에 주소를 입력하면, 해당 url에 매칭되는 물리 서버로 요청을 보낸다. (그리고 network 요청은 시간이 걸린다!)</p>\n<p>하지만, <strong>SPA framework에서는 서버로 요청을 보내지 않고 routing을 클라이언트에서 처리</strong>하는데 이를 <code class=\"language-text\">client side routing</code>이라고 한다. url이 바뀌어 브라우저가 서버로 요청을 보내는 것이 아닌, <code class=\"language-text\">history api</code>를 이용하여 주소만 바꾸고 이에 맞게 컨텐츠를 재구성하는 것이다!</p>\n<p>간단하게 history api에 대하여 알아보자. <code class=\"language-text\">window.history</code>로 접근할 수 있는 History객체는</p>\n<p><code class=\"language-text\">pushState</code>함수를 이용하여 현재 브라우저 탭의 url을 바꿀 수 있다. 또한, 이는 페이지가 이동한 것처럼 뒤로가기에 기존 페이지를 넣을 것이다. (stack과 유사한 구조)</p>\n<p><code class=\"language-text\">history.pushState({data : 'data'}, null, '/login')</code>를 통하여 url을 /login으로 바꾸고, 해당 페이지로 data 객체를 넣어줄 수 있다. 두번째 인자는 page title을 의미한다.</p>\n<p>이 외에도 <code class=\"language-text\">history.replaceState()</code>와 같이 기존 history stack을 지우고, 현재 인자의 값으로 대체하는 함수가 있다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/History_API\">history api MDN</a></p>\n<p>react에서는 <code class=\"language-text\">react router dom</code>과 같은 라이브러리에서 이를 기반으로 <strong>server가 아닌 client side에서 url을 바꿔주어 UI를 변경하도록 한다</strong>. 또한, 이에 대한 핸들러를 도입하여 각 url마다 다른 UI를 보여주도록 구현되어있을 것이다. 이에 웹서버로 해당 페이지에 대한 리소스를 요청하지 않아도 되니, <strong>끊김없는 페이지 이동</strong>을 경험할 수 있다. 우리가 react에서 routing을 할 때, <code class=\"language-text\">a tag</code>가 아닌 <code class=\"language-text\">Link</code>와 같은 컴포넌트를 사용하는 이유도 history api 기반으로 사용하기에 그렇다는 것을 유추해볼 수 있다!</p>\n<p>웹서버는 라우팅에 대한 처리를 하지 않고, 단순히 build된 정적인 파일을 제공해주기만 하면 될 것이다.</p>\n<p>웹 서버를 위한 express.js의 예시 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> express <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'express'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">express</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 정적 파일 서빙</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>express<span class=\"token punctuation\">.</span><span class=\"token function\">static</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'build'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 요청에 대하여 index.html을 리턴</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">sendFile</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'build'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'index.html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'server start'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">{base url}:3000/</code>로 url 요청이 왔을 때, <code class=\"language-text\">index.html</code>을 리턴하면 될 것이다. 하지만 이렇게 한다면 아래의 문제가 발생한다.</p>\n<h3 id=\"이로-인하여-발생할-수-있는-문제-feat-정적-파일-배포\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%A1%9C-%EC%9D%B8%ED%95%98%EC%97%AC-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C-feat-%EC%A0%95%EC%A0%81-%ED%8C%8C%EC%9D%BC-%EB%B0%B0%ED%8F%AC\" aria-label=\"이로 인하여 발생할 수 있는 문제 feat 정적 파일 배포 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이로 인하여 발생할 수 있는 문제 (feat. 정적 파일 배포)</h3>\n<p>예를 들어, SPA로 구현된 <code class=\"language-text\">example.com</code>이 인덱스로 존재하는 웹 사이트에서 로그인을 하기 위해 <code class=\"language-text\">example.com/login</code>으로 접속한다고 가정해보자. 만약 <strong>새로고침을 하거나, 해당 페이지로 바로 url 접근을 한다면 404 오류</strong> 등이 발생할 수 있다! (실제 서비스에는 이에 대한 처리가 다 되어있다)</p>\n<p>웹서버는 정해진 url 요청에 대하여 정해진 응답을 하도록 설계되어 있다. 하지만 위에서는 <code class=\"language-text\">/</code>에 대한 요청만 처리하고 나머지 요청은 처리하지 않으므로 그렇다. 브라우저에 url을 입력하거나, 새로고침을 한다면 기본적으로 해당 server에 요청을 하므로 서버에서는 <code class=\"language-text\">/login</code>에 대한 요청을 처리하지 않았으니, 오류가 발생한다.</p>\n<p>이에 web server에서는 다음과 같이 처리해줄 필요가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> express <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'express'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">express</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 정적 파일 서빙</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>express<span class=\"token punctuation\">.</span><span class=\"token function\">static</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'build'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 모든 요청에 대하여 index.html을 리턴. routing은 클라이언트에서 처리할 것</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">sendFile</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'build'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'index.html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'server start'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 한다면 모든 url 요청에 대하여 index.html이 처리하도록 하고, index.html에 포함된 js파일에서 routing을 처리하여 그에 맞는 페이지를 보여줄 것이다.!</p>\n<p>해당 이슈는 <code class=\"language-text\">AWS S3</code>에 리액트 빌드 파일을 업로드하고, url 접근시 build 폴더의 내용을 서빙할 때에도 발생한다. 따라서, 설정을 통하여 다른 url 요청에 대해서도(에러페이지 처리) index.html을 리턴하도록 해줘야한다.</p>\n<h2 id=\"csrclient-side-rendering\" style=\"position:relative;\"><a href=\"#csrclient-side-rendering\" aria-label=\"csrclient side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR(Client Side Rendering)</h2>\n<p>SPA는 기본적으로 <code class=\"language-text\">Client Side Rendering</code>으로 페이지가 보여지게 된다. 보통 index.html, css, js가 모든 페이지에 대한 처리를 담당하고, <u>비어있거나 내용이 없는 index.html에서 javascript가 로직에 따라 페이지를 렌더링</u>하게 된다.</p>\n<p>CSR은 보통 Client Side Routing을 포함하므로, <strong>서버에 대한 부하를 줄이고, (서버의 개입 없이) 페이지 간 이동을 즉각 처리할 수 있다는 장점</strong>이 있다. 그리고, 브라우저 캐시를 활용한다면 추가로 layout등에 대한 정보를 받을 필요가 없으므로 offline 환경에 대한 대응이 가능하다. 이는 PWA를 이용한 웹앱을 구축하는데에 도움이 된다.</p>\n<p><u>하지만, 몇가지 단점이 존재한다.</u></p>\n<p>CSR을 이용한 페이지는 <strong>처음에 js가 로드되어 렌더링될때까지 시간이 걸릴 수 있다</strong>. 사용자의 컴퓨터가 매우 느리거나(js 속도 느림) 네트워크 환경이 좋지 않다면(번들링된 큰 js파일을 받아오는 시간) 빈 화면을 오래 볼 가능성이 높아진다.</p>\n<p>또한, 페이지의 정보가 javascript에 의하여 동적으로 렌더링되므로 검색엔진에서 해당 페이지가 갖고 있는 컨텐츠에 대하여 파악하기 어려워진다. 이러한 문제는 <code class=\"language-text\">SEO</code>(Search Engine Optimization, 검색 엔진 최적화)를 수행하는데 치명적이다.</p>\n<p>정리하자면, 컨텐츠를 하나의 큰 JS파일로만 렌더링하므로 컨텐츠를 미리 알기 어렵고, 첫 화면을 마주치기 까지의 시간이 <code class=\"language-text\">MPA</code>에 비하여 오래 걸린다고 볼 수 있다.</p>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<p>SPA는 기본적으로 CSR을 사용하므로 이에 대한 장단점을 포함한다.</p>\n<ul>\n<li>장점\n<ul>\n<li>페이지 이동시 렌더링 속도 감소 (smooth UX)</li>\n<li>서버 부하 감소</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>첫 로딩 시간 지연</li>\n<li>SEO(검색 엔진 최적화) 문제</li>\n<li>클라이언트 로직이 공개되므로, DB를 직접 연결하는 등의 작업은 보안상 위험</li>\n</ul>\n</li>\n</ul>\n<p>기존에는 SPA와 반대되는 **MPA(multi page application)**를 주로 사용하였다.</p>\n<p><code class=\"language-text\">MPA</code>는 여러 html파일을 서버에서 만들고,(server side rendering) 각 페이지 별로 서버에서 리턴하는 방식으로 SPA의 장단점과 상충된다.</p>\n<p>그렇다면 SPA를 개선할 수 있는 방법에 대하여 알아보자! MPA에서 사용하는 기법들을 일부 차용할 수 있을 것이다.</p>\n<h1 id=\"spa-개선하기\" style=\"position:relative;\"><a href=\"#spa-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0\" aria-label=\"spa 개선하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SPA 개선하기</h1>\n<p>SPA의 단점을 보완할 수 있는 몇가지 방법이 있다. <code class=\"language-text\">react.js</code>를 기준으로 간단하게 알아보자.</p>\n<h2 id=\"code-splitting\" style=\"position:relative;\"><a href=\"#code-splitting\" aria-label=\"code splitting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>code splitting</h2>\n<p><u>로딩 시간 지연</u>을 해결하기 위한 가장 간단한 방법이다. 이는 첫 진입 시점에 모든 코드를 받아오는 것이 아니라, 필요 시점에 lazy하게 코드를 받아오는 것이라고 생각하면 된다. 이를 위한 몇가지 방법에 대하여 간단하게 알아보자.</p>\n<ol>\n<li>\n<p>dynamic import</p>\n<p>보통 import를 통하여 함수 또는 컴포넌트를 가져오는데, 이를 동적으로 가져오는 방법이 있다. 보통 import를 맨 위에 사용하지만, 이를 비동기 함수처럼 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./sum'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sum</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>heavy한 모듈의 경우, 필요한 시점에 import되도록 하면 그 시점에 서버에서 가져올 수 있다! 리액트 컴포넌트를 동적으로 불러올 때에는 아래의 방법을 도입해볼 수 있다.</p>\n</li>\n<li>\n<p>react lazy &#x26; Suspense</p>\n<blockquote>\n<p><code class=\"language-text\">lazy</code> lets you defer loading component’s code until it is rendered for the first time.</p>\n<ul>\n<li>공식문서</li>\n</ul>\n</blockquote>\n<p><code class=\"language-text\">lazy</code>함수는 React에서 동적으로 컴포넌트를 로드해올 때 사용하는 함수이다. <code class=\"language-text\">Suspense</code> 컴포넌트는 로딩에 대한 UI을 <code class=\"language-text\">fallback</code>으로 분리시킨 컴포넌트로 리액트 18버전부터 정식 제공된다.</p>\n<p>바로 공식문서의 예제를 보며 이해해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState<span class=\"token punctuation\">,</span> Suspense<span class=\"token punctuation\">,</span> lazy <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Loading <span class=\"token keyword\">from</span> <span class=\"token string\">'./Loading.js'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> MarkdownPreview <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">delayForDemo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./MarkdownPreview.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">MarkdownEditor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>showPreview<span class=\"token punctuation\">,</span> setShowPreview<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>markdown<span class=\"token punctuation\">,</span> setMarkdown<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, **world**!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>textarea value<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>markdown<span class=\"token punctuation\">}</span> onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token function\">setMarkdown</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>label<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkbox\"</span> checked<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>showPreview<span class=\"token punctuation\">}</span> onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token function\">setShowPreview</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>checked<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        Show preview\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>label<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>hr <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>showPreview <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>Loading <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>h2<span class=\"token operator\">></span>Preview<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h2<span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>MarkdownPreview markdown<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>markdown<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Suspense<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Add a fixed delay so you can see the loading state</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">delayForDemo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">promise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> promise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>MarkdownPreview 컴포넌트는 고의적으로 2초이후에 import 될 것이다. 그동안, <code class=\"language-text\">fallback</code>으로 지정된 Loading 컴포넌트가 보여진다. (Suspense는 로딩 UI를 분리하여 관심있는 데이터만 관리할 수 있다는 장점이 있음)</p>\n<p>여기서, MarkdownPreview 컴포넌트는 <strong>lazy 로딩 되므로 최초의 필요 시점에 따로 번들링되어 로드될 것</strong>이다. 이를 통해 routing이 일어나는 시점 이외에도 용량이 큰 코드 데이터를 불러오는 시점을 지정할 수 있을 것이다.! 이는 <u>라우팅 컴포넌트에서 사용되면 매우 좋을 것이다</u>. 물론 약간의 로딩은 걸리겠지만, 기존 CSR방식처럼 처음의 빈 화면이 나오는 시간을 줄일 수 있을 것이다.</p>\n<p>Suspense와 lazy를 이용하면 <code class=\"language-text\">HTTP stream</code>을 이용하여 데이터를 동적으로 유연하게 가져온다고 하는데, 이에 대하여는 더 공부해볼 필요가 있을 것 같다.</p>\n<p><a href=\"https://react.dev/reference/react/lazy\">공식문서-lazy</a></p>\n</li>\n<li>\n<p>code splitting with webpack</p>\n<p>우리가 사용하는 js 프레임워크는 보통 <code class=\"language-text\">webpack</code>이라는 번들러를 통하여 수많은 js파일을 합쳐 빌드되도록 최적화되어있다.</p>\n<p>webpack 설정을 통하여 code splitting을 구현할 수 있다고 하니 참고하자.</p>\n<p><a href=\"https://webpack.js.org/guides/code-splitting/\">공식문서</a></p>\n</li>\n</ol>\n<p>하지만 모든 파일을 split하여 전송한다면 그것 역시 좋지는 않을 것이, <strong>번들러의 이유가 사라진다</strong>. 따라서, <u>라우팅 컴포넌트에만 우선 적용을 하고, 상황에 맞게 도입하는 것이 권장</u>된다.</p>\n<h2 id=\"pre-renderingssr--ssg\" style=\"position:relative;\"><a href=\"#pre-renderingssr--ssg\" aria-label=\"pre renderingssr  ssg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-Rendering(SSR + SSG)</h2>\n<h3 id=\"server-side-rendering\" style=\"position:relative;\"><a href=\"#server-side-rendering\" aria-label=\"server side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server Side Rendering</h3>\n<p>다음에는 Client Side Rendering과 대척점인 Server Side Rendering에 대하여 알아보자. 이는 클라이언트에서 렌더링하지 않고, <strong>서버에서 미리 렌더링하여 완성된 html파일을 클라이언트에게 보내는 것</strong>이다. 서버속도와 네트워크 속도가 빠르다면, 컴퓨팅 성능이 좋지 않아도 바로 페이지의 컨텐츠를 확인할 수 있으며, 검색엔진 최적화에도 좋다.</p>\n<p>이러한 pre rendering logic은 <a href=\"https://react.dev/reference/react-dom/server\">server-side react api</a>를 참고한다.</p>\n<p><code class=\"language-text\">react-dom</code> 패키지의 <code class=\"language-text\">renderToString()</code>을 통하여 리액트 코드를 완성된 html 문자열로 만들 수 있다. 만약 wait해야할 데이터가 있어 Suspense 컴포넌트가 존재한다면, <code class=\"language-text\">renderToPipeableStream()</code> 함수를 이용하여 필요한 시점에 HTTP stream을 통하여 코드를 나눠 보낼 수 있다고 한다. 이를 통하여 서버에서 요청 시점에 html파일을 만들어 처리하면 <code class=\"language-text\">SEO</code>문제를 해결할 수 있고, 네트워크 속도만 빠르다면 즉시 화면을 볼 수 있다는 장점 또한 있을 것이다.</p>\n<p>하지만, 이는 서버가 매 요청 시점마다 html파일을 만들어줘야 하므로 서버의 부하가 커질 수 있다. 또한, <u>모든 페이지 이동에 대하여 SSR을 수행하도록 하면 결국 MPA랑 같아지므로 이의 단점을 모두 수용하게 된다</u>. 이에 개선안이 제안된다.</p>\n<h3 id=\"hydration\" style=\"position:relative;\"><a href=\"#hydration\" aria-label=\"hydration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hydration!</h3>\n<blockquote>\n<p>미리 도착한 정적인 DOM에 물을 부어 동적인 웹사이트를 만들자!</p>\n</blockquote>\n<p><strong>서버에서 렌더링한 html로 초기 페이지를 보여주고, 이후 로드된 js파일로 앞으로의 렌더링을 책임진다</strong>. 사용자는 빈 화면을 볼 시간이 더 줄어들고, 이후 페이지 이동은 CSR처럼 부드러울 것이다!</p>\n<p>간단한 SSR과 hydration의 과정을 살펴보자. 페이지에 최초 접속하는 상황을 가정하자.</p>\n<ol>\n<li>서버에서 SSR된 html 파일이 클라이언트에게 전송되고, <strong>브라우저에서 바로 정적인 첫 화면을 볼 수 있</strong>다.</li>\n<li>하지만, 아직 html뿐이므로 interactive한 일(event 등)은 처리되지 않고, <strong>화면이 동작하는 것처럼만</strong> 보인다. (이 시간을 uncanny valley,불쾌한 골짜기 라고도 함)</li>\n<li>이후 <strong>도착한 번들링된 js파일을 통하여 동적 요소를 초기화</strong>한다. 이때, event listener나 state 등이 초기화되고, <strong>동적인 interaction이 가능</strong>해진다.</li>\n<li>앞으로의 동작들은 <strong>SPA와 같이 동작</strong>한다.</li>\n</ol>\n<p><img src=\"https://blog.saeloun.com/images/useId/server_side_rendering.png\" alt=\"img\"></p>\n<p>이를 통해 빈 화면을 보는 시간이 줄어들게 될 것이다! 이를 위해 <code class=\"language-text\">ReactDOM</code>라이브러리에서는 <code class=\"language-text\">hydrate()</code>함수를 제공한다.</p>\n<p>하지만, html이 모두 렌더링되고 js가 로드되고, 그 이후에 hydrate을 수행하므로 <em>실제 동적인 페이지가 되기까지의 시간은 오래걸릴 수</em> 있다는 지적이 있다.</p>\n<p>이를 해결하기 위해, 위에서 언급한 <code class=\"language-text\">Suspense</code>와, Web Server에서 <code class=\"language-text\">renderToPipeableStream</code>으로 데이터를 전송하는 방식이 제안된다!</p>\n<p>예를 들어, 다음과 같은 구조의 컴포넌트가 있다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">NavBar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Sidebar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Post</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>여기서, Comments 컴포넌트에는 많은 js 로직과 오래걸리는 api 요청이 포함되어있다고 가정하자. 그렇다면, <em>최초 렌더링 이후 js가 실행되면서 오랜 시간이 걸려 그동안 사용자는 상호작용하지 못한다.</em></p>\n<p>우선, 웹서버는 <code class=\"language-text\">renderToString</code>이 아닌 <code class=\"language-text\">renderToPipeableStream</code>으로 html을 렌더링하여 보내도록 한다. 이는 웹서버에서 컴포넌트를 렌더링하면서 <strong>스트리밍의 형태로 조각조각 보내게 되어 모든 로드를 기다리지 않고 hydration을 수행</strong>할 것이다. 또한 Comments와 같은 <strong>값비싼 컴포넌트를 Suspense로 감싸서 SSR단계에서는 fallback 컴포넌트만 렌더링하여 보내도록 한다</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">NavBar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Sidebar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Post</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Comments는 Spinner(로딩) 컴포넌트로 대체되어 streaming의 형태로 SSR되어 보내지고, Comments는 hydration 단계에서 비동기적으로 업데이트 될 것이다. 또한 해당 컴포넌트를 lazy하게 splitting하여 가져올 수도 있다.!</p>\n<p>이 정도의 개념만 알아도 SSR 과 hydration에 대한 간단한 개념은 이해된 것 같다.</p>\n<h3 id=\"static-site-generation\" style=\"position:relative;\"><a href=\"#static-site-generation\" aria-label=\"static site generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Site Generation</h3>\n<p>또한, 서버의 부하를 줄이기 위해 초기에 동적인 데이터가 없는 경우, 빌드 단계에서 페이지를 구성하여 서버에서는 정적자원만 리턴해주는 <code class=\"language-text\">static site generation</code>이라는 방법도 존재한다. 이 경우, build 시점에 고정된 html 파일이 나오고, 요청시 html파일과 js파일을 넘겨주기만 하면 된다. (서버는 static server 역할만 수행) 이후, 클라이언트는 바로 초기 페이지를 마주칠 수 있고, js파일을 통하여 hydration하여 이후 페이지 이동에 있어서 CSR의 장점을 가져갈 수 있다.</p>\n<p>또한, <strong>CDN(Content Delivery Network)서버를 이용하여 빌드 파일을 캐싱해놓는다면 비용 측면에서도 매우 효율적</strong>일 수 있다. SSG + hydration의 조합이 좋아보이지만, 이는 페이지가 바뀔때마다 빌드를 해줘야하는 불편함이 있을 수 있다.</p>\n<h2 id=\"seo-최적화\" style=\"position:relative;\"><a href=\"#seo-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"seo 최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SEO 최적화</h2>\n<p>위의 내용은 비교적 구현하기 어려운 부분이 있다. 만약, 이미 CSR 기반의 react로 빌드를 해놓은 상태이고, 무언가를 도입하기 어려운 시점이라면 최소한 이것들은 해주면 좋을 것이다.</p>\n<h3 id=\"robotstxt\" style=\"position:relative;\"><a href=\"#robotstxt\" aria-label=\"robotstxt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>robots.txt</h3>\n<p>검색엔진은 어떤 주소에 접근할 때, <code class=\"language-text\">test.com/robots.txt</code>로 해당 주소의 robots.txt파일을 읽어와 간단한 정보를 파악한다. 예를 들어, 내 블로그의 주소인 <code class=\"language-text\">choieastsea.github.io/robots.txt</code>에 접근하면 다음과 같은 결과가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">User-agent: *\nSitemap: https://choieastsea.github.io/sitemap/sitemap-index.xml\nHost: https://choieastsea.github.io</code></pre></div>\n<p>이는 검색엔진에게 허용하거나 허용하지 않는 부분에 대하여 명시한다. 또한,  <code class=\"language-text\">sitemap.xml</code>파일의 위치에 대하여 알려준다.</p>\n<h3 id=\"sitemapxml\" style=\"position:relative;\"><a href=\"#sitemapxml\" aria-label=\"sitemapxml permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sitemap.xml</h3>\n<p>이는 검색엔진이 사이트의 컨텐츠를 파악하기 위한 index라고 생각하면 편하다. 내 블로그에서도 이를 제공하는데, <code class=\"language-text\">https://choieastsea.github.io/sitemap/sitemap-index.xml</code>로 접속하면 아래와 같은 목록들이 나온다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGklEQVQoz41Sa2+CQBDk//85FcoXlQLhDk7BgLyRx5jZFNOmanvJZJewOzczYEVRBK01EmOQJAZ93+PZWZYF/zmW533C9wMcjkfYtoPL5YJ5njEMA8ZxlAumaXqQ/gUryzKczymu1yuapkWeF8jzXIiLokAcx6jr+qnKX6pJGEVKlqjm3fmugoo5z55u2LOKwg/XRRAEUEohDEPJs21bdF2HlvjqVzAKuqCz2+0mbvb7g+RPYst1XRCO40g9nU6igMOvwFxJzLmyqqC0hjFGni3P8+D7/gPMblXyDCTke5JSUdM0SLNMlIrCzWaD3W4H27al0jY/EBffERIkKMsKSmlx9oOQlrfbLdI0lXBf2eXSqlAslyX4L6+W78WatDPEGaz7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sitemap\"\n        title=\"sitemap\"\n        src=\"/static/2dcfc6d9a2e826513b27fa97e11b854c/37523/sitemap.png\"\n        srcset=\"/static/2dcfc6d9a2e826513b27fa97e11b854c/e9ff0/sitemap.png 180w,\n/static/2dcfc6d9a2e826513b27fa97e11b854c/f21e7/sitemap.png 360w,\n/static/2dcfc6d9a2e826513b27fa97e11b854c/37523/sitemap.png 720w,\n/static/2dcfc6d9a2e826513b27fa97e11b854c/302a4/sitemap.png 1080w,\n/static/2dcfc6d9a2e826513b27fa97e11b854c/07a9c/sitemap.png 1440w,\n/static/2dcfc6d9a2e826513b27fa97e11b854c/6b26f/sitemap.png 1658w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이는 검색엔진이 사이트의 컨텐츠 정보와 주소를 파악하기 쉽게 해준다. 나는 build와 deploy과정에서 이를 만들어주는 자동화 툴이 포함된 블로그 테마를 이용중이기에 이렇게 깔끔하게 나오지만, 그것이 아니라면 관례를 따라 적어주는 것이 SEO에 좋을 것이다.</p>\n<h1 id=\"정리하며\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EB%A9%B0\" aria-label=\"정리하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리하며…</h1>\n<p>오늘 많은 내용에 대하여 공부해보았는데,,, 그럼 SPA와 MPA 사이에 정답은 있는가?</p>\n<p>절대적인 정답은 없고, <strong>상황에 맞게 장점을 차용하는 식으로 구현하는 것이 현명한 선택</strong>일 것이다. 실제 서비스 중에서도 SPA로만 구현된 것은 없을 것이고, 그렇다고 모두 같은 방식으로 구현되어 있지 않을 것이다.</p>\n<p>또한 Next JS와 같은 웹 프레임워크는 frontend server를 위하여 react.js를 기반으로 UI를 구성하고 상황에 맞게 server side rendering이나 static generation을 도입하도록 지원하므로, 이러한 프레임워크의 도움을 받을 수도 있을 것이다.</p>\n<p>결론적으로, 기술적 기반을 이해하고 장단점을 설명할 수 있다면, 상황에 맞는 방법을 선택할 수 있다고 생각하므로 꼭 익혀두자.</p>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<p><a href=\"https://www.zerocho.com/category/HTML&#x26;DOM/post/599d2fb635814200189fe1a7\">History Api 사용 예제</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=JU6sl_yyZqs\">React Lazy Loading 관련 영상</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=kZG3izJu7qE\">Hydration 관련 영상</a></p>\n<p><a href=\"https://blog.saeloun.com/2022/01/20/new-suspense-ssr-architecture-in-react-18/\">SSR + Suspense</a></p>","frontmatter":{"date":"November 08, 2023","title":"(WEB) SPA에 대하여 (장단점, routing, 개선방법)","categories":"WEB","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/WEB-SPA/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(9-1)-Paging/","nextSlug":"/OS(8)-Mechanism of Address Translation/","prevSlug":"/WEB-SPA/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}