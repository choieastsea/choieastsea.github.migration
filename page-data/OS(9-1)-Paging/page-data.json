{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(9-1)-Paging/",
    "result": {"data":{"cur":{"id":"8869d9e9-0598-5a31-9918-2c90927ba1e3","html":"<p>오늘은 <code class=\"language-text\">Paging</code> 기술에 대하여 알아보자. 저번까지 우리는 <code class=\"language-text\">base and bound</code> 방식으로 프로세스에게 메모리 가상화를 제공하고, <code class=\"language-text\">MMU</code>에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 <strong>internal fragment가 많이 발생</strong>하여 <code class=\"language-text\">segmentation</code>에 대하여도 알아보았다.</p>\n<p>segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 <strong>고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안</strong>된다.</p>\n<h1 id=\"paging\" style=\"position:relative;\"><a href=\"#paging\" aria-label=\"paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Paging</h1>\n<p>memory address를 여러개의 (비교적 작은) 고정된 크기의 <code class=\"language-text\">pages</code>로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 <strong>고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에 배치하는 것</strong>이다.</p>\n<p>예를 들어, Process의 address space는 아래와 같이 page로 나뉘어 물리 공간에 존재하게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+ElEQVQ4y4WT2W6jQBBF/f9/lEkyL85jlMiKwQ7xztpNAyaAV8wZVdvKMsqCdEVLiFt3qe5tNhuSJCFNU7TWxHFM0zT89HRd9y16URRxdfWH6+trbm//cnNzy3K5RGn9NigIAoIwJAwjtNI/DuvJT47jMBgMeHh4xHVHyJB1UWCMoa4r2ralPR5pTyeOwLE7cTge2W637HY7Cznv93t6osD3fZ6fn3FHI3vWYj/LSNKUsq7fx7ctXVlyUAlFEFA1jY1HINFJXL31eo3WitVqZS2KqrXjYCYTMt/nNY7p8hyCgC6OIc9oJAqlqKrqE6FE0yuKwpYhhFEckpqU0nXJ+n3yuzs2j490xpzLuAjdRBFmtaK+EAmhWA7D8Gx5Op0yHA4t5vM5KgxJ8xxdFJR5fibUmk5r8Dy2kwkmjr8mlNaExPM8XNdlsViglLKl5L5PlSRny/f3dP0+PD1RuS6pfKtrS1bX9WfLwjyZTvEDnyiOKB2H1/EYM5tSjkZ07giaxloWNHGEuZSy+ZChVZgoxWw2YzweMxw6Vq20W2QZhefxuli8ZcfpZJe32W3Z7ffW5v/oKXUu5OXlxZKufJ/U8zCDAWa5tGsjJMhN+NjMd4udZZnNTEjlbdKUaj5HK2WLqavq1+v26eqJzMPh8AbZ9vaLu/urtIvCf5ou22MG1zpkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"page\"\n        title=\"page\"\n        src=\"/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png\"\n        srcset=\"/static/9362b1135cf233e4857c9d4480f3d9a7/e9ff0/page.png 180w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/f21e7/page.png 360w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/37523/page.png 720w,\n/static/9362b1135cf233e4857c9d4480f3d9a7/33e10/page.png 844w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>오른쪽은 가상 공간을 의미하며, 왼쪽은 실제 address space(AS)의 page가 물리적인 공간의 page frame에 배치되는 것을 의미한다.</p>\n<p>이렇게 고정된 크기의 페이지를 배치함으로써 external fragment를 줄일 수 있지만, page의 크기가 고정이므로 internal fragement가 존재할 수 있다. (하지만 하나로 배치하는 것보다는 적을 것임)</p>\n<h1 id=\"page-table\" style=\"position:relative;\"><a href=\"#page-table\" aria-label=\"page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table</h1>\n<p>위의 그림을 보면, virtual page는 physical page frame에 매칭이 된다. 이러한 매핑 정보는 <code class=\"language-text\">Page Table</code>에 저장하여 translation에 사용한다.</p>\n<p>예를 들어, page table에 3,7,5,2의 배열의 형태로 저장되어 있다면 해당 4개의 가상 페이지의 실제 page frame number가 3,7,5,2임을 의미한다. page table 역시 메모리 구조에 존재해야하므로 OS의 memory 공간에 저장되어, <code class=\"language-text\">MMU</code>가 접근할 수 있도록 한다. OS는 <code class=\"language-text\">context switch</code>가 일어날 때, page table의 값을 업데이트하여 관리할 것이다. (기존 PT는?)</p>\n<h2 id=\"page-table-entrypte\" style=\"position:relative;\"><a href=\"#page-table-entrypte\" aria-label=\"page table entrypte permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table Entry(PTE)</h2>\n<p>page table은 보통 배열의 형태로 존재하는데, 각 원소를 page table entry(PTE)라고 부른다. PTE의 인덱스는 VPN(virtual page number)를 의미하고, 값은 PFN(Page Frame Number), 즉 물리적인 위치를 포함한다.</p>\n<p>PFN 말고도 해당 Page Frame에 대한 추가적인 정보가 비트의 형태로 존재하는데, 다음과 같다.</p>\n<ul>\n<li>Valid Bit : 해당 page가 프로세스에 의해 사용되었는지? 가능한 address space에 비하여 실제 사용하는 페이지 수는 한정적이므로 유효한 페이지인지를 기록</li>\n<li>Protection Bits : R/W 권한</li>\n<li>Present Bit : page가 memory에 존재하는지 (swap space에 있는지?)</li>\n<li>Dirty Bit : 메모리에 적재된 이후에 해당 page가 변경된 적이 있는지</li>\n<li>Accessed Bit : 최근에 해당 page가 접근된적 있는지</li>\n</ul>\n<p>이러한 PTE의 값은 다음에 자세히 알아보자.</p>\n<h2 id=\"address-translation-in-hw\" style=\"position:relative;\"><a href=\"#address-translation-in-hw\" aria-label=\"address translation in hw permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address translation in H/W</h2>\n<p>가상 주소는 MMU에서 Page Table의 값에 따라 실제 물리 주소로 변경된다. 그 과정을 간단하게 알아보자.</p>\n<p>한 페이지의 크기가 16B이고, 가상 주소의 크기는 64B라고 가정해보자.</p>\n<p>저 두 단서로만 우리가 알 수 있는 조건은 다음과 같다.</p>\n<ul>\n<li>한 프로세스는 4페이지를 갖는다 (64 / 16 = 4)</li>\n<li>2^6B만큼 주소를 표현할 수 있어야하므로, 주소는 6비트로 표현 가능하다</li>\n<li>가상 주소에서 앞부분은 VPN을 의미하며, 뒷부분은 offset(page 안에서의 오프셋)을 의미하므로, 상위 2비트는 VPN을 의미한다(4개 페이지 존재하므로)</li>\n</ul>\n<p>PA로 변환하기까지의 그림은 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmUlEQVQ4y33U2W4iQQwFUP7/43jhBSHEFgj7DmGnRseSexgyiaXSrXLZt7x1157PZyHwfZHxeFxarVZ1vt/vgdPptDQajbLf7+P8eDwCa0n2Lgw+Pz9Lt9stzWazfHx8xN4Do9Go9Hq9IKRnBxeLRam9vsx4MpnExel0itePx2Ps4Xa7jfX19VWu12vod7tdZXc4HP4SQkTL5bKsVqtwYsjBYgzX63U4u0funPf0P6ZMGEkPMUQgCwTO5/O5DAaDIOr3++V2u/0boaV2DJUA0XA4jNQ4wvl8HukqDXHPD1ZNeY0SmcgyBYiYHpmyXC6XilAzPA5/JCRqqXudTie6S34j/DVCNYLZRVFqArJ3QkTfCNUt65fDrHtIs4aJs9ksasiGqC3fKuX/dViqIlE7hqKEuowYOntAOWSgNNFlBJQ+JWlw1gxk0rR/1W02m2rYc9DzvppDrxlmaeagpqPX6ThqlMiTIHV5T/8tZWFnN6VnYO1lYJgRqKPle2ZrOQui9v6nye86h7XdbscjGmbZZ+Pq9XpkloHw+QOs+IEATb9oaAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png\"\n        srcset=\"/static/1298585682d7000b228ce325b1aa32a9/e9ff0/VA.png 180w,\n/static/1298585682d7000b228ce325b1aa32a9/f21e7/VA.png 360w,\n/static/1298585682d7000b228ce325b1aa32a9/37523/VA.png 720w,\n/static/1298585682d7000b228ce325b1aa32a9/4ef49/VA.png 890w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 VPN은 MMU에서 PFN(Page Frame Number)로 대체되어 물리 주소 값은 PFN + offset로 구성될 것이다.</p>\n<p>예를 들어 가상 주소가 010101이라면, 해당 주소는 프로세스의 1번째 페이지 중 5번째(0101 = 5)에 위치해있을 것이다. 0번째 페이지의 실제 위치는 Page Table의 0번째 줄을 보면 알 수 있다.</p>\n<p>이를 통하여 하나의 Page Table에는 4개의 <code class=\"language-text\">PTE</code>가 존재한다는 것도 유추할 수 있다. 또한, 물리주소의 PFN이 3비트인 것으로 보아, 해당 시스템에서는 가능한 Page Frame이 8(2^3)개 라는 것도 유추할 수 있다.</p>\n<h2 id=\"page-table의-단점은-없는가\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%80-%EC%97%86%EB%8A%94%EA%B0%80\" aria-label=\"page table의 단점은 없는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 단점은 없는가</h2>\n<p>정리하면, 메모리 주소가 변환되는 과정은 다음과 같을 것이다.</p>\n<ul>\n<li>CPU에서 코드, 데이터 등이 위치한 가상 주소를 보고 요청한다.</li>\n<li>MMU는 VA를 PA로 바꿔준다.\n<ul>\n<li>memory에 위치한 Page Table을 보고, VPN을 PFN으로 바꾸어 Physical Address를 얻는다</li>\n<li>실제 메모리에 접근하여 코드나 데이터를 fetch해온다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"속도-overhead\" style=\"position:relative;\"><a href=\"#%EC%86%8D%EB%8F%84-overhead\" aria-label=\"속도 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속도 overhead</h3>\n<p>이와 같이, 실제 물리 주소를 접근하는 과정에서 VA를 PA로 바꾸고, 이 과정에서 overhead는 발생할 수밖에 없다. Page Table역시 메모리에 존재하므로, 메모리에 두번씩이나 접근해야하는데 이는 썩 좋은 방법은 아닌 것 같다.</p>\n<h3 id=\"공간-overhead\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84-overhead\" aria-label=\"공간 overhead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간 overhead</h3>\n<p>또한 페이지 테이블의 크기는 작지 않다. 과거 자주 쓰이던 32bit 주소 체계에서는 보통 20bit은 VPN, 12bit는 offset으로 구성된다. 이 경우, Page Table Entry(PTE)의 갯수는 프로세스 하나당 2^20개가 필요하다. 보통 한 PTE에 4B를 차지한다고 한다면 4*2^20Byte, 즉 하나의 프로세스 당 주소 변환을 위하여 2^22 = 4MB의 공간이 필요하게 된다.</p>\n<p>최근 사용하는 64비트 주소 공간에 대하여 생각하면 페이지 테이블 하나만 저장하기 위해 GB 단위 이상을 사용해야할 것이다…</p>\n<p>그렇다면, 이를 개선할 방법은 없을까?! 속도를 개선하기 위해서는 VA-PA 쌍을 캐싱해두는 방법이 있다. 사이즈를 개선하기 위한 방법은 다음에 알아보고, 우선 caching을 통하여 속도를 개선하는 <code class=\"language-text\">TLB</code>에 대하여 알아보자.</p>\n<h1 id=\"translation-lookaside-buffer-tlb\" style=\"position:relative;\"><a href=\"#translation-lookaside-buffer-tlb\" aria-label=\"translation lookaside buffer tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Translation Lookaside Buffer (TLB)</h1>\n<p><code class=\"language-text\">MMU</code>에서 <code class=\"language-text\">PTE</code>를 일부 캐싱해놓는 곳을 <code class=\"language-text\">TLB</code>라고 한다. (TLB는 MMU의 일부이다) 자주 참조되는 PTE를 저장해놓는 소형 <u>하드웨어 캐시</u>로, <code class=\"language-text\">address-translation-cache</code>라고도 불린다.</p>\n<p>기본적으로 VA에서 PA로 전환하는 과정에서 memory가 아닌 <code class=\"language-text\">TLB</code>를 먼저 보고, TLB hit이 발생한다면 page table에 접근하지 않아도 된다! 하지만, TLB miss가 발생한다면 메모리에 다시 접근해야하므로 **지역성(locality)에 근거한 캐시 정책(LRU 등)**이 활용될 수 있을 것이다.</p>\n<p>또한 TLB는 MMU에 존재하는 캐시이므로, <code class=\"language-text\">context switching</code>이 발생하는 경우에는 기존 entry를 비활성화하고, 새로운 page table의 PTE로 교체해야할 것이다. 이를 위해 <code class=\"language-text\">TLB valid bit</code>를 사용한다. (이는 PTE의 valid bit와 다르다!)</p>\n<h2 id=\"page-table의-크기를-줄이는-방법\" style=\"position:relative;\"><a href=\"#page-table%EC%9D%98-%ED%81%AC%EA%B8%B0%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"page table의 크기를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Table의 크기를 줄이는 방법?</h2>\n<p>TLB는 page table의 단점 중 하나인 시간 overhead는 줄일 수 있는 HW적인 방법이다. 하지만, 공간 overhead를 줄이기 위해서는 어떻게 해야할까?</p>\n<p>가장 간단한 해결책은 <strong>page 하나의 크기를 늘리고, entry를 줄여 page table의 크기 자체를 줄일 수 있을 것</strong>이다. 페이지가 n배 커질수록, page table의 크기는 1/n배로 줄어들 것이다.</p>\n<p>하지만, 이는 앞서 연속된 하나의 주소 공간을 제공하던 방법과 마찬가지로 <code class=\"language-text\">internal fragmentation</code>(내부 단편화)의 문제가 발생하여 메모리 공간 부족이 나타날 수 있다.</p>\n<p>이를 해결할 수 있는 몇가지 방법이 있는데, paging과 segmentation을 결합한 <code class=\"language-text\">hybrid approach</code>, 그리고 <code class=\"language-text\">multi-level page table</code>기법이 제안된다. 이는 다음에 자세히 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"오늘은  기술에 대하여 알아보자. 저번까지 우리는  방식으로 프로세스에게 메모리 가상화를 제공하고, 에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 internal fragment가 많이 발생하여 에 대하여도 알아보았다. segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안된다. Paging memory address를 여러개의 (비교적 작은) 고정된 크기의 로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에…","frontmatter":{"date":"October 30, 2023","title":"(OS) 운영체제 복습 [9-1. Paging]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(9-1)-Paging/"}},"next":{"id":"dbf838fa-a84b-5baa-8fd9-b484a510bf52","html":"<p>MMU에서 Virtual Address에서 Physical Address로 변환되는 메커니즘을 간단한 함수의 실행과 함께 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span>\n\tx <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 함수가 실행되는 프로세스를 생각하면 OS는 아래와 같은 address space를 제공할 것이다. (프로세스마다 기본적으로 16KB만큼을 할당해준다고 가정하자)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 296.6666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAA7CAYAAAB7c6ruAAAACXBIWXMAABYlAAAWJQFJUiTwAAADwUlEQVRYw9WY107rQBCG8/4vA5FAcAGIqoQuWoDQe++9ztE3R7+12diJUy7OWWlke8u/U3dnXNjf37fd3V0rlUrG+/v7u93e3trj46Pd3Nw4XV9f2/39vRNjd3d39vT0lPRBzPv8/LTC2dmZnZ+f28rKis3Pz9v09LRtb2/b2tqabWxseN/i4qLNzc3ZwsKCXV1dJfOen5/t9/fXaGzw+vpqBQvaxcWFTU5O2t7ens3OzjooQHC+vr7ufQDSvr+/w6X28vLyF/Dj48MgxICzqakp29zctKWlJX/OzMw48NHRkU1MTLgkcL6zs2Nvb2/1gOgHHfb19TnI6emp64l+RLq8vLSTkxNfQB9jx8fHhqrQWR0gOvj5+XEuaRgjFIcx2tfXl/eLK/r5lg7ZvE6HNEQPARFbhuJ9aGjIDg4OXBVwqcZGDoiITMBt6MQFAGVHLIcRWIjBEB+iD8/gyRzEZZw1BfRzeHjoXAjw4eEh2RG/bESA8US/vKeKLL210hKRsRQEOg0OZT0ULtIiGSUeS4yytbXlvlUsFl0fUAgYWnp1ddXnpgEmbiMd4F8sbMQh85py2HUdYmVchwMA59bpAefsGpJUEvcBhDu521SrVQ+9sbExH4BDNmECvgXhc7gSrjUyMuLRJN+UP3KgAF4nss4/AMQtm8A9UoyPj7uO0bnGtIFzKMVKb0xkR02G2IRYHhwctJ6eHn9nU8aYz+ZIVQMoa7E4BoTQqdyGhTq5IQCxgwNK1CzA8OiXEUKwlgBjLgGKwaTDhoC6lOKFWdSQQ53WeQA1p8Yo7QKG4w0B84gcjzUFTHObLLA6P0wTOQswra8pYBaHWRwLMLdjNwJrO1I68sOsSFGUpEVLy5HCOzEMJzwB4L2tSOHJWcdJQxbGkwwCAIHmjhQlnpzo5XLZU7rR0VHPE0lNGGvbD1kESdxY5LYjpWuO3SxSWnLs/z9Scjt2XsN07U4Jr4CO75RQgo7vlFgdHV8B8Sn070RKHMMdRQqLOMZ0bOmQrQPMk32pFu7v77fe3t7UdK6GwxCQCQDExxQJJ3Uyma4STiWlnOJJwhkXiYDFKTGTWUwtPTAwkABovCYlZlfybIrC5eVl54zaWPkzxGI24OSmruFdfwLCMQdULNKpiyiu1lsqK5qVt6F+w5ZZ+FQqFZefi4cSl1wa9qmHsZwaRmEepQWGiDer+UUAUTNzTcqqKJoJalgWg6Fb9acCdqs0SwBVMsCR/IoiUf8UeIr4Tuur+W/DnxBqj+HhYf8vwwT9/chLUhF6/gOys5fZzublKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png\"\n        srcset=\"/static/23122becc17c9e94b52ff2a3983884a3/e9ff0/VA.png 180w,\n/static/23122becc17c9e94b52ff2a3983884a3/f21e7/VA.png 360w,\n/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png 436w\"\n        sizes=\"(max-width: 436px) 100vw, 436px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>x 변수는 stack영역에 저장되고, 컴파일된 명령어는 code 영역에 존재할 것이다. 이 과정에서 Address Translation이 어떤 식으로 이루어질지 생각해보자.</p>\n<h1 id=\"dynamic-relocation\" style=\"position:relative;\"><a href=\"#dynamic-relocation\" aria-label=\"dynamic relocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Relocation</h1>\n<p>이러한 주소의 배치는 프로세스 실행 이후에 address space가 변경될 수 있으니, dynamic relocation(동적 재배치)라고 불린다.</p>\n<h2 id=\"base-and-bound-하드웨어-기반\" style=\"position:relative;\"><a href=\"#base-and-bound-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B8%B0%EB%B0%98\" aria-label=\"base and bound 하드웨어 기반 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>base and bound (하드웨어 기반)</h2>\n<p>가장 단순한 방법으로는 위의 <strong>프로세스의 메모리 공간을 그대로 연속적인 하나의 물리적 공간에 매핑시키는 방법</strong>이 있을 것이다. 16KB가 연속적으로 남는 공간을 찾아서 그곳에 프로세스의 공간을 할당하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 143.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAADM0lEQVRIx42V505qURCFef9n8B8J0WDAoCRKIKBiw9ARFRsWilJERbHh3HxzM+QcDhpOsrMLe69Zs6bge3t7k1arJf1+X+z7/v6Wr6+vucbPz4++sdnXbDYlHo9LoVDQg+FwKNvb23JwcCD7+/u/Dn7n3vn5ub4bj8f/AY2VWXh6epKdnR2pVqtSLBalVCpNRrlcdq2z2awcHx+7AQGyYYC7u7tSqVTk5ORETk9P9REzIKw5r9VqksvldD0XYCQSEb/fL8vLyxIIBCQYDEooFJLFxUVZWlrSPfcA9gCyIRBOQDRC21QqJZubmxKLxVSzRCIhyWRStra2JJPJKPOZGtoHIKJjmcs22JsEtieQHpefn5/1kEA8Pj7K6+urssD6PFEmeC5AALB4eHgog8FAAblIJPP5vLJgtrUNMgCjnijPcpncYibZYY0h1ra3cX9/L1dXV+7Eng4KEmC12+0KSX99fa3j9vZWGo3GZH54eND15eWlG3A6sU1T2PCA6BJtJEmn07KysqIu8/vd3d0EEFJgTPLQNDDAXq8n7XZb3YINs+2pfc6cgPbN1BBAXDaATqejgzOnAafLaIo0Pn4kcdfW1hRgNBppROv1ulxcXOgDNCXqRJY95wQDw5aHvCWdfACwQWjWtDMeoRHGiDBVsbCwoGXIXZgaW1jxjrsQ8bhM+4IdQOiIKxhYX19XBpxZClmkPz4+VFfy2RMUEhuweT8YAwjTs7Mzb7eBoZUW7YlqsGqhfik1ZnSkicD+8/NTc5a7M10mHWD68vKibEl6XOfh+/u7DrTGfbSHITO5qgz5bwCANbMBkkLMlOLe3p5GFAOck6+s0RBw0oos0LSJRqMSDodVWCIGdR4fHR3pTP+jsa6urmonJ40slZjRH2B1GXegzLBKQSOsYxWDRBRWdkbK4C4ELLGZ0ffPSiHPAOMxwJyhpRlyVgrEYOqJ8nRzoPGiH/oQbdyHCUactexqX781ByJnzRQZ+NdDJ/INtk6Gk24z7bJpaK6ZdtZorfECiIaeBkveYQkQwk/ukcQ3NzeTRsA8PShPPIGt6y+ADEejjY0NLSM+wNDnr4Ec3LMyNYb/ACBSX4dpGsZ3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseandbound\"\n        title=\"baseandbound\"\n        src=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png\"\n        srcset=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/e9ff0/baseandbound.png 180w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/f21e7/baseandbound.png 360w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 경우, 두개의 레지스터 값만 유지한다면 간단하게 VA와 PA간 변환이 가능하다. 해당 프로세스는 32KB에서 시작하고, address space의 크기는 16KB이므로, <code class=\"language-text\">base</code> 레지스터에 32KB, <code class=\"language-text\">bound</code> 레지스터에 16KB의 값을 갖고 있도록 하자. <u>각각 시작주소와 프로세스 주소 공간의 크기를 의미</u>한다.</p>\n<p>그렇다면 <code class=\"language-text\">MMU</code>(Memory Management Unit)에서  <code class=\"language-text\">PA = base + VA</code>로 변환해줄 수 있을 것이다. 만약 VA가 bound인 16KB보다 크거나 0보다 작다면 에러가 발생하도록 하면 된다.</p>\n<h3 id=\"role-of-hardware-in-translation\" style=\"position:relative;\"><a href=\"#role-of-hardware-in-translation\" aria-label=\"role of hardware in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of hardware in translation</h3>\n<p>주소 변환에서 하드웨어의 역할이 무엇인지 정리해보자.</p>\n<ul>\n<li>CPU는 <code class=\"language-text\">privileged mode</code> (<code class=\"language-text\">kernel mode</code>)를 제공해야 운영체제가 접근권한을 갖도록 할 수 있다.</li>\n<li>하드웨어는 base &#x26; bound 레지스터를 제공하며, CPU당 한쌍이 필요하다. 이를 통해 <strong>주소 변환과 범위 검사를 수행</strong>하며 <strong>오류 발생시에는 예외를 발생</strong>시킨다. 또한 <strong>레지스터 값을 변경하는 특권 명령어를 제공</strong>해야한다. 프로세스마다 각 레지스터 값들은 다르므로, 변경이 필요하며 이는 특권 모드에서 일어나야하기 때문이다.</li>\n</ul>\n<h3 id=\"role-of-os-in-translation\" style=\"position:relative;\"><a href=\"#role-of-os-in-translation\" aria-label=\"role of os in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of OS in translation</h3>\n<p>그렇다면 운영체제에서 <code class=\"language-text\">dynamic relocation</code>을 지원하기 위해 해줘야 할 일은 뭐가 있을지 알아보자.</p>\n<ul>\n<li>프로세스가 실행될 수 있는 유휴 메모리 공간인 <code class=\"language-text\">free list</code>를 관리한다. 위의 예시에서는 16<del>32KB, 48</del>64KB 영역이 free list에 있을 것이다.</li>\n<li>프로세스가 시작할 때 메모리 공간을 할당해주고, 종료할 때 이를 정리해준다.</li>\n<li>context switching 발생시, <code class=\"language-text\">PCB</code>에 실행중인 CPU의 <code class=\"language-text\">base</code>와 <code class=\"language-text\">bound</code> 레지스터 값을 저장해주거나 이전 레지스터 값을 복원해줘야 한다.</li>\n<li>하드웨어 예외 발생시, error handler를 통하여 조치를 취해야 한다. 보통 OS는 해당 프로세스를 종료함으로써 자원을 보호한다.</li>\n</ul>\n<h2 id=\"segmentation\" style=\"position:relative;\"><a href=\"#segmentation\" aria-label=\"segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segmentation</h2>\n<p>base and bound 방법은 비교적 간단하지만 내부 단편화(<code class=\"language-text\">internal fragment</code>)가 발생할 수 있다는 단점이 있다. 위의 그림들을 보면 프로세스에게 할당이 되었지만 사용중이지 않은 heap ~ stack 사이의 빈 영역이 존재하는데, base and bound 방법은 이러한 내부 단편화가 일어날 수 밖에 없는 구조이다. 고정 크기를 각각의 프로세스에 할당하므로 <strong>한 메모리에서 실제 사용하는 용량에 비해 실행시킬 수 있는 프로세스의 수는 적을 것</strong>이다.</p>\n<p>예를 들어, 32bit 주소 공간을 갖는 체계에서 하나의 프로세스는 무려 2^32byte = 4GB의 공간이 필요하게 된다… 하지만 실질적으로 프로세스에서 필요한 메모리의 크기는 MB단위일 것인데, 불필요한 부분들이 너무 많아 지게 된다.</p>\n<p>따라서 address space를 보통 <strong>heap, stack, code segment로 나누고, 이렇게 생긴 여러개의 (base, bound)를 MMU에 각각 두어 일반화</strong>한 방식인 <code class=\"language-text\">segmentation</code>이 제안된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVQ4y52U2W/aQBCH/Z9XfWikSonI2b72oXlppVZV1CoVRwI0AQJJzH0Ggy/A2AYCGDDHr5oFEwdVSuhIox0f++3M7MxwuiZAEhKQa/eQa3dMpdodVIlHNsNDFCXY9gTtdhuGYTAlW9d19Pv99TPZnU4HXD75C9HAe8SD+7i59DCNBz2IBvbQUEog6Xa7yOVyyOfzKJfLqFQqKBQKGI1G0DQN6XQalmWxQ7hyzoew14PrwAmuA8eIXJzgyn+M6MUxTENaAwkiiiKD0OrYqqqiVqthMpmg1WqBK2V9CP7eQ9h75NJDRAJHMHVxCex0GFCWZQwGAwYgHY/HDFiv15+AhfQ5Yhe7SIQOEQ8eME2EDhC73EdTrWCxWHpYLBYZhEKjVRCENZBs27ZZ+JwqlyEKt5DrPBQxyVSiC6rzeKgUWd5M02SrJElrYLVaZV65gc1mE5xtT1lY8xkwHtsYj2w4MpksbQqTAI1GA4+Pjyx/BKGbJSAdRN7SwVyjrUM2TIiajlxVQFlSIOsmpLaOXn+wPGw+Z+twOEQqlUKpVGJAnueRzWZZ7qbTKWazGbirwgM+R5L4Gs/gkzeM03AcXxJZnEZ4NMwuAy0okSshuPPsth3hur0e+pYFtaVBlBWmbbODgWWhpWksL46H7s2btqPct5sUdn6G8NEfxaE3gt3zP/jgj7J3iVwRiiSyUDY3bqrznfueyODNWQgeXww7P/x4d3aJXV8Mb8+CEDRjGZpr00vCVZQmbmsK7usKQnwGkWwR93UVd4IEo9t7Ft5roNzYsp4SPp0Czqb5HFPbfhbqqzwcroDu3xerMGmK0KVs5aG1AlIdUeWTOrdKBUzT5V+3/CKQirbX67G+pTYiCB2ydciWK4duoVKhb+7i3crDzZ//20NqcIJSc9NKQ5NsyiX1ayaT2S6H9BPNumQyycY6NTuNdBrnlEvK6TYh/wVtti9w5MDjCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"segmentation\"\n        title=\"segmentation\"\n        src=\"/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png\"\n        srcset=\"/static/99d8bbe29d2c10911c0c29ed5429333e/e9ff0/segmentation.png 180w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/f21e7/segmentation.png 360w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png 720w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/302a4/segmentation.png 1080w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/525d3/segmentation.png 1090w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리 공간을 코드, 힙, 스택의 3개의 segment로 분할하고, 각각 base, bound, 순방향 증가 여부(<u>스택의 경우, 역방향으로 증가하므로</u>)를 기록하여 segmentation을 간단하게 구현할 수 있다. 순방향 증가 여부의 경우, translation 과정에서 stack영역은 반대 방향이므로 다르게 계산해줄 필요가 있으므로 알 필요가 있다.</p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>하지만 이 방법은 내부 단편화는 줄일 수 있어도, 각 segment 사이의 작은 빈 공간이 많이 존재하게 되는 외부 단편화 (<code class=\"language-text\">external fragment</code>)가 발생할 수 있다는 단점이 존재한다. 이를 해결하기 위해 물리 메모리를 한 곳으로 몰아서 압축하는 방법이 제안되기도 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFklEQVQ4y22UV4uyMRCF/f+/QfBKEKzghcJe2MCCdS14Ifburr3XWZ5ZRvaDLxCSTE7OnDnJ+zqez6dcLhdhtDaZTGQwGMjxeHzH2L9er//g5vO59Ho92W6375gDEATr9VpqtZp8fn5KOp2WXC4nxWJRyuWytNtteTweb1yj0ZBKpSKZTEZxpVJJz9Xr9V9CQKvVSmKxmESjUfH5fOJ0OiUUCkkkElFilIEBm0wmFRcIBMTlconX65WPjw9JJBK/hAaMx+MK8vv94na7lRhS1EC4XC61vFQqJcFgUPfBeTweCYfDGnfgH15Mp1OVns/ntRcKBVWWzWal2WxqyYvFQnFYgxUkolQ6a0bH7XaTzWajKhnpo9FIfcIzFLEHoeFer5f8ryHOcTqdZDabydfXlxwOB71ZlEAKGbHdbqc3TCXsQU7jLAkQRePs20P8YQ6YBNwsAMA2gvv+/n4TWjWcswTqIWQAUYmKbrcr1WpV+v2+xuj3+/2N+/sW/zYlJLuVzCHArDudjgJQw3g+nzVOyVhAxxI68/1+r8lUIdJ5NraBEhLYQfbt8uzNMrKG0OIkc2A6PrCwDdY8FZ6IxVA4Ho9Vpb0G7BkOh3oWYiVEoV0KqghyCFIIWVOKXQo4U0eCVqulI5Uood0yHQ9pEPNzsJ8BHkII0V9CVGGRla2EBPhjsIDAvm1IIaICymUOzmwwESSwOZfyA811WsxGLfJSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compact\"\n        title=\"compact\"\n        src=\"/static/3491ec2ae9efa9381131014955213c91/37523/compact.png\"\n        srcset=\"/static/3491ec2ae9efa9381131014955213c91/e9ff0/compact.png 180w,\n/static/3491ec2ae9efa9381131014955213c91/f21e7/compact.png 360w,\n/static/3491ec2ae9efa9381131014955213c91/37523/compact.png 720w,\n/static/3491ec2ae9efa9381131014955213c91/84ee5/compact.png 1076w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 파편화된 외부 미사용 공간들을 압축하는 방법은 overhead가 큰 연산이므로 비용이 많이 든다. 이에 운영체제는 (미사용) 공간을 관리하는 알고리즘을 이용할 수 있는데, <code class=\"language-text\">best-fit</code>, <code class=\"language-text\">worst-fit</code>, <code class=\"language-text\">first-fit</code>, <code class=\"language-text\">buddy algorithm</code>등이 존재하며 압축을 최소화하면서 상황에 맞게 최선의 방법을 선택할 수 있을 것이다.</p>\n<p>또한 segmentation은 유연하지 못하다는 단점이 있다. 힙, 스택, 코드의 3 영역으로 나눈다고 해도 각각은 모두 연속적으로 존재해야하므로 유연성이 떨어진다. 이에 <code class=\"language-text\">Fine-grained</code> 와 <code class=\"language-text\">Coarse-grained</code> segmentation이 제안되는데, 조각이 많아진다면 유연성은 증가하지만 레지스터값들이 그만큼 늘어나므로 관리가 어려워질 수 있다.</p>\n<p>다음에는 이에 해결책이 될 수 있는 <code class=\"language-text\">Paging</code> 기법에 대하여 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"October 29, 2023","title":"(OS) 운영체제 복습 [8. Mechanism of Address Translation]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(9-1)-Paging/","nextSlug":"/OS(8)-Mechanism of Address Translation/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}