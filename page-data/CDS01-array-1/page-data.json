{"componentChunkName":"component---src-templates-blog-template-js","path":"/CDS01-array-1/","result":{"data":{"cur":{"id":"74408fa6-45a8-50c5-90bc-2d58f542b7aa","html":"<p>자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다.</p>\n<h1 id=\"수학적-귀납법\" style=\"position:relative;\"><a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B7%80%EB%82%A9%EB%B2%95\" aria-label=\"수학적 귀납법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수학적 귀납법</h1>\n<p>컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다.</p>\n<blockquote>\n<p>BASE : P(1)이 참이다.</p>\n<p>STEP : P(n-1) -> P(n)이 참이다.</p>\n<p>따라서, 모든 자연수 n에 대하여 P(n)은 참이다.</p>\n</blockquote>\n<p>BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 <strong>P(n-1)이 참이라고 믿는 것</strong>인데, 이유는 무엇일까.</p>\n<h2 id=\"p-q의-의미\" style=\"position:relative;\"><a href=\"#p-q%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"p q의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>P->Q의 의미</h2>\n<p>예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자.</p>\n<ul>\n<li>100점을 맞고, 치킨을 사주었다. => 참</li>\n<li>100점을 맞고, 치킨을 안사주었다. => 거짓</li>\n<li>100점을 안맞았고, 치킨을 안사주었다. => 참</li>\n<li>100점을 안맞았는데, 치킨을 사주었다. => <strong>참</strong></li>\n</ul>\n<p>마지막 경우가 참인 이유는 100점을 안맞았을때의 약속에는 아무 내용도 없기 때문에 판단할 수 없고, 약속을 어긴 것은 아니기 때문이다. 이를 <code class=\"language-text\">vacuously true</code>라고 부르는 사람도 있고, 어쨌든 약속은 100점을 안맞았을때는 신경쓸 필요가 없이 참이고, <strong>100점을 맞았을 때 치킨을 사주는지 여부에 따라서 약속의 참거짓이 결정</strong>된다.</p>\n<p>이를 위의 step에 대입시켜보자. P(n-1) -> P(n)이 참인 것을 보이려면, P(n-1)이 거짓인 경우에는 항상 참이므로(vacuously true), 굳이 무언가를 증명할 필요가 없다. 따라서, P(n-1)이 참인 것을 가정하고, P(n)이 참임을 보이면 되는 것이다. 주로, 귀납법에서는 해당 함수, 수식이 항상 성립함을 증명하므로 이와 같이 생각하면 편할 것이다.</p>\n<h1 id=\"배열array\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4array\" aria-label=\"배열array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Array)</h1>\n<p>이제 본격적으로 자료구조에 대하여 공부해보자. 가장 기본적인 자료구조는 배열이다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>배열은 연속된 주소에 동일한 type의 자료형들이 모여있는 것들을 말한다. C에서의 배열은 연속된 주소에 같은 타입의 데이터가 저장되어 있고, python과 같은 언어에서는 array가 아닌 list를 사용하는데, 이는 연속된 주소에 데이터를 가리키는 reference가 저장되어 있다. 따라서, list에는 여러가지 자료형을 넣을 수 있는 것이다.</p>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<p>배열의 가장 큰 장점은 배열의 연속된 공간에서 오는 특징에서 기인하는데, 바로 Access Time 이다. 보통 선형 자료구조에서는 처음부터 끝까지 가리키기 위해 index가 존재하는데, 배열에서는 연속된 공간에 같은 type이 모여있으므로, <strong>특정 인덱스에 대하여 상수시간에 접근이 가능하다</strong>.</p>\n<p>예를 들어, 배열에서 k번째의 data에 접근하려고 한다고 해보자. 이는 <code class=\"language-text\">배열의 시작주소 + (k-1)*(type size)</code>로 접근이 가능하며, 이는 배열의 크기가 크거나 k의 크기가 커도 항상 같은 시간(<code class=\"language-text\">O(1)</code>)에 접근할 수 있게 된다. LinkedList 등은 시작부터 k-1번 인덱스까지 차례대로 접근해야하므로, 이는 상수시간이 아니다.</p>\n<p>또한, 정렬된 배열(sorted array)의 경우 <code class=\"language-text\">search</code>가 빠르다. 이는 <code class=\"language-text\">Binary Search</code>(이분탐색)을 통해 <code class=\"language-text\">O(log n)</code>시간에 탐색이 가능하다. 참고로, 접근과 탐색은 특정 값을 찾는지 특정 위치의 값을 찾는지 이므로 완전히 다른 것이다.!</p>\n<p>정렬되지 않은 배열의 경우에는 탐색에는 일일이 탐색하는 <code class=\"language-text\">Linear Search</code>(선형탐색)을 통해 <code class=\"language-text\">O(n)</code> 시간이 걸리므로 느리다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<p>배열의 단점으로는 크기 변화에 대한 비용이 크다는 것이 있다. 배열은 선언시 정해진 크기만큼 메모리 공간을 차지하므로, 해당 크기를 넘어가게 되면 새로운 빈 공간을 찾아서 할당하고 이전의 값들을 복사하여 옮기는 작업이 필요하다! 우리가 사용하는 동적배열도 내부적으로는 정적배열로 구현되어있고, 크기 변화시 이러한 오버헤드가 발생함을 알 수 있다. 배열의 크기가 줄이는 경우에도 마찬가지.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>배열은 크기의 변화가 적고, 같은 자료형인 data들로 구성하는 것이 적합하다. 만약, 정렬이 되어있거나 정렬에 대하여 오래걸리지 않는다면 배열은 탐색 또한 빠른 자료구조이다!</p>\n<h1 id=\"재귀-recursion\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-recursion\" aria-label=\"재귀 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 (Recursion)</h1>\n<p>재귀는 보통 함수에서 많이 사용되는 개념으로, 함수 안에 해당 함수를 호출하는 것을 재귀함수라고 한다. loop를 사용하는 것을 재귀를 사용하면 더 직관적이고 코드가 짧아지는 경우가 많으므로 잘 알아두자.</p>\n<h2 id=\"재귀함수의-구성\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"재귀함수의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 구성</h2>\n<p>재귀는 위에서 공부한 <code class=\"language-text\">수학적 귀납법</code>과 매우 유사한 구조를 갖는다. 재귀 자체가 귀납적으로 구성되어 있기 때문이다. 재귀함수는 보통 base case와 recursion case로 나뉜다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>재귀함수를 탈출(return)하는 조건. 귀납법에서의 base 에 해당</p>\n</li>\n<li>\n<p>recursion case</p>\n<p>재귀적으로 실행되는 조건. 귀납법에서의 step에 해당</p>\n</li>\n</ol>\n<h2 id=\"재귀함수의-해석\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%B4%EC%84%9D\" aria-label=\"재귀함수의 해석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 해석</h2>\n<p>재귀적으로 생각하기 위해, 재귀함수를 n부터 1까지 따라 내려가는 것은 오히려 이해에 방해가 될 수 있다. 귀납법과 같이, 해당 함수가 정답이 return된다고 생각하고 재귀함수를 구성하면 된다!</p>\n<p>이에 대한 예시로, 정렬 중 하나인 merge sort를 구현해보도록 하자.</p>\n<h2 id=\"merge-sort\" style=\"position:relative;\"><a href=\"#merge-sort\" aria-label=\"merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort</h2>\n<p><code class=\"language-text\">merge sort</code>는 <code class=\"language-text\">merge algorithm</code>을 이용한 정렬이다. 머지 알고리즘은, 두 정렬된 배열을 합쳐 하나의 정렬된 배열을 만드는 알고리즘이다. 두 정렬된 배열 first, second가 있을 때, 각 배열의 <u>제일 앞 요소만을 비교하여 더 작은 것을 새로운 배열에 차례대로 빼서 넣어주</u>면 된다. c++로 코드를 다음과 같이 짜보았다. (인자는 순서대로 정렬된 결과 배열, 정렬된 첫번째 배열, 정렬된 두번째 배열, 결과 배열의 크기, 첫번째 배열의 크기, 두번째 배열의 크기를 의미한다)</p>\n<h3 id=\"merge-algorithm\" style=\"position:relative;\"><a href=\"#merge-algorithm\" aria-label=\"merge algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge algorithm</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> first_size<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> second_size<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 정렬된 두 배열을 합쳐 하나의 정렬된 배열로 만든다.</span>\n    <span class=\"token keyword\">int</span> firstcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> secondcnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>first <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n            first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            firstcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n            second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            secondcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstcnt <span class=\"token operator\">>=</span> first_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//1. first 배열에 남은 값이 없는 경우 -> 새로운 배열에 second를 순서대로 넣는다.</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n                second<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>secondcnt <span class=\"token operator\">>=</span> second_size<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n          \t<span class=\"token comment\">//2. second 배열에 남은 값이 없는 경우</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ret<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>first<span class=\"token punctuation\">;</span>\n                first<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++에서는 배열의 이름이 배열의 주소를 의미하고, 이를 하나씩 증가시킬때마다 배열의 인덱스 한칸만큼 증가하는 것을 이용하였다. 살짝 골치아픈 것은 두 배열의 크기가 다를 수도 있고, 두 배열의 크기가 같더라도 한 배열이 값이 더 작은 것들이 많아 먼저 소진된다면, 결과 배열에 나머지 값들을 차례대로 넣어줘야하는데, 다른 방법이 생각나지 않아 단순하게 차례대로 넣어주도록 처리하였다.</p>\n<p>이제, merge sort를 재귀적으로 구현해보자! 핵심은 재귀적으로 생각하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// base case</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> new_arr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 결과를 저장할 새로운 배열</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        new_arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 절반씩 나누어서 merge_sort &amp; 합치기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// n이 홀수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token comment\">// n이 짝수인 경우 step</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> new_arr<span class=\"token punctuation\">,</span> new_arr <span class=\"token operator\">+</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"merge-sort-algorithm\" style=\"position:relative;\"><a href=\"#merge-sort-algorithm\" aria-label=\"merge sort algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>merge sort algorithm</h3>\n<p>합병 정렬의 인자로는 정렬되지 않은 배열이 주어질 것이고, 이 함수를 통하여 배열을 정렬하는 것을 기대한다.</p>\n<ol>\n<li>\n<p>base case</p>\n<p>배열의 크기가 1보다 작다면, <strong>(정렬이 완료된 것이므로)</strong> 종료한다.</p>\n</li>\n<li>\n<p>step</p>\n<ol>\n<li>배열의 크기가 1보다 크다면, 배열을 앞부분 배열과 뒷부분 배열로 나누어서 각각 <code class=\"language-text\">merge sort</code> 해준다.</li>\n<li>정렬된 두 배열을 merge 알고리즘을 통하여 하나의 정렬된 배열로 합쳐준다.</li>\n</ol>\n</li>\n</ol>\n<p>잘 와닿지 않지만, 2-1은 수학적 귀납법에서 P(n-1)이 참이라고 가정하는 부분과 유사하다! 나누어서 각각 merge sort 해주는데, 여기서 그 안을 생각하지 말자!! <strong>merge sort의 결과로 정렬된 배열이 나온다고 가정하는 것이 핵심</strong>이다. base case가 잘 되어있다면, 이 함수는 정렬을 완벽하게 수행하여 리턴될 것이다!</p>","excerpt":"자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다. 수학적 귀납법 컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다. BASE : P(1)이 참이다. STEP : P(n-1) -> P(n)이 참이다. 따라서, 모든 자연수 n에 대하여 P(n)은 참이다. BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 P(n-1)이 참이라고 믿는 것인데, 이유는 무엇일까. P->Q의 의미 예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자. 100점을 맞고, 치킨을 사주었다. => 참 100점을 맞고, 치킨을 안사주었다. => 거짓 100점을 안맞았고, 치…","frontmatter":{"date":"July 01, 2022","title":"(DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/CDS01-array-1/"}},"next":{"id":"e1e5d260-58e0-58af-a974-6c589aef1c8d","html":"<p>Dijkstra(다익스트라) Algorithm은 그래프에서, <strong>한 노드에서 출발하여 다른 노드로 가는 최단 거리</strong>를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다.</p>\n<h2 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h2>\n<p>input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight)</p>\n<p>output : 1번노드에서 n번노드까지의 최단 거리</p>\n<p>​\t(입력 예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n</code></pre></div>\n<h1 id=\"그래프를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"그래프를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프를 표현하는 방법</h1>\n<p>weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데,</p>\n<ol>\n<li>\n<p>노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다.</p>\n<p>4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, <code class=\"language-text\">matrix[4][3]=5</code>와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다.</p>\n</li>\n<li>\n<p>한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)로 저장해도 헷갈리지만 않으면 좋다!</p>\n<p>위와 같은 상황일때, <code class=\"language-text\">node_4의 인접노드 : (5, 3번)</code>와 같이 표현할 수 있다.</p>\n</li>\n</ol>\n<p>2의 방법이 공간적으로 효율적이고 여러 엣지가 존재할 경우도 활용이 가능하다. <code class=\"language-text\">c++</code>에서는 pair와 vector배열을 이용하여 입력에 대하여 인접노드를 추가하는 형태로 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\nvector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span> E<span class=\"token punctuation\">[</span><span class=\"token number\">100005</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span> <span class=\"token comment\">// number of nodes, number of edges</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> from <span class=\"token operator\">>></span> to <span class=\"token operator\">>></span> weight<span class=\"token punctuation\">;</span>\n        E<span class=\"token punctuation\">[</span>from<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        E<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>전역변수 E에 모든 엣지의 정보가 저장되어 있으므로, 이를 탐색하며 최단거리를 구할 수 있다.</p>\n<h1 id=\"dijkstra-의사-코드\" style=\"position:relative;\"><a href=\"#dijkstra-%EC%9D%98%EC%82%AC-%EC%BD%94%EB%93%9C\" aria-label=\"dijkstra 의사 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dijkstra 의사 코드</h1>\n<p>위와 같이 그래프를 만들고 나서는 다익스트라 알고리즘을 이용하여 그래프를 탐색하며 최단거리를 구할 수 있다.</p>\n<p>(1번노드에서 출발하여 n번노드까지의 최단거리를 구하는 다익스트라 알고리즘이라고 가정해보자) 우선 출발지부터 i번 노드까지의 최단거리를 기록하는 <code class=\"language-text\">D[i]</code>가 필요하다. D 배열의 각 원소는 처음에 매우 큰 값으로 세팅하도록 하고, 이후 탐색하면서 더 작은 비용의 거리가 발견된다면 업데이트 되도록 하므로, 큰 값으로 초기화를 해준다.</p>\n<ul>\n<li>\n<p>1번노드~1번노드의 거리는 0이므로, 이를 priority queue(이하 pq, 방문할 노드를 엣지의 거리 순으로 저장함)에 저장한다. D[시작노드] = 0 임을 확정짓는다.</p>\n<ul>\n<li>pq가 비어있을때 까지</li>\n</ul>\n<ol>\n<li>\n<p>pq에서 가장 거리가 짧은 엣지를 찾는다. 노드 번호 : <code class=\"language-text\">curNode</code>, 엣지 길이 : <code class=\"language-text\">curDist</code></p>\n</li>\n<li>\n<p>pq에서 해당 엣지(ex. x번 노드까지의 거리)을 제거한다. (방문 처리)</p>\n</li>\n<li>\n<p>만약 <code class=\"language-text\">D[curNode]</code>가 <code class=\"language-text\">curDist</code>보다 작지 않은경우, (D[ ] 업데이트 필요)</p>\n<ol>\n<li>\n<p>curNode의 인접한 노드들을 조사하는데…</p>\n</li>\n<li>\n<p><code class=\"language-text\">D[x]</code>와 <code class=\"language-text\">D[curNode]+curNode~x의 거리</code>를 비교하여 더 작은 값으로 X 노드까지의 최단거리를 업데이트한다.</p>\n</li>\n<li>\n<p>업데이트 되는 경우에는 해당 엣지 정보를 pq에 추가한다.</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>주의해야할 점은 크게 두가지가 있다.</p>\n<ul>\n<li>인접한 엣지 중에서 가장 weight가 짧은 것을 추출하는 과정에서, 일반 배열로 저장하는 것(<code class=\"language-text\">O(N)</code>)보다는 PQ로 저장하는 것(<code class=\"language-text\">O(log(N))</code>)이 효율적이다.</li>\n<li>A에서 C까지의 최단경로를 볼 때, 임의의 노드 B에서 A<del>B + B</del>C까지의 거리와 A~C의 거리를 비교하고, 더 짧은 것으로 거리를 확정짓는 것이 다익스트라의 핵심이다.</li>\n</ul>\n<p>코드는 아래와 같다. 만약 endNode가 추가적으로 필요하다면, 인자에 추가하고 endNode탐색시 종료하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> startNode<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    priority_queue<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">></span> pq<span class=\"token punctuation\">;</span> <span class=\"token comment\">// (weight, nodeNo)</span>\n    <span class=\"token comment\">// startNode PQ에 추가</span>\n\n    pq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> startNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    d<span class=\"token punctuation\">[</span>startNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pq<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curNode <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> curDist <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// printf(\"curNode : %d, curDist : %lld\\n\", curNode, curDist);</span>\n        <span class=\"token comment\">//해당 노드 방문 처리</span>\n        pq<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> curDist<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//최단 거리 노드의 인접노드</span>\n                <span class=\"token keyword\">int</span> nextNode <span class=\"token operator\">=</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> nextDist <span class=\"token operator\">=</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// printf(\"nextDist : %lld, nextNode: %d\\n\", nextDist, nextNode);</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nextDist <span class=\"token operator\">&lt;</span> d<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// printf(\"update needed\\n\");</span>\n                    <span class=\"token comment\">// update 필요</span>\n                    d<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nextDist<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// pq push</span>\n                    pq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>nextDist<span class=\"token punctuation\">,</span> nextNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"다익스트라에서-경로를-표현하는-방법\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%EC%97%90%EC%84%9C-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"다익스트라에서 경로를 표현하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다익스트라에서 경로를 표현하는 방법</h2>\n<p>위의 코드는 단지 x번 노드부터 n번 노드까지의 최단거리를 의미한다. 따라서, 어떠한 경로를 통하여 갔는지는 추가적인 작업이 필요하다. 이는 최단거리가 업데이트되어 확정되는 순간에 <strong>해당 노드를 방문하기 직전의 노드를 기록하면 된다</strong>! nextNode와 curNode를 통하여 최단거리를 비교하는 과정에서, 업데이트가 일어나면(최단거리 확정이 일어나면) 배열에다가 curNode를 저장하면 될 것이다.</p>\n<p>그렇게 하면 1 -> 4 -> 3 -> 5의 경로로 최단경로가 확정될 때, [0, 1, 0, 5, 0, 3]와 같이 저장될 것이다. 이를 스택에다가 넣어서 출력하면 깔끔하게 나올 것이다. 최종 코드는 다음과 같다. <code class=\"language-text\">codeforces 20C</code>문제에 대한 코드이다.! 결국 다익스트라가 이러한 틀로 구성되니까 참고하면 좋을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\nvector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span> E<span class=\"token punctuation\">[</span><span class=\"token number\">100005</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> d<span class=\"token punctuation\">[</span><span class=\"token number\">100005</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> prevNode<span class=\"token punctuation\">[</span><span class=\"token number\">100005</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 최단경로에서 i번째 노드의 이전 노드를 저장</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> startNode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> endNode<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    priority_queue<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">></span> pq<span class=\"token punctuation\">;</span> <span class=\"token comment\">// (weight, nodeNo)</span>\n    <span class=\"token comment\">// startNode PQ에 추가</span>\n\n    pq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> startNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    d<span class=\"token punctuation\">[</span>startNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    prevNode<span class=\"token punctuation\">[</span>startNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> startNode<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pq<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curNode <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> curDist <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// printf(\"curNode : %d, curDist : %lld\\n\", curNode, curDist);</span>\n        <span class=\"token comment\">//해당 노드 방문 처리</span>\n        pq<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> curDist<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//최단 거리 노드의 인접노드</span>\n                <span class=\"token keyword\">int</span> nextNode <span class=\"token operator\">=</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> nextDist <span class=\"token operator\">=</span> E<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// printf(\"nextDist : %lld, nextNode: %d\\n\", nextDist, nextNode);</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nextDist <span class=\"token operator\">&lt;</span> d<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// printf(\"update needed\\n\");</span>\n                    <span class=\"token comment\">// update 필요</span>\n                    d<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>curNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nextDist<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// for path</span>\n                    prevNode<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curNode<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// pq push</span>\n                    pq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>nextDist<span class=\"token punctuation\">,</span> nextNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios_base<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">// n : number of nodes, m : number of edges</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> from <span class=\"token operator\">>></span> to <span class=\"token operator\">>></span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1-based-node</span>\n        E<span class=\"token punctuation\">[</span>from<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>weight<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        E<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>weight<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// printf(\"from : %d, to : %d, weight : %lld\\n\", from, to, weight);</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> LLONG_MAX<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> LLONG_MAX<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// update되지 않았다 -> 경로 없다</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n    stack<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// printf(\"%d \", c);</span>\n        path<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        c <span class=\"token operator\">=</span> prevNode<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        path<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"May 28, 2022","title":"(Alg) 그래프 알고리즘 - Dijkstra와 최단 경로 출력","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/Alg-Dijkstra/"}},"prev":{"id":"5b0b9dd5-ebb1-5e97-afe5-96b81e72e2d6","html":"<p>배열은 저번에 공부했듯이 고정된 크기의 연속된 주소에 저장된 자료구조이다. 배열도 저장하는 방법(위치, 정렬)에 따라 크게 4가지로 나눌 수 있다.</p>\n<h1 id=\"배열의-종류\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"배열의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열의 종류</h1>\n<ul>\n<li>\n<p>데이터가 몰려있냐에 따라</p>\n<ul>\n<li>\n<p>packed</p>\n<p>배열안의 데이터(의미있는)가 한쪽에 몰려있는 경우이다.</p>\n</li>\n<li>\n<p>unpacked</p>\n<p>배열안의 데이터가 산발적으로 존재하는 경우이다. 빈 공간에는 의미없는 값이나, 특정 값(예를 들어 의미없음을 뜻하는 -1 등)이 들어가 있을 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>데이터가 정렬되어있냐에 따라</p>\n<ul>\n<li>\n<p>sorted</p>\n<p>배열안의 데이터가 정렬되어(숫자면 값이 크거나 작은 순서대로) 있다.</p>\n</li>\n<li>\n<p>unsorted</p>\n<p>배열안의 데이터가 정렬되어 있지 않다. (데이터의 크고 작음이 순서에 영향을 미치지 않는다)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>두 기준으로 보았을 때 4가지 조합이 존재하는데, 배열에서 가장 중요한 연산인 <code class=\"language-text\">Search</code>, <code class=\"language-text\">Insert</code>, <code class=\"language-text\">Delete</code>를 직접 구현해보면서 각 배열의 특징에 대하여 알아보도록 하자! (단, insert 또는 delete 시 배열 전체의 크기 변화는 없다고 가정) <u>search는 해당 값을 찾는 연산, insert는 해당 값이 없다면 추가하는 연산, delete는 해당 값이 있다면 삭제하는 연산으로, insert와 delete는 항상 search가 선행되어야 할 것</u>이다.</p>\n<h1 id=\"1-packed--unsorted\" style=\"position:relative;\"><a href=\"#1-packed--unsorted\" aria-label=\"1 packed  unsorted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. packed &#x26; unsorted</h1>\n<p>가장 기본적인 형태의 배열이다. 배열의 데이터의 크기가 S라고 했을 때, 데이터는 아래와 같이 저장될 것이다. 1행은 인덱스를 의미하고, 2행은 데이터를 의미하며 S는 4이다.</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>3</td>\n<td>7</td>\n<td>6</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>Search</p>\n<p>정렬되어 있지 않으므로 차례대로 찾아야할 것이다. <code class=\"language-text\">O(n)</code>이 걸릴 것이다.</p>\n</li>\n<li>\n<p>Insert</p>\n<p>Search하고, insert를 하는데 단순히 끝에 데이터를 넣고 S를 1 증가시키면 될 것이다. 순수 insert 자체는 <code class=\"language-text\">O(1)</code>이 걸리지만, 총 <code class=\"language-text\">O(n)</code>이 걸린다.</p>\n</li>\n<li>\n<p>Delete</p>\n<p>만약 값을 찾고 그 값을 x로 지운 후, 뒤의 값들을 하나씩 미루는 방법을 사용한다면 그 자체로 <code class=\"language-text\">O(n)</code>이 걸릴 것이다. 하지만 unsorted array는 데이터에 위치에 대하여 특정한 제약이 없으므로, 단순히 맨 끝의 데이터와 지울 데이터의 위치를 바꾸고 S를 1 감소시켜주면 된다.</p>\n<p>예를 들어, 5를 delete하려고 하면, 0번 인덱스의 5와 마지막 인덱스의 6을 바꿔주고(혹은 6을 0번에만 대입해줘도 됨) s를 줄여주면 된다. delete(5)의 결과는 아래와 같다.</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6</td>\n<td>3</td>\n<td>7</td>\n<td>6</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<p>코드는 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> S<span class=\"token punctuation\">;</span> <span class=\"token comment\">// size of array</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// A에 x가 있는지 찾는다 없다면 -1 리턴</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// A에 x를 끝에 넣어준다</span>\n    A<span class=\"token punctuation\">[</span>S<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    S<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dlte</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> loc<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 해당 위치의 데이터를 마지막 원소와 스왑하고 지운다</span>\n    <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>loc<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    A<span class=\"token punctuation\">[</span>loc<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>S <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    A<span class=\"token punctuation\">[</span>S <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n    S<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> quit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>quit<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> c<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'s'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d not founded\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d founded in %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'i'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'d'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">dlte</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'q'</span><span class=\"token operator\">:</span>\n            quit <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"S : %d\\n\"</span><span class=\"token punctuation\">,</span> S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%3d   \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%3d   \"</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"2-packed--sorted\" style=\"position:relative;\"><a href=\"#2-packed--sorted\" aria-label=\"2 packed  sorted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. packed &#x26; sorted</h1>\n<p>아래와 같은 형식으로 저장될 것이다. S(배열의 크기)는 4이다.</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>Search</p>\n<p>Binary Search를 이용하면 <code class=\"language-text\">O(log n)</code>에 찾을 것이다. 빠르다!</p>\n</li>\n<li>\n<p>Insert</p>\n<p>데이터에 따라 삽입되는 위치가 정해질 것이다. 이는 이전과 다르게 중간에 삽입한다면 뒤의 데이터들을 하나씩 미뤄야 하므로 <code class=\"language-text\">O(n)</code>의 시간이 걸릴 것이다. insert의 경우에는 값이 없을때, 삽입하는 것이므로 어디에 삽입할지를 search단계에서 파악하는 것이 필요하다. 따라서, 전역변수를 두고 search가 실패했을 경우, insert해야하는 위치를 저장하도록 하면 될 것이다.</p>\n</li>\n<li>\n<p>Delete</p>\n<p>역시 삭제한 위치가 생기면 뒤의 데이터들을 하나씩 당겨야 하므로 <code class=\"language-text\">O(n)</code>의 시간이 걸릴 것이다.</p>\n</li>\n</ul>\n<p>코드는 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> S<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// size of array</span>\n<span class=\"token keyword\">int</span> loc<span class=\"token punctuation\">;</span> <span class=\"token comment\">// insert할 위치</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Recursive Binary search</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">></span> right<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// loc 위치에서 insert할 예정</span>\n        loc <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// left...mid ... x ...right</span>\n        <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// left ... x ... mid ... right</span>\n        <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// loc 뒤의 원소들을 한칸씩 미룬다.</span>\n    S<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> S<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> loc<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// A에 x를 loc에 넣어준다</span>\n    A<span class=\"token punctuation\">[</span>loc<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dlte</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> loc<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 해당 위치의 원소 뒤로 한칸씩 당긴다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> loc <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        A<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    S<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> quit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>quit<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> c<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'s'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> S <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d not founded\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d founded in %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'i'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> S <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'d'</span><span class=\"token operator\">:</span>\n            cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> S <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">dlte</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token char\">'q'</span><span class=\"token operator\">:</span>\n            quit <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"S : %d\\n\"</span><span class=\"token punctuation\">,</span> S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%3d   \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> S<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%3d   \"</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"3-unpacked--unsorted\" style=\"position:relative;\"><a href=\"#3-unpacked--unsorted\" aria-label=\"3 unpacked  unsorted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. unpacked &#x26; unsorted</h1>\n<p>unpacked에서는 효율적인 연산을 위하여 해당 위치에 데이터가 있는지 추가로 저장할 필요가 있다. 또한 추가적으로, insert와 delete에서 시간을 절약하기 위해 <code class=\"language-text\">free list</code>와 비슷한 개념을 사용하게 된다. 앞으로 데이터는 아래와 같은 형식으로 저장되거나 업데이트 될 것이다.</p>\n<ol>\n<li>\n<p>해당 위치에 데이터가 있는 경우 : 데이터에는 의미있는 값이 저장된다</p>\n</li>\n<li>\n<p>해당 위치에 데이터가 없는 경우 : 데이터에 다음 비어있는 공간의 인덱스가 저장된다!</p>\n<p>이렇게 저장해줌으로써, 빈 공간을 <code class=\"language-text\">Linked List</code>처럼 관리할 수 있게 된다. 최초의 빈 공간은 따로 변수로 관리한다.(head의 역할)</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>Search</p>\n<p>정렬되어있지 않으므로 선형탐색을 해야한다. <code class=\"language-text\">O(n)</code>의 시간이 걸릴 것이고, 비교하면 packed보다는 (빈 공간 역시 탐색하므로) 더 오래 걸릴 것이다.</p>\n</li>\n<li>\n<p>Insert</p>\n<p>해당 데이터가 없다면 빈 공간(데이터가 없는 공간)에 삽입할 것이다. 빈 공간을 탐색하는 것은 <code class=\"language-text\">O(n)</code>만큼 걸리겠지만, 위의 free list 개념을 이용하면, 상수시간에 해결 가능하다.</p>\n</li>\n<li>\n<p>Delete</p>\n<p>해당 데이터가 있다면 해당 위치에 데이터가 없다고 표시해준다. 또한, 해당 위치의 데이터는 다음 비어 있는 공간의 인덱스로 저장하도록 한다. 역시 상수시간에 가능하다.</p>\n</li>\n</ul>\n<p>코드는 아래와 같다.</p>","frontmatter":{"date":"July 08, 2022","title":"(DS) 자료구조 정리 02- 다양한 종류의 배열 (packed~unpacked, sorted~unsorted)","categories":"Alg","author":"choieastsea","emoji":"😬"},"fields":{"slug":"/CDS01-array-2/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/CDS01-array-1/","nextSlug":"/Alg-Dijkstra/","prevSlug":"/CDS01-array-2/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}