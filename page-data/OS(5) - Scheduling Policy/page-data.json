{"componentChunkName":"component---src-templates-blog-template-js","path":"/OS(5) - Scheduling Policy/","result":{"data":{"cur":{"id":"673fdb45-03b2-5faa-82e9-8bda9f41a585","html":"<p>저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지(<code class=\"language-text\">scheduling mechanism</code>)에 대하여 공부해보았다.</p>\n<p>오늘은 scheduling을 할 때 순서를 결정짓는 <code class=\"language-text\">Policy</code> 에 대하여 공부해보도록 하자. <code class=\"language-text\">Scheduling Policy</code>란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다.</p>\n<p>오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다.</p>\n<h1 id=\"scheduling의-목표\" style=\"position:relative;\"><a href=\"#scheduling%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"scheduling의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scheduling의 목표</h1>\n<p>우선 CPU burst time에 대하여 알 필요가 있다.</p>\n<blockquote>\n<p>CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간</p>\n<p>만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임</p>\n</blockquote>\n<p>scheduling의 목표는 다음과 같다.</p>\n<ul>\n<li>Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다</li>\n<li>Minimize average <code class=\"language-text\">turnaround time</code> : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화</li>\n<li>Minimize average <code class=\"language-text\">response time</code> : 평균응답시간(최초실행시간 - Process도착시간의 평균)을 최소화</li>\n<li>Fairness : 프로세스를 차별하지 않고 공평하게 처리해야함</li>\n<li>Minimize overhead : context switching하기 위한 오버헤드를 최소화해야함</li>\n</ul>\n<p>여기서는 동시에 여러 프로세스들이 ready queue에 들어와있으며, I/O 등의 작업을 사용하지 않는다고 가정하자.</p>\n<h1 id=\"fifofcfs\" style=\"position:relative;\"><a href=\"#fifofcfs\" aria-label=\"fifofcfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO(FCFS)</h1>\n<p>먼저 ready queue에 들어온 process를 실행시키는 것이다. 그리고 프로세스는 작업이 끝날때까지 CPU를 점유한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrklEQVQ4y61UuYoCURBsQTwi/TMx8CsMBcXMRPAPzEw9MVDwNlMEA+8LFVEDQfECb1Fr6V5m2GU3cdmG4tV79abpnq4Zut1u2O12OBwOOB6Psj6fT3C8Xi+8G+T3+2E2m5FMJpHNZuHz+TAcDkXkxJz0HZDX6wURIRKJIJFIwOl0otfr4a9BHo9HEgYCAYRCIdjtdlSrVRFPp5PgcrkIFH69Xn9wBndE6XQaDocDpVIJmUwG4XAYrVYL7XYb/X4f0+kUnU4H3W5X+GAwQLPZxGw2E95oNITz3fl8Djqfz2q56/Va5avVSgbEsdlssN1uhe/3eyyXS7WDxWKhPjMej0H456BarSYT5na5/a/gcx4Wa6lU6pvG+3w+j9FohMlkIq2z7chischQ/gKtVotYLIZoNAqXyyV2I6vVKqJGo3k7oV6vRzwel6Rut1uqJZvNJqLRaJQLOp1OVoUr+Lo3GAxSnclkElcEg0GpUBKy59gibIVcLgd+p2wR5qyxyQuFAiqVilijWCyiXC4L55XBdqnX658J7/e7OiE2qRJs2t/O+f7j8VA/TbaOEvxP+AADszANcQSf5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fifo\"\n        title=\"fifo\"\n        src=\"/static/818688cf4bd6a872f518bf7dd1f85bcc/37523/FIFO.png\"\n        srcset=\"/static/818688cf4bd6a872f518bf7dd1f85bcc/e9ff0/FIFO.png 180w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/f21e7/FIFO.png 360w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/37523/FIFO.png 720w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/302a4/FIFO.png 1080w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/07a9c/FIFO.png 1440w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/74e37/FIFO.png 1732w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 두가지 경우를 보며 turnaround time을 계산해보도록 하자. 0초에 프로세스ABC 순으로 들어온 경우이다.</p>\n<p>첫번째 경우에는 처음 들어와서 종료될때 까지의 시간이 10,20,30 이므로 (10+20+30)/3 = 20초이며, 두번째 경우에는 (100+110+120)/3 = 110 초로 차이가 크다.</p>\n<p>두번째 경우와 같이 먼저 들어온 오래 걸리는 process때문에 turnaround time이 증가하는 현상을 <code class=\"language-text\">convoy effect</code>라고 한다. 마트에서 계산대에 맨 앞에 가장 많은 물건은 담은 카트의 사람이 계산하는 것과 비슷한 현상이라고 볼 수 있다~ 스케줄러는 turnaround time을 줄이기 위해 다른 알고리즘을 생각할 필요가 있을 것이다.</p>\n<h1 id=\"sjfshortest-job-first\" style=\"position:relative;\"><a href=\"#sjfshortest-job-first\" aria-label=\"sjfshortest job first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF(Shortest Job First)</h1>\n<p>말 그대로 가장 짧은 일을 먼저 하는 것이다. 아까와 같이 ABC가 동시에 들어올 때, 가장 짧게 걸리는 B와 C를 우선적으로 실행하는 것이다. 그렇다면 turn around time은 (10+20+120)/3 = 50 초가 될 것이다. 하지만 이 역시도 몇가지의 문제가 존재한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB80lEQVQ4y6VUOWuqQRQdSzv/gHEpbbSzDmgKFUUkqEltZyEqQVwK179gKYo2IoiF2qZIECtBBUFQQQvFDTfc9YQZ+PLyNsJ7XjjMmTN37ndnvsOQ7XaL3W6H4/GI74LmfRek3W7j9fUV6XQaDocDDw8P0Ol00Gq1P0Gj0UCtVv+mU9B8lUqFVqsFUqvVkM1mEQwGIZfLQQj5b7y9vYHU63XkcjlWUKFQ3FTw/f0dpFqtolgsIplMwm63w2QywWKxQK/Xw2w2MxgMBjw+PsJqtcJoNDI8PT198ufnZ3b0ZrMJMp1OcblccDqdMBwOPy93PB5/8slkguv1yvhsNsPhcGB8vV5jPp8zTrXBYADCbeKKns9nBprAzf/G6UjdQfdyc7LZbDAajVhH9At08ZYg1FuNRoO1To/A+ZJitVqx41LO6V9H2u1yuWR5i8WCNUPohQoEAkilUkgkEohEIgaxWIy7uzsIhULGOZ1bo7pMJkOhUECpVEIoFEK/3we5v79nv5zH4/2zTfh8PvNwPp+H0+lEt9sFUSqVN3kvkUgglUrBZrOh0+mAxONx+Hw+RCIRuN1u1no4HIbL5WJmp/rLywv8fj9isRg8Hg+8Xi+i0SgCgQDK5TIqlQoymQx6vd4P29DY7/d/fAi+6r8+IpwPaVAffgBkcviHGx4DAQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sjf\"\n        title=\"sjf\"\n        src=\"/static/6160a046e28af39472e2c618efacecda/37523/sjf.png\"\n        srcset=\"/static/6160a046e28af39472e2c618efacecda/e9ff0/sjf.png 180w,\n/static/6160a046e28af39472e2c618efacecda/f21e7/sjf.png 360w,\n/static/6160a046e28af39472e2c618efacecda/37523/sjf.png 720w,\n/static/6160a046e28af39472e2c618efacecda/302a4/sjf.png 1080w,\n/static/6160a046e28af39472e2c618efacecda/07a9c/sjf.png 1440w,\n/static/6160a046e28af39472e2c618efacecda/baa75/sjf.png 1746w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p>우선, 작업의 길이를 알고 있기 쉽지 않다. 실제 상황에서는 A,B,C가 동시에 들어올 때, 가장 짧게 걸리는 프로세스를 예측 정도만 하고 알수는 없을 것이다.</p>\n</li>\n<li>\n<p>위의 두번째 그림처럼 A가 더 먼저 들어오고, 5초에 B와 C가 들어오면 결국 FIFO와 유사한 “좋지 않은 turnaround time”이 나타나게 된다.</p>\n</li>\n</ol>\n<p><u>두번째 문제</u>를 해결하기 위해 Process의 실행에 OS가 개입하여 스케줄링을 하는 <code class=\"language-text\">선점형 스케줄러</code>의 필요성이 나타난다. non-preemtive scheduler는 프로세스가 끝날 때까지 기다리므로, 랜덤하게 프로세스가 들어오는 상태에서 SJF는 제 성능을 낼 수 없다. 반면에, 프로세스의 실행 중의 timer 등으로 <strong>OS가 개입하여 프로세스의 <code class=\"language-text\">context switching</code>을 수행할 수 있는 <code class=\"language-text\">preemtive scheduler</code>는 다른 방법을 제안</strong>할 수 있다.</p>\n<h1 id=\"stcfshortest-time-to-complete-first\" style=\"position:relative;\"><a href=\"#stcfshortest-time-to-complete-first\" aria-label=\"stcfshortest time to complete first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STCF(Shortest Time to Complete First)</h1>\n<p>여기서부터는 scheduler가 주기적으로 상황을 체크하고, 이에 따라 context switching을 수행하는 선점형 스케줄러이다. 말 그대로, 완료하기까지에 남은시간이 가장 적은 순서부터 수행한다는 것이다. 따라서 <code class=\"language-text\">SJF</code>에서 임의의 시간에 ready queue에 들어온 프로세스들이 기다리게 되는 현상을 해결할 수 있을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABAUlEQVQoz6WRPaqDQBSFZwE2acQViKKbENeT2i0oSBotRGy0kxQWBsHCxtoypMsGRPxDtFHPYwYM74FNeBfOcDnzce9whuz7jrqu0XUd3u835nnGf4rQgw56vV4YxxHDMGDbNqzr+kd08TRNTGf3B0PKsoQsy0iSBHme43a7QdM0iKIIVVWhKMpHkiQx9rdHGcrqus4eRB6PBwghiOMY9/sdhmGA53nmfSNBEFhsJE1TZgRBgCiKcL1ewXHc1wMvlwv6vgd5Pp9wHAdVVaEoCmRZhjAMYZombNuG7/uwLOu0PxjP8+C6Ltq2BVmW5fNDNPCjaPBH0cDPesocHPWbpsEPSbuI6bDTYYoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"stcf\"\n        title=\"stcf\"\n        src=\"/static/fe33c7b89f59d87efce76610c576e01b/37523/stcf.png\"\n        srcset=\"/static/fe33c7b89f59d87efce76610c576e01b/e9ff0/stcf.png 180w,\n/static/fe33c7b89f59d87efce76610c576e01b/f21e7/stcf.png 360w,\n/static/fe33c7b89f59d87efce76610c576e01b/37523/stcf.png 720w,\n/static/fe33c7b89f59d87efce76610c576e01b/4c42d/stcf.png 896w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>B,C가 도착한 시간에 스케줄러는 프로세스마다 남은 시간을 확인한다. 여기서, A보다 B,C가 일찍 끝난다고 판단되면 그것들부터 먼저 실행을 하는 것이다. 위의 경우, turnaround time은 (120+10+20)/3 = 50초가 될 것이다. 즉, SJF의 이상적인 환경일때의 turnaround time을 동시에 도착하지 않는 프로세스들 사이에서도 보장해줄 수 있다.</p>\n<h2 id=\"response-time의-고려\" style=\"position:relative;\"><a href=\"#response-time%EC%9D%98-%EA%B3%A0%EB%A0%A4\" aria-label=\"response time의 고려 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Response Time의 고려</h2>\n<p>매우 좋아보이지만, 여기서 스케줄러의 성능 평가 지표중 하나인 <code class=\"language-text\">response time</code>을 들여다보자. 응답 시간은 <em>프로세스 도착시점부터 해당 프로세스의  최초 실행시점까지의 시간</em>을 의미한다. 또한 <strong>시스템과 상호작용을 원활히 하기위한 사용자의 요구와 관련</strong> 되어 있다.</p>\n<p>non-preemptive scheduler의 경우, 더 우선순위가 높은 다른 프로세스가 끝날 때까지 첫 실행시간이 지연되므로 response time이 매우 좋지 않다. 추가적으로, STCF도, 비슷한 종료시간의 프로세스들이 동시에 도착한다면 기다리는 시간이 적지 않음을 알 수 있다. 예를 들어 위의 경우에서 C를 실행하고 10초뒤에 실행되는데 이는 우리가 느끼기에 매우 느린 속도이다.</p>\n<p>따라서 응답시간이 빨라야 사용자는 빠르다고 느끼므로, <strong>응답시간에 좀 더 중점을 두고 스케줄링 정책을 고려</strong>할 필요가 있을 것이다.</p>\n<h1 id=\"rr\" style=\"position:relative;\"><a href=\"#rr\" aria-label=\"rr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RR</h1>\n<p>Round Robin이라는 방식은 응답시간을 줄이기 위해 <code class=\"language-text\">time slice</code> 개념을 도입한다. 프로세스의 실행과 관련없이 <strong>주기적으로 시간을 쪼개고, 그때마다 번갈아가면서 프로세스를 실행하는 것</strong>이다(따라서 preemptive). time slice의 간격이 작으면 응답시간이 빠르고, 너무 작다면 context switching하는 데 너무 많은 시간을 소비하게 되므로 이를 적당히 잘 고르는 것이 중요하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNUlEQVQoz42RPcuCYBSG/WVNubi0tQuBFAmtDQ7W4GhETjXZKG39CX+CYhBKg4JlRWQfer+cE4XIO3jgPM/h5nCdL+H5fILs9XqhKAr2sizxeDxYv9/v/JPWxITVaoX1eg3btmFZFhzHwWw2w2azwXw+x3a7xfl8bgwVer0eZFnGYDBAp9PBeDxGu93GZDJBq9VieBiGnPx+v39T1P1bTOj3+1AUBaPRCN1uF5qmQZIkGIYBURSxWCwQx3GjcQkq6LoO8ul0ylDqSFVVmKaJ4XCI5XIJ13URRRGCIIDv+9jv99jtdvA8j2PSkiT5dHi5XJhMezoejyyeTiccDgeOr9crj0xHStOUIXmecw6B6GhZlnEBBv636O9eyG632+8o9cNUY9ovj0xP3avJ1CF1UNXqeVXwH2ZEPJUMfaQzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rr\"\n        title=\"rr\"\n        src=\"/static/71b76292c22ac325ad6a4aecd097bf1f/37523/RR.png\"\n        srcset=\"/static/71b76292c22ac325ad6a4aecd097bf1f/e9ff0/RR.png 180w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/f21e7/RR.png 360w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/37523/RR.png 720w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/076ca/RR.png 914w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하지만 <code class=\"language-text\">turnaround time</code>의 측면으로 보았을 때, 모든 프로세스가 동시에 끝나게 되므로, 최악의 평균 시간을 갖게 됨을 알 수 있다… 그렇지만, 응답시간이 뛰어나고 공평한 프로세스의 분배가 이뤄지는 것을 알 수 있다.</p>\n<p>preemptive한 스케줄러인 <code class=\"language-text\">STCF</code>와 <code class=\"language-text\">RR</code>의 장단점을 생각해보며 다음으로 넘어가면 좋을 것 같다.</p>\n<h1 id=\"입출력을-고려한-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"입출력을 고려한 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입출력을 고려한 스케줄링</h1>\n<p>아직까지 고려되지 않았지만, 실제 scheduling에서는 몇가지 조건이 추가적으로 있다.</p>\n<ol>\n<li>프로세스 실행 도중에 IO가 호출된다</li>\n<li>프로세스의 실행시간을 알 수 없다 (따라서 STCF는 거의 불가능하다)</li>\n</ol>\n<p>첫번째로, 프로세스 실행 중 입출력이 발생하는 경우에 대하여 알아보자.</p>\n<p>예전에도 배웠다시피, 입출력이 발생하면 해당 프로세스의 상태는 <strong>block</strong>이 된다. 그리고 위에서 언급한 스케줄러의 목표 첫번째(CPU를 최대한 활용)를 위하여 CPU는 해당 프로세스의 입출력 작업이 완료될때까지 다른 작업을 수행할 것이다. 또한 입출력 작업이 완료되었을 때에도, context switching을 할지 결정해야한다.</p>\n<p>예를 들어, 각각 작업시간이 50ms인 프로세스 A,B가 있다고 하자. A 프로세스는 10ms마다 10ms가 걸리는 IO 작업을 수행하며 B는 입출력을 하지 않는다고 가정하자. 그랬을 때 입출력을 고려하지 않은 STCF는 아래의 첫번째 그림같이 비효율적으로 운영될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACOklEQVQoz4VTTUtqURS9M2voP2giOGwYOGhs42Y6ERIdCE6amJUSjSJw0iRoEoL2C5JUJBFFBw20TwwxtfwKtdTU8mM91obzeO9N3oLt3t5z7zrrrL2PtlgsQDw9PaHZbKLX6+H29haz2QyFQgEfHx94e3tDsVjEeDyWtVqthkajgff3d6lbrZZ8+/PzA63b7WIwGMBgMODo6AiJRAJ6vV42WV5eRi6Xg8fjwfr6Ovr9PjRNw+npKa6vr3F1dSURjUYRi8Xw+fkJ7evrC4xgMIidnR14vV7s7+9LsN7b28Pu7q4E64ODA1FOZS8vL6hUKr9jMplAo9xyuSyKnE4n1tbWUK/XRQnXVldXhfzy8hJLS0tQ4PGm0+lfQWj8oY/39/fiTyQSkZxMJpFOp3FzcyNHenh4ENJ8Pi8116gwk8ng8fFRnlG1RjKy03BCZWI0Gkmmd0rV9/e31GyWWlMc7IeGP8APFOjHvxsoMpXVhKgsR2aHh8MhXC4XwuEwzs7O4Ha7kc1mYbFYEI/H4fP5ZAJoh9VqlWOykcR8PhdCFRrJKJtjs729DbvdLnUoFIJOp8PJyQlMJhPMZjMCgYA0hl5SiCJUIYTsKIeS2NjYgM1mEwUk63Q6WFlZwfn5OY6Pj2E0GvE/aDSeu3Hy/X4/Dg8PkUqlsLm5KbfH4XDg4uJC7Nja2sLr6ytKpZJ0lbPHzP+8SXJTyMoO8UWiWq1KI2iFevb8/CxZXbd2uy1jxsbd3d3JDeEIcX5/AZd5JWOeA/zPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"io\"\n        title=\"io\"\n        src=\"/static/58ad25fa51cd5527dd0c321fef0f1ceb/37523/io.png\"\n        srcset=\"/static/58ad25fa51cd5527dd0c321fef0f1ceb/e9ff0/io.png 180w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/f21e7/io.png 360w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/37523/io.png 720w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/302a4/io.png 1080w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/07a9c/io.png 1440w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/a2498/io.png 1764w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>처음에 A가 실행되고, 10ms 뒤에 A가 blocked되었을 때에도 A가 남은 시간이 더 적으므로 A를 계속 선택하게 되는 것이다. 따라서, 입출력을 고려한 스케줄링 정책은 다를 필요가 있다. A를 10ms의 작업 5개로 보는 것이다. A의 작업이 10ms 시점에 끝나므로 B가 실행이 되고, A가 입출력이 끝나면 다시 더 조금 남은 A가 실행이 되는 식이다. 위의 두번째 그림이 이와 같다.</p>\n<p>이처럼 입출력이 잦은 프로세스는 짧고 자주 실행되도록 하여 CPU 사용량을 높일 수 있을 것이다. 하지만, 우리는 가장 어려운 조건이 남아있다. 실제 프로세스의 작업량을 scheduler가 알기 매우 어렵다는 것이다! 따라서 STCF와 RR의 개념을 응용하여 실행시간을 예측하기 어려운 상태에서 스케줄링을 최선(스케줄링의 목표 달성)으로 하는 방법이 고안되고 있다.</p>\n<h1 id=\"mlfqmulti-level-feedback-queue\" style=\"position:relative;\"><a href=\"#mlfqmulti-level-feedback-queue\" aria-label=\"mlfqmulti level feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MLFQ(Multi-Level Feedback Queue)</h1>\n<p>가까운 과거를 통하여 미래(실행시간)를 예측하고, <strong>우선순위가 있는 queue(linked list)를 여러개 두어 스케줄링</strong>을 하도록 하는 스케줄러이다. 이는 LINUX에서 사용하는 스케줄링과 유사하다고 한다. 몇가지 원칙은 다음과 같다.</p>\n<ul>\n<li>Priority(A) > Priority(B)이면, A가 실행된다 (B는 실행되지 않음).</li>\n<li>Priority(A) = Priority(B)이면, A와 B는 RR방식으로 실행된다.</li>\n<li>프로세스가 들어오면,가장 높은 우선순위의 큐에 놓여진다.</li>\n<li>주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다.</li>\n<li>타임 슬라이스를 소진하기 전에 (io등으로 인하여)CPU를 양도하면 우선순위를 유지한다.</li>\n</ul>\n<p>그림으로 간단하게 표현하면 아래와 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABW0lEQVQ4y52U2Y6DMAxF+f9fq1S1fYCH7gXRfVMpiNWjY8kVRZkBjSWLxDE3ju9NPPnDmqZxxvM8/1ory1KqqtKxl2WZzGYziaJI4jiW1Woly+VSFouFJtzvd9lutwpyOp3keDyqXy4XeT6fcr1e9T8cUI/EIAjkcDho0n6/l91upxtQxev10tj7/ZbNZqNjA12v17oZY+IKKD1Ghew++Mgs1HWtCebMcYwKAcUsz6ydZz33+gihR/P5/BNrezvX5r2AVAioq0Ibt2O9gBAF820risIJNggwTVOVB/IyJdxuN4259Dqoh8gFYJMTEgH4X4BJksj5fP5ao1qTSZcgr8tcl8XH4/HR4W+kDOqhGUfjNgy1j7Bhji+qx5nb8aiSNW4IbiQ5j0zCeDyWyWSid3M6nepjMRqNFJj+QQS99H1fc8IwVMadpDABlApodNtZ42vVmgZhnsfCVeEP567iDh+tzn4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mlfq\" title=\"mlfq\" src=\"/static/92602f6385c6161cbf63c717dc4d2fd0/37523/mlfq.png\" srcset=\"/static/92602f6385c6161cbf63c717dc4d2fd0/e9ff0/mlfq.png 180w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/f21e7/mlfq.png 360w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/37523/mlfq.png 720w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/d52e5/mlfq.png 848w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>프로세스는 처음 스케줄러에 진입시, 높은 우선순위 큐에 순서대로 들어가게 된다. 같은 우선순위에 있는 프로세스라면 RR방식으로 실행되며 사용량이 time slice(혹은 어떠한 기준)를 넘어선다면 해당 프로세스의 우선순위를 낮추는 것이다. 하지만, IO 작업등으로 다른 프로세스가 실행되도록 하거나 time slice를 다 쓰지 못한다면 우선순위를 유지한다.</p>\n<h2 id=\"어떻게-mlfq에서-실행시간을-추측할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-mlfq%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%B6%94%EC%B8%A1%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 mlfq에서 실행시간을 추측할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 MLFQ에서 실행시간을 추측할까?</h2>\n<p>MLFQ에서는 우선 작업을 높은 순위에 배치한다. 만약 **<u>해당 작업이 금방 끝난다면 끝나는 거고, 오래 걸린다면 자연스럽게 우선순위가 떨어지게 될 것</u>**이다. 이는 STCF와 유사하다고 볼 수 있다! 또한, <strong>입출력이 많은 대화형 작업의 경우에도 우선순위를 높게 유지하도록 하여 response time을 작게 해주는 효과</strong> 또한 존재한다.</p>\n<h2 id=\"mlfq의-한계\" style=\"position:relative;\"><a href=\"#mlfq%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"mlfq의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MLFQ의 한계</h2>\n<p>여태까지의 이슈를 해결해주는 스케줄링 기법이긴 하지만 MLFQ에도 한계점이 존재한다.</p>\n<ol>\n<li>\n<p>Starvation</p>\n<p>다른 Process들이 모두 interactive하다면(입출력이 자주 있다면), IO가 적은 특정 프로세스들은 계속하여 스케줄링되지 못하는 현상이 발생할 수 있다. 따라서, 주기적으로 <code class=\"language-text\">Priority Boost</code>를 통하여 프로세스가 선택되도록 한다. 이는 CPU bound 했다가 IO bound 작업이 많아지는 프로세스에서도 유용할 것이다.</p>\n</li>\n<li>\n<p>Gaming the scheduler</p>\n<p>time slice 직전까지 점유하다가, IO를 발생시키는 것을 반복하는 악의적인 프로세스가 있을 수 있다. time slice의 99%만큼 사용한 경우에 CPU를 양도하게 되면 CPU를 거의 독점할 수도 있다. 따라서, time slice단위로만 측정하는 것이 아니라 Process가 해당 우선순위에서 얼마나 사용했는지를 누적 기록하여 time slice를 초과할 때 우선순위를 낮출 수 있다.</p>\n</li>\n</ol>\n<p>추가적으로, time slice를 얼마로 조정해야하는지 등이 이슈가 있다. 보통 우선순위가 높은 큐는 짧은 time slice를 적용하여 response time을 줄이고, 대화형(interactive) 작업을 빠르게 처리한다고 한다. 오늘날에는 MLFQ를 개선한 많은 스케줄러가 쓰이고 있다고 한다.</p>\n<p>오늘까지 CPU scheduler에 대하여 배웠다. 다음에는 multi process에서 프로세스간 통신에 대하여 공부해보자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지()에 대하여 공부해보았다. 오늘은 scheduling을 할 때 순서를 결정짓는  에 대하여 공부해보도록 하자. 란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다. 오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다. Scheduling의 목표 우선 CPU burst time에 대하여 알 필요가 있다. CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간 만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임 scheduling의 목표는 다음과 같다. Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다 Minimize average  : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화 Minimize …","frontmatter":{"date":"July 26, 2023","title":"(OS) 운영체제 복습 [5. Scheduling Policies]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(5) - Scheduling Policy/"}},"next":{"id":"f8a99189-165d-5bbd-9e80-a64a0c519a84","html":"<p>이번에는 실제 프로세스가 실행되는 과정을 운영체제의 역할에 초점을 맞추어 공부해보도록 하자.</p>\n<h1 id=\"process-execution-direct-execution\" style=\"position:relative;\"><a href=\"#process-execution-direct-execution\" aria-label=\"process execution direct execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process Execution (Direct Execution)</h1>\n<p>Process를 실행할 때 <strong>단순한 운영체제</strong>가 하는 일들을 순서대로 알아보자. 간단하게 하나의 CPU에서 하나의 Process가 실행된다고 가정하자.</p>\n<ol>\n<li>\n<p>OS는 메모리를 할당하고 memory image를 만든다.</p>\n<p>메모리 이미지는 저번에도 언급했듯 code, data, stack, heap 영역을 포함한다.</p>\n</li>\n<li>\n<p>CPU의 Program Counter, 그리고 기타 레지스터(Stack Pointer)들이 초기화된다.</p>\n</li>\n<li>\n<p>위의 세팅 과정이 끝나고, Process는 CPU를 점유하고 명령어들을 실행하게 된다 (명령어 실행 과정에서 OS는 개입하지 않음)</p>\n</li>\n</ol>\n<h2 id=\"일반-함수의-실행-과정\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98-%ED%95%A8%EC%88%98%EC%9D%98-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95\" aria-label=\"일반 함수의 실행 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반 함수의 실행 과정</h2>\n<p>예를 들어, 어떠한 함수를 실행한다고 하자.</p>\n<p>함수 실행시, 메모리에서는 함수의 내용이 존재하는 위치로 <code class=\"language-text\">JUMP</code>하게 된다. 이때, 함수 종료 이후의 실행을 위해 기존의 메모리 위치(기존 PC의 값)를 갖고 점프해줘야 한다. 함수의 실행은 stack영역에서 이루어지므로 함수가 stack에 push되며, SP(Stack Pointer)가 업데이트 될 것이다. 함수가 종료되면, stack frame을 pop하고(SP도 업데이트) 저장해놓았던 기존의 메모리 위치로 PC값을 다시 업데이트해준다.</p>\n<p>하지만, 이처럼 프로세스의 초기화 이후의 <u>실행을 전적으로 OS가 관여하지 않는 것은 몇가지 문제가 존재</u>한다.</p>\n<ol>\n<li>운영체제는 프로세스가 어떤 나쁜 짓들을 하는지 알 수 없다. 메모리를 할당받거나, 파일 입출력을 하는 등의 하드웨어 자원을 사용하는 것은 특수한 연산이고 <strong>프로세스 맘대로 하게 해선 안된다</strong>.</li>\n<li>프로세스가 독립적으로 실행되므로, 운영체제가 개입하여 프로세스의 상태를 바꿀 수 없다. 즉, <strong>time sharing이 불가능</strong>하다!</li>\n</ol>\n<p>따라서, 우리는 <code class=\"language-text\">Limited Direct Execution</code>(제한적 직접 실행)이라는 이름으로 프로세스를 실행하도록 하며, 이를 위해 <code class=\"language-text\">system call</code>이 존재한다!</p>\n<h2 id=\"system-call의-실행-과정---hw-privilege-level\" style=\"position:relative;\"><a href=\"#system-call%EC%9D%98-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95---hw-privilege-level\" aria-label=\"system call의 실행 과정   hw privilege level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>System Call의 실행 과정 - H/W privilege level</h2>\n<p>H/W자원에 접근하기 위해서는 system call을 이용하는 것이 Limited Direct Execution의 핵심인데, 먼저 CPU의 <code class=\"language-text\">privilege level</code>을 알 필요가 있다.</p>\n<p>CPU와 같은 하드웨어는 자원에 접근하기 위한 권한에 대한 mode가 존재한다. 크게 기본적인 <code class=\"language-text\">user mode</code>와 위험한 작업을 수행할 수 있는 <code class=\"language-text\">kernel mode</code>가 있으며, <strong>시스템콜과 같은 작업들은 오직 커널 모드에서만 실행가능하다</strong>.</p>\n<p>kernel은 하드웨어를 연결되는 핵심 공간으로, 소중하고 중요하다(?) 따라서 커널은 user stack을 신뢰하지 않으므로 별도의 kernel stack을 사용한다. 또한, user mode에서 kernel 영역으로의 주소를 이동하지 못하게 한다. 악성 코드가 user mode에서 kernel의 기능을 사용하지 못하게 하기 위함이다. 대신에, 커널은 부트될 때 <code class=\"language-text\">Interrupt Descriptor Table(IDT)</code>를 초기화하고 여기에 시스템 콜과 같은 커널 기능들을 사용하기 위한 <code class=\"language-text\">trap_handler</code>의 주소를 넣어둔다. (IDT를 통해서만 커널 기능의 주소를 얻을 수 있다는 말이지, <em>IDT에 커널의 코드가 존재한다는 것은 아니다</em>)</p>\n<p>즉, user mode에서는 시스템 콜에 접근하거나 실행할 수 없으며 <strong>커널의 기능들을 사용하기 위해서는 CPU를 커널 모드로 바꿔야 한다</strong>!</p>\n<h2 id=\"mechanism-of-system-call-trap-instruction\" style=\"position:relative;\"><a href=\"#mechanism-of-system-call-trap-instruction\" aria-label=\"mechanism of system call trap instruction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mechanism of system call (trap instruction)</h2>\n<p>위의 함수 실행과 다르게, system call은 호출시 <code class=\"language-text\">trap</code>이라는 instruction이 수행된다. 역으로 user mode로 돌아오려면 <code class=\"language-text\">return-from-trap</code> 명령어가 존재한다. trap 명령어는 다음의 일들을 수행한다.</p>\n<ul>\n<li><u>CPU를 커널 모드로</u> 바꾼다 (커널모드는 CPU가 바뀌는 것이다. CPU가 수행가능한 작업의 권한을 높여주는 것이라고 생각하자)</li>\n<li>kernel stack으로 SP를 옮긴다. (해당 작업은 커널 모드에서만 가능!) <strong>커널 스택은 사용자 스택과는 물리적으로 다른 곳에 위치하며, 프로세스마다 갖는다.</strong></li>\n<li>기존의 값(PC, registers 등… 이를 <code class=\"language-text\">context</code>라고도 함)을 <em>kernel stack에 저장</em>한다. → 이는 <code class=\"language-text\">return-from-tap</code>시, user context를 복원하기 위함임</li>\n<li>수행될 일에 따라, IDT에 있는 주소를 보고 trap handler function이 있는 곳으로 JUMP하여 system call이 수행된다.</li>\n</ul>\n<p>추가적으로 Trap 명령어는 시스템 콜 호출을 포함하여 다양한 상황에서 수행된다.</p>\n<ul>\n<li>System call (Program이 OS의 기능에 접근하려 할 때)</li>\n<li>Program fault 발생 시(ex. segmentation fault 발생!)</li>\n<li>interrupt 발생시</li>\n</ul>\n<h3 id=\"return-from-trap\" style=\"position:relative;\"><a href=\"#return-from-trap\" aria-label=\"return from trap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>return-from-trap</h3>\n<p>system call, 또는 interrupt가 종료되면 trap모드가 종료되는데, 이때 <code class=\"language-text\">return-from-trap</code> 명령어가 수행된다. 이는 trap 명령어에서 커널스택에 놓았던 것들을 user stack으로 다시 옮기는 작업이 포함된다.</p>\n<ul>\n<li>해당 프로세스의 kernel stack에 있던 context들을 다시 user stack으로 restore(복원)한다.</li>\n<li>CPU를 user mode로 조정한다.</li>\n<li>trap 실행 이후의 user code로 PC를 조정하고 코드를 실행한다.</li>\n</ul>\n<p>trap 명령어와 return-from-trap을 간단하게 그림으로 보면 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0ElEQVQoz0WS62tTQRDF73+rfhUFURAFv4lIJa20CqIWxYKI2kSpfSc+YpukMaQtzW3u+5E079w82mbvT3Zj68Awe87MsmdmVgOohR6eaxJFPQkRYgLiXLmQUXKTKY7FmcrHcaxc5cUZ8WTKa62GQbnwmT+FLSrllLrcqh+ymXlNav0lTjWjOLOyzsrWW7Yzr4g6FhcW2Dts/1hiK/OGmreH5rv7fP2U4PnCI4o77xgOxwR2nsTsTe4+uMp+MUng1yhkl7hz7woL87cI3BKdbp9+NEY/WOPhzHUeJ24Q2Ltoo0GN9OocXz7OUMq/xwibHFWypFfm2EjNUswvUz522Nv9wGp6kXT6BbqexwgbqrZc+sZmKsF68gm+nUMzj3O45k+lTN9PqjZCt0AoVbRDLH1TcdXSMtGzebylpzTb+mXLrvGd5olBPTzCt37LGZo41W26LQNL31BFjdohnvWLRljGM7OKsw/WaN++hrdwn3bP/T9DJ0dNCnBy1P0SmhCC4bDPIOpwOh5xfi63GnM6HjAcdIljISEiFkQIRkgcS0oGtenxqM9o2FNnLYoibNvB9wOCYOrSer0+9frJpRL5sGNatBpNhS++jbROp0vjH/8XdHBETeZdFwcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"trap_img.png\"\n        title=\"trap_img.png\"\n        src=\"/static/f85ef213b1198a5bafa08f8cc6dac92e/37523/trap_img.png\"\n        srcset=\"/static/f85ef213b1198a5bafa08f8cc6dac92e/e9ff0/trap_img.png 180w,\n/static/f85ef213b1198a5bafa08f8cc6dac92e/f21e7/trap_img.png 360w,\n/static/f85ef213b1198a5bafa08f8cc6dac92e/37523/trap_img.png 720w,\n/static/f85ef213b1198a5bafa08f8cc6dac92e/302a4/trap_img.png 1080w,\n/static/f85ef213b1198a5bafa08f8cc6dac92e/07a9c/trap_img.png 1440w,\n/static/f85ef213b1198a5bafa08f8cc6dac92e/e3729/trap_img.png 1794w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>정리하면, CPU의 권한 모드에 따라 자원에 접근할 수 있는 기능을 제공하는 kernel을 이용할 수 있도록 <code class=\"language-text\">trap</code>명령어가 존재하며, 해당 작업이 끝난 이후에는 user stack으로 돌아오게 된다.</p>\n<h3 id=\"context-swtiching을-고려한-trap--return-from-trap\" style=\"position:relative;\"><a href=\"#context-swtiching%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-trap--return-from-trap\" aria-label=\"context swtiching을 고려한 trap  return from trap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context Swtiching을 고려한 trap &#x26; return-from-trap</h3>\n<p>사실 return-from-trap을 한다고 해서 trap이 실행되었던 그 프로세스가 바로 다시 schedule되어 실행되는 것은 아니다. 상황에 따라 다를 수 있는데 그 이유는 다음과 같다.</p>\n<ul>\n<li>해당 trap이 program fault 등으로 인하여 발생한 경우 → 프로세스가 종료되어야 한다</li>\n<li>해당 trap이 blocking syscall에 의하여 발생한 경우 → 해당 작업이 끝날때까지 block해야한다.</li>\n<li>추가적으로, 해당 프로세스가 그동안 너무 오래 실행되었거나 다른 process가 더 높은 실행의 우선순위에 있을 수 있다.</li>\n</ul>\n<p>이러한 경우에 <u>실행중인 프로세스가 바뀌</u>게 되는 <code class=\"language-text\">context switching</code>이 발생하게 된다!! 이제 운영체제의 Scheduler에 대하여 알 필요가 있다.</p>\n<h2 id=\"os-scheduler\" style=\"position:relative;\"><a href=\"#os-scheduler\" aria-label=\"os scheduler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS scheduler</h2>\n<p>운영체제의 스케줄러는 프로세스의 상태를 관리하는데, 크게 두가지 부분으로 나뉜다.</p>\n<ol>\n<li>Policy : 어떤 프로세스에 우선순위를 둘지</li>\n<li>Mechanism : 어떻게 해당 프로세스로 context switching을 할지</li>\n</ol>\n<p>Policy에 대하여는 다음 글에 알아보고, 오늘은 trap과 관련하여 일어나는 context switching을 어떻게 처리하는지의 mechanism에 대하여 알아보자.</p>\n<p>scheduler는 개입하는 시점을 누가 결정하냐에 따라서 non-preemptive(cooperative 협조)방식과 preemptive(or 비협조 방식)으로 나뉜다. 전자는 process에서 interrupt가 발생할 때마다 스케줄링을 하는 방식인데, 이는 프로세스가 무한루프에 빠지거나 시스템 콜 등을 호출하지 않는 경우 (즉 return-from-trap이 호출되지 않는 경우)에는 스케줄링이 어렵다(<em>특정 프로세스가 CPU를 독점하게 된다</em>). 따라서 오늘날의 운영체제는 <strong>특정 프로세스의 독점을 막기위해 주기적으로 timer interrupt를 호출시켜 스케줄링을 수행</strong>하도록 하는데 후자의 방식이 이와 같다.</p>\n<h3 id=\"mechanism---context-switch\" style=\"position:relative;\"><a href=\"#mechanism---context-switch\" aria-label=\"mechanism   context switch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mechanism - context switch</h3>\n<p>그렇다면, 운영체제에서 어떻게 process간 전환을 수행할까?</p>\n<p>A 프로세스가 실행중이고, B 프로세스로 넘어가는 과정을 생각해보자.</p>\n<ul>\n<li>kernel stack에 A의 context(PC, SP, 레지스터값들)를 저장한다.</li>\n<li>B의 커널스택에서부터 context(PC, SP 등)를 HW로 복원한다. 이때, stack pointer도 A의 커널스택에서 B의 커널 스택을 가리키도록 바뀔 것이다.</li>\n</ul>\n<p>B의 커널스택에는 이전에 descheduled될 때, B의 context가 저장되어 있었을 것이다. 위의 과정 이후에는 <u>B가 kernel mode로 실행될 것이고, return-from-trap 연산으로 user mode로 실행될 것</u>이다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>Limited Direct Execution을 통하여 <strong>운영체제는 process에 일반적인 실행에 대한 권한을 위임하고, hw에 접근해야하는 등의 중요한 명령이 실행되거나 주기적으로 개입을 한다</strong>. (항상 개입하면 느려질 것이고, 항상 개입하지 않으면 악의적인 프로세스에 대응할 수 없음)</p>\n<p>시스템 콜, 인터럽트, 폴트 등으로 인하여 한 process에 <code class=\"language-text\">trap</code> 명령어가 실행되고, 이를 통해서 CPU를 user mode에서 kernel mode로 바꿀 수 있다. kernel mode로 전환하면 프로세스마다 존재하는 <code class=\"language-text\">kernel stack</code>에 기존 context를 저장하고, 종료 이후의 <code class=\"language-text\">return-from-trap</code>에서 다시 user stack으로 context가 복원된다.</p>\n<p>또한, trap 발생시에 Process를 전환할 수 있는데, 비협조적 방식에서는 OS가 주기적으로 발생시키는 timer interrupt를 이용하여 scheduling을 수행한다. 다른 Process로 <code class=\"language-text\">context switching</code>이 일어날 때에는 deschedule되는 프로세스의 context를 그것의 kernel stack에 저장해놓고, schedule될 프로세스의 커널스택으로부터 PC, SP 등의 context를 복원하여 다른 프로세스를 실행할 준비를 마치게 된다!</p>\n<p>다음에는 OS가 실행할 프로세스를 결정하는 원리인 scheduling policy에 대하여 공부해보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"July 16, 2023","title":"(OS) 운영체제 복습 [4. Process Execution Mechanisms]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}},"prev":{"id":"30a585f6-14f0-5e91-8fc5-a19cfbfde638","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 배열에서 중복을 제거하고 제거된 배열의 크기를 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\">링크</a></p>\n<p>배열의 정렬 상태가 유지되어야하고 파라미터로 들어온 배열을 변형해야한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>처음에는 python의 set 자료형을 통하여 중복을 제거하는 방법을 생각해보았다. 하지만, 이는 순서를 유지하기 위해 sort를 수행해야하므로 선형탐색 하는 방법도 구현해보았다.</p>\n<h3 id=\"sol1-set집합-자료형으로-중복-제거\" style=\"position:relative;\"><a href=\"#sol1-set%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9C%BC%EB%A1%9C-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0\" aria-label=\"sol1 set집합 자료형으로 중복 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol1. set(집합) 자료형으로 중복 제거</h3>\n<p><code class=\"language-text\">sorted(list(set(nums)))</code>를 해주면 중복을 제거하고 정렬상태를 유지시킬 수 있다. 하지만 새롭게 만들어진 배열을 nums에다가 대입해주는 과정이 추가로 필요하다.</p>\n<h3 id=\"sol2-선형탐색하면서-중복-제거\" style=\"position:relative;\"><a href=\"#sol2-%EC%84%A0%ED%98%95%ED%83%90%EC%83%89%ED%95%98%EB%A9%B4%EC%84%9C-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0\" aria-label=\"sol2 선형탐색하면서 중복 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol2. 선형탐색하면서 중복 제거</h3>\n<p>가장 간단하게 생각해볼 수 있는 방법으로, 새로운 배열을 만들고 nums 배열을 선형탐색하며 <strong>중복되지 않는다면 값을 하나씩 넣어</strong>주면 된다. 여기서 잘 생각해보면 새로운 배열 없이 nums 안에서도 처리할 수 있다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity:</p>\n<ul>\n<li>sol1 : set 연산은 <code class=\"language-text\">O(n)</code>만큼 들고, 이후 k size 리스트를 정렬하는데는 <code class=\"language-text\">O(klogk)</code>정도 들 것이다. 그리고, nums에 할당하는 과정이 필요하니(문제의 조건으로 인하여) <code class=\"language-text\">O(k)</code>만큼의 시간이 더 들 것이다.</li>\n<li>sol2 : O(n)</li>\n</ul>\n</li>\n<li>\n<p>Space complexity:</p>\n<ul>\n<li>\n<p>sol1 : O(k) (중복이 제거된 배열의 크기)</p>\n</li>\n<li>\n<p>sol2 : O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeDuplicates</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        remove duplicate in non-decreasing list\n        \"\"\"</span>\n        after_mod <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>after_mod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> after_mod<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>after_mod<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeDuplicates</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        remove duplicate in non-decreasing list\n        \"\"\"</span>\n        k <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 중복 발생</span>\n                <span class=\"token keyword\">pass</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 다르다면, nums 배열에 넣어줌</span>\n                nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n                k <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> k</code></pre></div>\n<p>처음에는 <code class=\"language-text\">new_list = []</code>를 만들고, 중복이 발생하지 않을때만 nums[i]를 넣어주었다. 하지만 nums[i]까지 탐색했을 때, new_list의 크기가 k라고 하면 <strong>k는 항상 i보다 작다는 것을 알 수 있다</strong>. 따라서 이전의 값을 다시 사용할 일이 없으니 new_list 대신 nums를 그대로 사용하면 된다.</p>","frontmatter":{"date":"August 23, 2023","title":"(Alg) LeetCode Top Interview 150 - 26. Remove Duplicates from Sorted Array","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-26/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(5) - Scheduling Policy/","nextSlug":"/OS(4)-Process Execution Mechanisms/","prevSlug":"/Alg-LC-26/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}