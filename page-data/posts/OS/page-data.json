{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/OS","result":{"pageContext":{"currentCategory":"OS","categories":["All","OS","WEB","Alg","BE","FE","블로그","ADsP"],"edges":[{"node":{"id":"db6352b0-91a9-5d92-91ca-fb220b7a3ec1","excerpt":"저번 글에서는 Process의 실행의 주체인 Thread에 대하여 공부하고, multi-thread computing 환경에서 CPU core의 수와 관계 없이 발생할 수 있는 문제인 (경쟁 상태)에 대하여 경험하였다. 이는 의 저수준 명령어가 하게 이뤄지지 않으며, 한 스레드가 실행중인 동안 (상호 배제)가 보장되지 않고 스케줄되기 때문이라고 배웠다. 오늘은 여러 쓰레드가 동시에 특정 자원에 접근할 때, 공유되는 자원을 예상가능하게 관리하는 방법인 Lock 기법에 대하여 공부해보자. Locks  위의 코드는 으로 지정되어야 하고, 이를 위해 lock variable을 도입한다. 락의 사용법을 간단하게 표현하면 다음과 같다. lock 변수를 선언하고, 어떤 스레드에서 해당 lock을 얻어야만 counter = counter + 1; 영역에 접근할 수 있다. 이후 unlock으로 락을 해제한다. 어떤 쓰레드가 락을 얻었다면 다른 쓰레드는 해당 영역에 접근하지 못한다(그동안 block…","fields":{"slug":"/OS(12)-Locks/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [12. Locks]","date":"December 07, 2023"}},"next":{"fields":{"slug":"/OS(11)-Memory Allocation/"}},"previous":null},{"node":{"id":"7ddd8ab6-bee4-537e-b771-8d7364afb737","excerpt":"저번까지 Virtualization에 대하여 공부했고, 오늘부터는 동시성/병행성 (Concurrency)에 대하여 공부해보자. 멀티 쓰레드 프로그램에서는 메모리 공간에 동시에 접근하는 상황이 일어나게 되는데, 이에 대해 운영체제는 충돌이 나지 않도록 몇가지 방법을 제공해주는데, 이것이 concurrency와 관련이 있다. 차근차근 알아보자. Thread 여태까지 우리는 단일 쓰레드 프로그래밍 환경을 전제로 공부했다. 간단하게 복습해보면, 한 프로세스에 하나의 실행 흐름만 존재하는 것이다. 현재 실행되는 주소 공간 상의 위치를 알기 위하여 PC(Program Counter), SP(Stack Pointer)를 두어 프로세스의 실행을 관리한다. 하지만, Process는 실행 중에 여러 Thread를 가질 수도 있다! 그럼 쓰레드가 뭐지? 쓰레드는 프로세스에서 작업의 단위로, Process에서 필요한 부분만을 복사하여 실행되는 것이라고 볼 수 있다. 한 프로세스 내의 쓰레드들은 code…","fields":{"slug":"/OS(11)-Memory Allocation/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [11. Threads and Concurrency]","date":"December 04, 2023"}},"next":{"fields":{"slug":"/OS(10)-Swap space/"}},"previous":{"fields":{"slug":"/OS(12)-Locks/"}}},{"node":{"id":"e7a643ea-3297-52e9-9cef-f79a8a963286","excerpt":"현대의 많은 시스템들은 64bit 주소 체계를 사용하고 있는데, 여러 프로세스들이 동시에 실행되기에 16GB정도의 메모리는 매우 부족하다. 그렇지만 우리는 아무렇지 않게 여러 프로세스를 띄워놓고 사용하고 있다. 과연 운영체제는 어떻게 이런 물리 메모리의 공간 부족을 해결하고 가상화된 물리 메모리를 프로세스에게 제공할까? 오늘은 이러한 메모리 공간 부족을 극복하는 방법에 대하여 알아보자. Swap Space OS는 disk(HDD, SSD)를 이용한다! Process에서 활성화된 영역만 메모리에 남기고 필요없는 메모리 공간은  하여 보조 저장장치의 swap space에 저장한다.  swap space는 보조 저장장치에 존재하는 공간으로, 프로세스의 주소공간을 의미한다. 하지만 보조 저장장치는 속도가 매우 느리므로, 해당 공간에는 사용되지 않지만 나중에 필요할 수 있는 Page를 메인 메모리로부터   한다. 이에 해당 Page가 필요한 경우에 다시 메인 메모리로  하여 사용한다. Sw…","fields":{"slug":"/OS(10)-Swap space/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [10. Demand Paging - Swap Space]","date":"November 24, 2023"}},"next":{"fields":{"slug":"/WEB-SPA/"}},"previous":{"fields":{"slug":"/OS(11)-Memory Allocation/"}}},{"node":{"id":"e08fbfa3-135f-57f0-8191-3c0897ac61ae","excerpt":"저번시간에는 메모리 가상화에서 Paging 기법에 대하여 배웠다. 고정된 크기의 Page로 주소 공간을 분할하고, 이를 물리 메모리의 남는 자리에 배치하여 가상 주소공간과 물리 주소공간을 Page Table을 통하여 매칭하는 방법이다. 하지만, page table은 기본적으로 memory 공간에 있으므로 시간적으로 느려져 주소를 전환하는 에 라는 캐시를 두어 하드웨어적으로 속도를 향상시킬 수 있는 방법이 제안되었다. 또한 page table 자체의 크기(+대부분은 invalid/unused 상태인채로 비어있음)도 무시할 수 없으므로 이를 줄일 수 있는 방법이 제안되었는데, 오늘은 그 방법에 대하여 다뤄보자. 1. Bigger Pages 가장 간단한 방법으로는 Page Frame 자체의 크기를 늘리는 방법이다. 이를 통해 Page Table Entry(PTE)의 갯수를 줄여 Page Table의 크기를 줄일 수 있을 것이다. 32bit address space에서, Page Fram…","fields":{"slug":"/OS(9-2)-Multilevel Page Table/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [9-2. Multi Level Page Table]","date":"November 01, 2023"}},"next":{"fields":{"slug":"/OS(9-1)-Paging/"}},"previous":{"fields":{"slug":"/WEB-SPA/"}}},{"node":{"id":"8869d9e9-0598-5a31-9918-2c90927ba1e3","excerpt":"오늘은  기술에 대하여 알아보자. 저번까지 우리는  방식으로 프로세스에게 메모리 가상화를 제공하고, 에서 virtual address(VA)를 physical address(PA)로 변환하는 과정에 대하여 공부했다. 하지만 연속된 공간으로 제공하는 방법은 internal fragment가 많이 발생하여 에 대하여도 알아보았다. segmentation은 가변 크기의 세그먼트로 나누는데, 이를 통해 내부 단편화는 줄일 수 있지만, 세그먼트의 크기가 제각각이므로 외부 단편화가 쉽게 발생할 것이라는 문제점이 존재한다. 이에 고정된 세그먼트들로 메모리 자원을 할당하는 Paging 기법이 제안된다. Paging memory address를 여러개의 (비교적 작은) 고정된 크기의 로 나누고, 이를 물리 메모리 공간에 매핑하는 방법이다. segmentation과의 차이점으로는 기능별로 나누는 것이 아닌 고정된 크기로 가상 주소를 page frame 단위로 나누고, 이를 물리 page frame에…","fields":{"slug":"/OS(9-1)-Paging/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [9-1. Paging]","date":"October 30, 2023"}},"next":{"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}},"previous":{"fields":{"slug":"/OS(9-2)-Multilevel Page Table/"}}},{"node":{"id":"dbf838fa-a84b-5baa-8fd9-b484a510bf52","excerpt":"MMU에서 Virtual Address에서 Physical Address로 변환되는 메커니즘을 간단한 함수의 실행과 함께 알아보자. 위의 함수가 실행되는 프로세스를 생각하면 OS는 아래와 같은 address space를 제공할 것이다. (프로세스마다 기본적으로 16KB만큼을 할당해준다고 가정하자)  x 변수는 stack영역에 저장되고, 컴파일된 명령어는 code 영역에 존재할 것이다. 이 과정에서 Address Translation이 어떤 식으로 이루어질지 생각해보자. Dynamic Relocation 이러한 주소의 배치는 프로세스 실행 이후에 address space가 변경될 수 있으니, dynamic relocation(동적 재배치)라고 불린다. base and bound (하드웨어 기반) 가장 단순한 방법으로는 위의 프로세스의 메모리 공간을 그대로 연속적인 하나의 물리적 공간에 매핑시키는 방법이 있을 것이다. 16KB가 연속적으로 남는 공간을 찾아서 그곳에 프로세스의 공간을 …","fields":{"slug":"/OS(8)-Mechanism of Address Translation/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [8. Mechanism of Address Translation]","date":"October 29, 2023"}},"next":{"fields":{"slug":"/OS(7)-Introduction to Virtual Memory/"}},"previous":{"fields":{"slug":"/OS(9-1)-Paging/"}}},{"node":{"id":"1c4f24f1-992b-5749-bee9-e2d91a87e79d","excerpt":"저번까지 Part1에 해당하는 Process와 CPU 가상화에 대하여 중점적으로 배웠다. OS는 process에게 독립성을 보장해주기 위하여 하나의 자원을 오롯이 제공하는 것처럼 느끼게 해주는데, 이번에는 그 중 메모리 자원에 대한 OS의 정책을 공부해보는 시간을 갖도록 하자. Why Virtual Memory? 당연히 현대의 컴퓨터는 하나의 메모리에 한 프로세스만을 제공하지 않는다. 전체 메모리 공간을 여러 프로세스들이 적절히 나눠서 사용하고 있는데, 한정된 메모리 공간을 적절하게 분배해야하며, 프로세스의 메모리 공간은 항상 연속적이지 않을 것이다. (왜냐면, 연속공간에 모든 프로세스들을 할당한다고 했을 때, 내부 단편화가 발생하여 메모리 공간을 효율적으로 사용하지 못할 수 있으므로) 하지만 운영체제의 메모리 가상화 덕분에, 개발자들은 파편화된 메모리 공간들을 관리하지 않고, 메모리를 연속되고 고정된 공간으로 간주할 수 있다! Abstraction : (Virtual) Addre…","fields":{"slug":"/OS(7)-Introduction to Virtual Memory/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [7. Introduction to Virtual Memory]","date":"October 28, 2023"}},"next":{"fields":{"slug":"/OS(6)-IPC/"}},"previous":{"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}}},{"node":{"id":"4816b4db-01ed-5807-a7d1-a04d66600126","excerpt":"저번까지 운영체제의 Scheduling에 대하여 알아보았다. 오늘은 프로세스간 통신에 대하여 알아보도록 하자. Inter Process Communication(IPC) 일반적으로 프로세스들은 독립적인 메모리 공간(memory space)를 갖고 있으므로, 메모리를 공유하지 않는다. 하지만, 프로세스간 communication이 필요한 경우가 많으며 서로 데이터를 공유할 상황도 생기므로, 이를 구현하기 위해 에 대하여 알 필요가 있다. Shared Memory 그 중 첫번째로 에 대하여 알아보자.  시스템 콜을 통하여 프로세스들은 같은 영역의 공유 메모리 자원에 접근할 수 있다. int shmget(key_t key, int size, int shmflg) 여러 프로세스에서 같은 key를 통하여 같은 shared memory영역에 접근할 수 있게 된다 해당 시스템 콜을 통하여 다수의 프로세스는 공유된 메모리 자원에 접근하여 read/write 연산을 수행할 수 있다. 하지만, 주의…","fields":{"slug":"/OS(6)-IPC/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [6. Inter Process Communication(IPC)]","date":"October 28, 2023"}},"next":{"fields":{"slug":"/WEB-jwt(3)/"}},"previous":{"fields":{"slug":"/OS(7)-Introduction to Virtual Memory/"}}},{"node":{"id":"673fdb45-03b2-5faa-82e9-8bda9f41a585","excerpt":"저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지()에 대하여 공부해보았다. 오늘은 scheduling을 할 때 순서를 결정짓는  에 대하여 공부해보도록 하자. 란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다. 오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다. Scheduling의 목표 우선 CPU burst time에 대하여 알 필요가 있다. CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간 만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임 scheduling의 목표는 다음과 같다. Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다 Minimize average  : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화 Minimize …","fields":{"slug":"/OS(5) - Scheduling Policy/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [5. Scheduling Policies]","date":"July 26, 2023"}},"next":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}},"previous":{"fields":{"slug":"/Alg-LC-26/"}}},{"node":{"id":"f8a99189-165d-5bbd-9e80-a64a0c519a84","excerpt":"이번에는 실제 프로세스가 실행되는 과정을 운영체제의 역할에 초점을 맞추어 공부해보도록 하자. Process Execution (Direct Execution) Process를 실행할 때 단순한 운영체제가 하는 일들을 순서대로 알아보자. 간단하게 하나의 CPU에서 하나의 Process가 실행된다고 가정하자. OS는 메모리를 할당하고 memory image를 만든다. 메모리 이미지는 저번에도 언급했듯 code, data, stack, heap 영역을 포함한다. CPU의 Program Counter, 그리고 기타 레지스터(Stack Pointer)들이 초기화된다. 위의 세팅 과정이 끝나고, Process는 CPU를 점유하고 명령어들을 실행하게 된다 (명령어 실행 과정에서 OS는 개입하지 않음) 일반 함수의 실행 과정 예를 들어, 어떠한 함수를 실행한다고 하자. 함수 실행시, 메모리에서는 함수의 내용이 존재하는 위치로 하게 된다. 이때, 함수 종료 이후의 실행을 위해 기존의 메모리 위치(…","fields":{"slug":"/OS(4)-Process Execution Mechanisms/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [4. Process Execution Mechanisms]","date":"July 16, 2023"}},"next":{"fields":{"slug":"/OS(3)- Process API/"}},"previous":{"fields":{"slug":"/OS(5) - Scheduling Policy/"}}},{"node":{"id":"2c803dde-8b03-5489-ae45-f640fcdf8b24","excerpt":"OS는 이라는 함수들로 Process를 생성/제어할 수 있는 API(Application Programming Interface)를 제공한다. 시스템 콜을 통하여 우리는 하드웨어에 대한 권한을 일부 부여받을 수 있게 된다. System call OS에서 에 들어왔을 때 사용할 수 있는 함수. 즉, system call은 일반 함수와 다른 높은 권한을 갖는 함수라고 볼 수 있다. H/W에 직접 접근하는 등의 민감한 작업들은 오직 에서만 가능하므로 system call을 사용해야 한다. IO 작업과 같은해주는 system call들은 process를 blocked상태로 descheduled 시키게 될 것이다. 즉, 하드웨어의 동작에 긴밀하게 연관되어 있다고 볼 수 있다. Should we rewrite programs for each OS? 시스템 콜은 운영체제마다 조금씩 다르다. 하지만, 거의 모든 현대의 운영체제는 라는 시스템 콜의 표준이 존재하므로, OS마다 다른 프로그램을 작성…","fields":{"slug":"/OS(3)- Process API/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [3. Process API]","date":"July 15, 2023"}},"next":{"fields":{"slug":"/OS(2)-Process/"}},"previous":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}}},{"node":{"id":"ef679d0a-8051-5f57-a48b-1868cb4bba1b","excerpt":"Process Process는 실행중인 프로그램(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 을 해서, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 부터, 고수준의 scheduling과 같은 까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까? 프로세스 표현하기(Process Abstraction) 프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태()를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다. PID (프로세스를 구분하기 위해 프로세…","fields":{"slug":"/OS(2)-Process/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [2. Process Abstraction]","date":"June 28, 2023"}},"next":{"fields":{"slug":"/OS(1)-computer-architecture/"}},"previous":{"fields":{"slug":"/OS(3)- Process API/"}}},{"node":{"id":"84137e27-ee51-5a2b-8271-d1e61c57eda6","excerpt":"운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자! Von Neumann Architecture 폰 노이만 구조 컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 로부터 fetch, decode, execute, writeback의 과정을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 에 올라가(load)있어야하며, CPU는  레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다. 이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 실행하기 위해서는 메모리에 로드가 되어야 한다는 것을 알 필요가 있다. CPU Cent…","fields":{"slug":"/OS(1)-computer-architecture/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [1. 컴퓨터 구조 skim]","date":"June 27, 2023"}},"next":{"fields":{"slug":"/OS(0)-intro/"}},"previous":{"fields":{"slug":"/OS(2)-Process/"}}},{"node":{"id":"2417c2da-54ea-589c-8580-8f3be2b8e4b0","excerpt":"운영체제란? OS Operating System 운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..! 운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어이다. 운영체제는 자원을 어떻게 관리하고 보호할까? OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 직접 접근할 수 없도록 한다. 이러한 자원에 접근할 수 있는 를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 (가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다. 자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 …","fields":{"slug":"/OS(0)-intro/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [0. 운영체제의 개요]","date":"June 26, 2023"}},"next":{"fields":{"slug":"/Django(12)- nested model /"}},"previous":{"fields":{"slug":"/OS(1)-computer-architecture/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}