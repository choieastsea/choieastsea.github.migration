{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/OS",
    "result": {"pageContext":{"currentCategory":"OS","categories":["All","WEB","Alg","BE","OS","FE","블로그","ADsP"],"edges":[{"node":{"id":"673fdb45-03b2-5faa-82e9-8bda9f41a585","excerpt":"저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지()에 대하여 공부해보았다. 오늘은 scheduling을 할 때 순서를 결정짓는  에 대하여 공부해보도록 하자. 란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다. 오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다. Scheduling의 목표 우선 CPU burst time에 대하여 알 필요가 있다. CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간 만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임 scheduling의 목표는 다음과 같다. Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다 Minimize average  : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화 Minimize …","fields":{"slug":"/OS(5) - Scheduling Policy/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [5. Scheduling Policies]","date":"July 26, 2023"}},"next":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}},"previous":{"fields":{"slug":"/Alg-LC-27/"}}},{"node":{"id":"f8a99189-165d-5bbd-9e80-a64a0c519a84","excerpt":"이번에는 실제 프로세스가 실행되는 과정을 운영체제의 역할에 초점을 맞추어 공부해보도록 하자. Process Execution (Direct Execution) Process를 실행할 때 단순한 운영체제가 하는 일들을 순서대로 알아보자. 간단하게 하나의 CPU에서 하나의 Process가 실행된다고 가정하자. OS는 메모리를 할당하고 memory image를 만든다. 메모리 이미지는 저번에도 언급했듯 code, data, stack, heap 영역을 포함한다. CPU의 Program Counter, 그리고 기타 레지스터(Stack Pointer)들이 초기화된다. 위의 세팅 과정이 끝나고, Process는 CPU를 점유하고 명령어들을 실행하게 된다 (명령어 실행 과정에서 OS는 개입하지 않음) 일반 함수의 실행 과정 예를 들어, 어떠한 함수를 실행한다고 하자. 함수 실행시, 메모리에서는 함수의 내용이 존재하는 위치로 하게 된다. 이때, 함수 종료 이후의 실행을 위해 기존의 메모리 위치(…","fields":{"slug":"/OS(4)-Process Execution Mechanisms/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [4. Process Execution Mechanisms]","date":"July 16, 2023"}},"next":{"fields":{"slug":"/OS(3)- Process API/"}},"previous":{"fields":{"slug":"/OS(5) - Scheduling Policy/"}}},{"node":{"id":"2c803dde-8b03-5489-ae45-f640fcdf8b24","excerpt":"OS는 이라는 함수들로 Process를 생성/제어할 수 있는 API(Application Programming Interface)를 제공한다. 시스템 콜을 통하여 우리는 하드웨어에 대한 권한을 일부 부여받을 수 있게 된다. System call OS에서 에 들어왔을 때 사용할 수 있는 함수. 즉, system call은 일반 함수와 다른 높은 권한을 갖는 함수라고 볼 수 있다. H/W에 직접 접근하는 등의 민감한 작업들은 오직 에서만 가능하므로 system call을 사용해야 한다. IO 작업과 같은해주는 system call들은 process를 blocked상태로 descheduled 시키게 될 것이다. 즉, 하드웨어의 동작에 긴밀하게 연관되어 있다고 볼 수 있다. Should we rewrite programs for each OS? 시스템 콜은 운영체제마다 조금씩 다르다. 하지만, 거의 모든 현대의 운영체제는 라는 시스템 콜의 표준이 존재하므로, OS마다 다른 프로그램을 작성…","fields":{"slug":"/OS(3)- Process API/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [3. Process API]","date":"July 15, 2023"}},"next":{"fields":{"slug":"/OS(2)-Process/"}},"previous":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}}},{"node":{"id":"ef679d0a-8051-5f57-a48b-1868cb4bba1b","excerpt":"Process Process는 실행중인 프로그램(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 을 해서, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 부터, 고수준의 scheduling과 같은 까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까? 프로세스 표현하기(Process Abstraction) 프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태()를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다. PID (프로세스를 구분하기 위해 프로세…","fields":{"slug":"/OS(2)-Process/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [2. Process Abstraction]","date":"June 28, 2023"}},"next":{"fields":{"slug":"/OS(1)-computer-architecture/"}},"previous":{"fields":{"slug":"/OS(3)- Process API/"}}},{"node":{"id":"84137e27-ee51-5a2b-8271-d1e61c57eda6","excerpt":"운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자! Von Neumann Architecture 폰 노이만 구조 컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 로부터 fetch, decode, execute, writeback의 과정을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 에 올라가(load)있어야하며, CPU는  레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다. 이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 실행하기 위해서는 메모리에 로드가 되어야 한다는 것을 알 필요가 있다. CPU Cent…","fields":{"slug":"/OS(1)-computer-architecture/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [1. 컴퓨터 구조 skim]","date":"June 27, 2023"}},"next":{"fields":{"slug":"/OS(0)-intro/"}},"previous":{"fields":{"slug":"/OS(2)-Process/"}}},{"node":{"id":"2417c2da-54ea-589c-8580-8f3be2b8e4b0","excerpt":"운영체제란? OS Operating System 운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..! 운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어이다. 운영체제는 자원을 어떻게 관리하고 보호할까? OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 직접 접근할 수 없도록 한다. 이러한 자원에 접근할 수 있는 를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 (가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다. 자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 …","fields":{"slug":"/OS(0)-intro/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [0. 운영체제의 개요]","date":"June 26, 2023"}},"next":{"fields":{"slug":"/Django(12)- nested model /"}},"previous":{"fields":{"slug":"/OS(1)-computer-architecture/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}