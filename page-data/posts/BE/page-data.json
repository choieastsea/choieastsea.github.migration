{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/BE",
    "result": {"pageContext":{"currentCategory":"BE","categories":["All","FE","WEB","블로그","Alg","BE","ADsP","Algorithms"],"edges":[{"node":{"id":"547ad7ca-81ab-59f0-8b59-28fabce02cf6","excerpt":"이전까지 장고와 리액트 서버를 연결해보았고, 이때 생길 수 있는 문제인 CORS 정책을 해결하는 것까지 알아보았다. 오늘은 간단하게 장고에서 지원하는 사용자 모델에 대하여 알아보고, 회원가입과 로그인/로그아웃 등의 기능을 구현해보자. 장고에서 제공하는 User Model 장고에서는 사용자와 관련한 많은 기능들이 포함된 User Model class가 기본적으로 제공된다. 공식문서 settings.py에서 User관련한 것들을 추가하지 않고 migration을 진행하였다면 DB에 auth_~로 시작하는 테이블이 만들어져있을 것이다. 하지만, 여기서 제공하는 user의 필드는 id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined 정도이다. 로그인은 username과 password를 기반으로 이루어지며, is_active한 사용자만 aut…","fields":{"slug":"/Django(8)-User Model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [8-django user model (1 to 1)]","date":"April 23, 2022"}},"next":{"fields":{"slug":"/Django(7)-Search&CORS/"}},"previous":{"fields":{"slug":"/FE-input-custom-hook-ts/"}}},{"node":{"id":"2216b6bb-30a6-5f7e-8c55-546e561f0708","excerpt":"이전까지 DRF의 CBV를 어떻게 구현하는지 알아보았다. ModelViewSet이 가장 간단하게 구현이 가능했는데, 이를 기반으로 검색기능을 만들어보자. Item 모델의 이름(name)에 해당 검색어가 포함되는지를 판단하여 리턴하는 api를 기존 ModelViewSet에다가 만들어보려고 한다. 그리고 가능하다면 실제 브라우저와 연결해보도록 하자!! 요구사항 [GET] localhost:8000/item/search?name=I I를 포함한 name을 갖는 item list를 리턴하도록 우선, 앞으로는 ModelViewSet으로만 처리하기 위해 items/urls.py를 간단하게 해주었다. ModelViewSet 클래스 수정  오버라이딩 ModelViewSet에서는 질의가 들어왔을 때, 내부적으로 함수를 사용한다. 따라서 이를 오버라이딩하여 쿼리 문자열을 처리할 수 있다. 쿼리 문자열은 으로 접근할 수 있다. Django ORM에서 를 하면 해당 문자열(대소문자 구분 없이)이 포함되…","fields":{"slug":"/Django(7)-Search&CORS/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [7-Search, 브라우저와 연결하기]","date":"April 16, 2022"}},"next":{"fields":{"slug":"/Django(6)-request-response/"}},"previous":{"fields":{"slug":"/Django(8)-User Model/"}}},{"node":{"id":"14ee35cd-9837-5380-8e94-1042bcaa938f","excerpt":"저번까지는 DRF의 serailizer에 대하여 공부하였고, 새로운 item을 만드는 api까지 간단하게 만들어보았다. 오늘은 좀 더 다양한 method에 대하여 알아보고, DRF(Django Rest Framework)의 을 도입하여 rest api에 최적화된 간단한 view구조를 설계해보도록 한다. 다양한 request에 대한 response 장고에서는 request와 response를 이렇게 처리한다. 장고에서는 요청을 HttpRequest객체에서 처리하도록 하고, 응답은 HttpResponse객체에서 처리하도록 한다. 이렇게 요청에 대하여 함수에서 처리하도록 하는 것을 라고 하며, 뷰 클래스에서 처리하도록 하는  역시 존재한다. in drf DRF에서도 request와 response를 받는 방법을 CBV,FBV로 나눠볼 수 있다. 우리가 저번에  데코레이터를 이용해 처리한 방법이 FBV이며, 오늘은 CBV에 대하여 알아보자. 가장 기본적인  클래스를 상속하여 뷰 클래스를 …","fields":{"slug":"/Django(6)-request-response/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [6-DRF CBV(APIView부터 ViewSet까지)]","date":"April 15, 2022"}},"next":{"fields":{"slug":"/Django(4)-migration/"}},"previous":{"fields":{"slug":"/Django(7)-Search&CORS/"}}},{"node":{"id":"565611de-2914-5d4f-af5d-738fe5e83e69","excerpt":"저번에 item 을 정의하는 것까지 해보았다. 이를 우리의 MySQL server에 적용시켜보자! 해야할 일은 크게 3가지로 나뉜다. model 정의 / 수정 migration file 생성 DB에 적용(migrate) 이 흐름을 이해하는 것이 중요하며, 직접 해보도록 하자. migration file 생성 가상환경이 활성화 되어있는 상태에서 위의 명령어를 입력한다. 을 하면 해당 앱에 존재하는 모델의 변경사항 등을 위치에 저장해준다. (app_name이 없다면 전체 앱을 탐색) 실제 위의 명령어가 정상 수행되면  파일이 생성되었다는 메시지가 나오는데, 파일을 열어보면 다음과 같다. 이러한 파일을 직접 만들어서 관리할 수도 있지만, 장고의 manage.py는 버전별로 나누어 이에 대한 관리를 용이하게 해준다. migrate migration 파일은 아직까지 파이썬 코드단으로 변경사항 등을 기록한 것이고, 이를 DB에 진짜로 반영하기 위해서는 migrate를 수행해주면 된다. 위와 …","fields":{"slug":"/Django(4)-migration/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [4 - DB(migration)]","date":"April 14, 2022"}},"next":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}},"previous":{"fields":{"slug":"/Django(6)-request-response/"}}},{"node":{"id":"edcd3751-d5fc-5f9a-9826-0c0da687ecfa","excerpt":"저번까지는 model의 구조를 DB schema에 적용하는 migration을 알아보았다. 오늘은 데이터를 저장하고, 저장된 데이터를 가져와서 사용할 때 필요한 개념인 직렬화에 대하여 알아보자! 어렵지만 이해를 해야 다음으로 넘어갈 수 있으니 매우 중요하다고 볼 수 있다. DRF Serializer 장고에는 기본적으로 이라는 것이 있지만, 앞으로는 DRF(Django Rest Framework)에서 제공하는 를 사용할 예정이다. DRF를 사용하는 이유 REST api 서버를 구성하기 위해 초점이 맞춰진 기능들이 많음 장고보다 코드의 중복을 줄이는 몇가지 클래스들이 제공됨 우선 가상환경에 DRF를 설치해준다. 그리고, settings.py의 INSTALLED_APPS에서 를 추가해준다. 참고로, INSTALLED_APPS에는 pip로 설치해준 것도 추가해야할 경우가 있고, manage.py startapp 등으로 만든 appConfig의 name도 들어가야한다. (모든 pip 모듈을…","fields":{"slug":"/Django(5)-serailizer-django-orm/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [5-serializer와 Django ORM]","date":"April 14, 2022"}},"next":{"fields":{"slug":"/Django(3)-model/"}},"previous":{"fields":{"slug":"/Django(4)-migration/"}}},{"node":{"id":"e34e2492-ff4f-5260-be49-839350a0dc0e","excerpt":"장고 모델 저번에는 localhost:8000/item/ 를 브라우저에 입력하면 응답하도록 하였다. 이번에는 item model을 정의하고, 이를 DB에 적용(migrate)시켜보자. django에서 제공하는 model은 우리가 다루는 데이터의 객체를 의미한다고 볼 수 있고, 하나의 모델 클래스는 관계형 DB에서의 한 table이라고 볼 수 있다. 우리 프로젝트에서 다루는 ”상품”을 정의해보자. item 모델 정의 field type(mysql) info item_id(pk) auto increment int 상품코드(1부터 증가) name varchar 상품명 price int(positive) 상품가격 stock_count int(positive) 현재 상품의 남은 수량 우선 간단하게 이정도만 정의해보도록 하자. 이러한 필드들은 언제든지 수정이 가능하며, 충돌이 생긴다면 이에 대한 해결책을 제시해주는 것도 장고의 장점이다! 위의 모델을 만들기 위해서는 item/models.py…","fields":{"slug":"/Django(3)-model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [3 - Django model]","date":"April 13, 2022"}},"next":{"fields":{"slug":"/Django(2)-django-intro/"}},"previous":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}}},{"node":{"id":"712a6369-c9cf-5e78-bf02-5ff42e5f5177","excerpt":"프로젝트를 시작하기에 앞서, 장고에 대하여 개략적으로 알아보고, 첫 장고 앱을 만들어보자! 장고란 장고는 간단하고 빠르게 웹 서비스를 구현할 수 있는 파이썬 기반의 웹 프레임워크이다. 다양하고 많은 기능들이 제공되지만, 우리는 프로젝트를 위한 기능들을 위주로 공부한다. 장고 서버가 http 요청에 대하여 응답을 하는 과정은 다음과 같다. urls.py (해당 app과 매핑) app의 어떤 기능을 사용할지 매핑 views.py 에서 로직의 결과를 리턴 장고 세팅 우선, 이 설치되어 있어야 한다. 프로젝트를 위한 디렉토리를 만들고, 아래와 같이 수행한다. 가상환경 만들기 다른 프로젝트들과 충돌이 나지 않게 해당 프로젝트를 위한 virtual environment가 구성되어야 한다. 가상환경에서 python library들을 설치하면 해당 환경에서만 유효한 독립적인 환경을 만들 수 있다. (참고로 깃으로 관리한다면 가상환경은 에다가 넣어놓는 것을 권장함) (guri-venv)로 시작하는…","fields":{"slug":"/Django(2)-django-intro/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [2-django 기초]","date":"April 12, 2022"}},"next":{"fields":{"slug":"/Django(0)-init/"}},"previous":{"fields":{"slug":"/Django(3)-model/"}}},{"node":{"id":"376d81e6-a8ee-5dcb-8dec-4337de0416a9","excerpt":"계기 방학동안 서비스를 운영하기 위해 api 서버로 장고를 사용하였다. 우리 서비스에서 장고를 사용한 가장 큰 이유는, 비스니스 로직에서 필요한 라이브러리가 파이썬에서만 사용가능했기 때문이다. 물론, 해당 역할을 별개의 서버로 분리하는 방법도 가능하지만, 장고는 복잡한 설정 없이 admin page를 구현할 수 있으므로 시간 단축에도 용이할 것 같아 선택하였다. 풀스택으로 단기간에 완성해야 하는 입장이였으므로 정리를 할 필요를 느껴, 장고를 다시 복기해보려고 한다. 또한, 장고에서 REST 서버를 위한 많은 클래스와 기능이 제공되는 DRF를 도입하여 많은 것들을 개선해보도록 하자. 간략한 소개 이 프로젝트에서는 간단한 회원제 쇼핑몰 페이지를 만들어보며 장고에 대하여 정리해보고자 한다. 서버는 api server로, 를 이용하여 구축할 예정이고, 프론트엔드는 로 간단하게 만들어볼 예정이다.! 서버 코드 링크 : https://github.com/choieastsea/market-gu…","fields":{"slug":"/Django(0)-init/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [0-시작]","date":"April 11, 2022"}},"next":{"fields":{"slug":"/Django(1)-overall/"}},"previous":{"fields":{"slug":"/Django(2)-django-intro/"}}},{"node":{"id":"c25f6b47-0620-527d-9513-e5ec469005fd","excerpt":"서비스 내용 이름은 마켓 구리! (좀 구리지만 이름을 붙혀놔야 기억을 잘하니까) 구독 상품과 일반 상품을 구매할 수 있는 마켓 웹서비스를 구축해보자. 판매자(관리자)가 물건을 등록하고, 사용자는 물건을 구매하거나 정기 구매를 하도록 한다. use case 아주 간단한 유즈케이스 다이어그램을 그려보았다. 비회원의 경우, 상품목록까지만 볼 수 있고, 회원이 되어야만 상품을 구매할 수 있도록 할 예정이다. 판매자는 상품을 등록하고 판매내역을 볼 수 있게 할 예정이며, 이는 관리자 페이지의 형식으로 제공할 예정이다. 서비스 구조 프론트엔드와 백엔드를 분리하여 개발/운영한다. 일단은 on-premise로 개발하고, 시간이 된다면 AWS와 같은 서비스에 올려 직접 배포해보자.  하나의 서버 컴퓨터라고 생각하고, nginx와 같은 웹서버를 두어 요청에 따라 front 또는 api 서버에 요청을 전달하고 이에 맞는 응답을 해주도록 구성하였다. 규모가 커질수록 역할에 따라 서버컴퓨터(혹은 클라우드…","fields":{"slug":"/Django(1)-overall/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [1-서비스 기획 및 설계]","date":"April 11, 2022"}},"next":{"fields":{"slug":"/ADsP-Review/"}},"previous":{"fields":{"slug":"/Django(0)-init/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}