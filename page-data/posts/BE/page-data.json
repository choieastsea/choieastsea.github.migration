{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/BE",
    "result": {"pageContext":{"currentCategory":"BE","categories":["All","OS","WEB","Alg","BE","FE","블로그","ADsP"],"edges":[{"node":{"id":"222f2675-aa22-52b5-b6a3-1e530a03e240","excerpt":"ORM ORM은 Object Relational Mapping의 약자. RDB의 테이블을 Object와 연결시켜 표현하고, SQL없이 해당 프레임워크의 언어로 데이터를 조작할 수 있도록 인터페이스 및 함수를 제공해준다. 이는 객체 지향 프로그래밍을 일관적으로 구성하는데 유용하다. 또한, 여러 DB에 대하여 라이브러리가 존재하므로, DB를 변경할 때 생기는 DB의 문법적인 변경사항 등을 고려하지 않을 수 있다. (이식성이 높다) n+1 문제 ORM을 사용하는 경우, 데이터에 접근하는 경우에 SQL 쿼리를 실행하게 된다. 프레임워크마다 SQL을 실행하는 시점은 조금씩 다른데, 기본적으로는 을 하게 될 것이다. 장고에서는, Pages.objects.all() 등을 실행하면 쿼리셋이 생성되는데, 이때는 DB에 접근하지 않는다. 쿼리셋 안의 데이터에 접근할 때, DB에 접근하게 된다. 이를 Lazy Loading(지연 로딩)이라고 한다. Lazy Loading과 반대되는 것은 Eager L…","fields":{"slug":"/BE-n+1/"},"frontmatter":{"categories":"BE","title":"(DB) n+1 문제와 해결책 (Django)","date":"September 14, 2023"}},"next":{"fields":{"slug":"/Alg-LC-909/"}},"previous":{"fields":{"slug":"/Alg-LC-75/"}}},{"node":{"id":"d29ae45e-a773-5de5-b305-65de5395c632","excerpt":"저번까지 Item 모델과 연관된 Question과 Answer 모델을 구현해보았다. 질문을 남긴 사람만 해당 질문을 변경할 수 있고, 답변은 관리자 페이지를 통해서만 달 수 있다. 오늘은 쇼핑몰의 핵심 기능인 사용자가 물건을 장바구니에 담고, 구매하는 기능을 구현해보도록 하자. 장바구니(Cart) 모델 만들기 장바구니에 대한 요구사항을 간단하게 정리해보자. 장바구니는 User model과 Item model을 으로 연결해주는 테이블이므로, 별도의 모델로 작성하도록 한다. 로 장바구니 앱을 만들자. 사용자 물건(item) & 물건의 현재 가격 수량 장바구니 추가/업데이트 시점(추가, 수정 등으로 7일 지나면 장바구니 삭제되도록 할 수 있을 것) 위의 요구사항을 에 구현해보자. 다음으로 장바구니에 대한 정보를 보여줄 때 필요한 serializer를 구현한다. serializer에서는 아래의 두가지 필드가 추가되면 좋을 것 같다. 총 금액 주문이 가능한지 여부(품절이 되면 주문이 불가능…","fields":{"slug":"/Django(12)- nested model /"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [12- nested model & serializer, 장바구니 모델 추가]","date":"June 16, 2023"}},"next":{"fields":{"slug":"/Django(11)- model advanced/"}},"previous":{"fields":{"slug":"/OS(0)-intro/"}}},{"node":{"id":"743c8dd2-f602-5a45-9e46-65b1f6265e9d","excerpt":"저번까지 Django User model과 이를 처리하는 SessionAuthentication에 대하여 알아보았다. 오늘은 “상품”에 해당하는 Item model을 구체적으로 구현해보고, 서비스를 위한 몇가지 모델을 추가로 만들어보자. 우선, 상품에 대하여 질문과 답변을 남길 수 있도록 Question 모델과 QNA 모델을 만들어주도록 한다. Model with ForeignKey 질문 모델에 대한 정의는 별도의 app을 만들어서 진행하였다. 질문에 대한 모델과 답변에 대한 모델이 존재하는데, 질문은 2개의 Foriegn key를 가져야 한다. 어떤 아이템에 대한 질문인지 (item) 누가 작성한 질문인지 (user) 로 정의한 필드들은 origin이 어디에 있는지, 참조하고 있는 데이터가 삭제되었을 때에 대한 정의를 해줄 수 있다. 추가적으로, 우리처럼 custom user model을 사용한 경우에는, 를 해주고, 로 가져와야 한다!! settings.py에서 AUTH_USE…","fields":{"slug":"/Django(11)- model advanced/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [11- 모델 구체화, 참조 모델 구현]","date":"May 12, 2023"}},"next":{"fields":{"slug":"/Django(10)-Signal and Permissions/"}},"previous":{"fields":{"slug":"/Django(12)- nested model /"}}},{"node":{"id":"55e8c2c3-78dc-5102-bb2b-c19c4883d54c","excerpt":"장고의 세션 기능은 생각보다 많은 기능들이 제공된다. Django Session DB 관리하기 세션 만료 기본적으로, 세션의 만료 시간이 정해져 있다. setttings.py에서 설정할 수 있는데, 몇가지 옵션들을 알아보자. SESSION_EXPIRE_AT_BROWSER_CLOSE (default : False) 브라우저가 종료될 때 세션이 만료되도록 하는 옵션 SESSION_COOKIE_AGE 위의 옵션이 False일 때, 세션의 유효 기간 (초 단위) SESSION_SAVE_EVERY_REQUEST (default : False) 요청이 올때, 세션의 유효기간을 갱신할 지 여부 중복 로그인 방지 장고에서는 로그인 시,  signal이 발생하게 된다. 이는 비동기/GUI 프로그래밍의 event와 비슷한 것으로, eventHandler(listener)를 달아주는 것처럼 장고에서는 를 달아주면 된다! signals은 장고에서 제공하는 몇가지가 있고, 커스텀으로도 특정 시그널을 만들…","fields":{"slug":"/Django(10)-Signal and Permissions/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [10- 세션 기능 추가 + DRF permissions]","date":"May 03, 2023"}},"next":{"fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"}},"previous":{"fields":{"slug":"/Django(11)- model advanced/"}}},{"node":{"id":"9faef788-f40a-5db0-97c2-24efd7802c83","excerpt":"저번까지 User model을 1:1 매핑하여 Profile model을 만들어서 usermodel을 커스텀 하는 방법으로 구현해보았다. 하지만, 쓸모 없이 복잡한 부분들도 많고 이는 그렇게 권장되는 방향이 아닐 것이다. 따라서, 장고에서 제공하는 User model의 상위 클래스인 를 이용하여 사용자 모델을 커스텀하는 방법으로 전환해보자..! 힘들겠지만, 지금이라도 바꿔야 좋을 것이다. Abstract User Model 우선, 우리는 이미 기존 user model을 마이그레이트해서 사용한 적이 있으므로, 이를 지워줄 필요가 있다. 우선, migration파일 내용을 지워준다. DB에서  를 실행해준다. myuser/models.py에 Profile class를 없애주고, 다음을 추가한다. settings.py에서 기본 사용자 객체를 우리가 정한 User로 바꿔준다. 다시 migration을 진행해준다. 해당 커밋은 여기를 참고한다. 다시 로 새로운 관리자 계정을 만들고 들어가보…","fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [9-django user model (AbstractUser & SessionAuthentication in DRF)]","date":"April 28, 2023"}},"next":{"fields":{"slug":"/Django(8)-User Model/"}},"previous":{"fields":{"slug":"/Django(10)-Signal and Permissions/"}}},{"node":{"id":"547ad7ca-81ab-59f0-8b59-28fabce02cf6","excerpt":"이전까지 장고와 리액트 서버를 연결해보았고, 이때 생길 수 있는 문제인 CORS 정책을 해결하는 것까지 알아보았다. 오늘은 간단하게 장고에서 지원하는 사용자 모델에 대하여 알아보고, 회원가입과 로그인/로그아웃 등의 기능을 구현해보자. 장고에서 제공하는 User Model 장고에서는 사용자와 관련한 많은 기능들이 포함된 User Model class가 기본적으로 제공된다. 공식문서 settings.py에서 User관련한 것들을 추가하지 않고 migration을 진행하였다면 DB에 auth_~로 시작하는 테이블이 만들어져있을 것이다. 하지만, 여기서 제공하는 user의 필드는 id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined 정도이다. 로그인은 username과 password를 기반으로 이루어지며, is_active한 사용자만 aut…","fields":{"slug":"/Django(8)-User Model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [8-django user model (1 to 1)]","date":"April 23, 2023"}},"next":{"fields":{"slug":"/Django(7)-Search&CORS/"}},"previous":{"fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"}}},{"node":{"id":"2216b6bb-30a6-5f7e-8c55-546e561f0708","excerpt":"이전까지 DRF의 CBV를 어떻게 구현하는지 알아보았다. ModelViewSet이 가장 간단하게 구현이 가능했는데, 이를 기반으로 검색기능을 만들어보자. Item 모델의 이름(name)에 해당 검색어가 포함되는지를 판단하여 리턴하는 api를 기존 ModelViewSet에다가 만들어보려고 한다. 그리고 가능하다면 실제 브라우저와 연결해보도록 하자!! 요구사항 [GET] localhost:8000/item/search?name=I I를 포함한 name을 갖는 item list를 리턴하도록 우선, 앞으로는 ModelViewSet으로만 처리하기 위해 items/urls.py를 간단하게 해주었다. ModelViewSet 클래스 수정  오버라이딩 ModelViewSet에서는 질의가 들어왔을 때, 내부적으로 함수를 사용한다. 따라서 이를 오버라이딩하여 쿼리 문자열을 처리할 수 있다. 쿼리 문자열은 으로 접근할 수 있다. Django ORM에서 를 하면 해당 문자열(대소문자 구분 없이)이 포함되…","fields":{"slug":"/Django(7)-Search&CORS/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [7-Search, 브라우저와 연결하기]","date":"April 16, 2023"}},"next":{"fields":{"slug":"/Django(6)-request-response/"}},"previous":{"fields":{"slug":"/Django(8)-User Model/"}}},{"node":{"id":"14ee35cd-9837-5380-8e94-1042bcaa938f","excerpt":"저번까지는 DRF의 serailizer에 대하여 공부하였고, 새로운 item을 만드는 api까지 간단하게 만들어보았다. 오늘은 좀 더 다양한 method에 대하여 알아보고, DRF(Django Rest Framework)의 을 도입하여 rest api에 최적화된 간단한 view구조를 설계해보도록 한다. 다양한 request에 대한 response 장고에서는 request와 response를 이렇게 처리한다. 장고에서는 요청을 HttpRequest객체에서 처리하도록 하고, 응답은 HttpResponse객체에서 처리하도록 한다. 이렇게 요청에 대하여 함수에서 처리하도록 하는 것을 라고 하며, 뷰 클래스에서 처리하도록 하는  역시 존재한다. in drf DRF에서도 request와 response를 받는 방법을 CBV,FBV로 나눠볼 수 있다. 우리가 저번에  데코레이터를 이용해 처리한 방법이 FBV이며, 오늘은 CBV에 대하여 알아보자. 가장 기본적인  클래스를 상속하여 뷰 클래스를 …","fields":{"slug":"/Django(6)-request-response/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [6-DRF CBV(APIView부터 ViewSet까지)]","date":"April 15, 2023"}},"next":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}},"previous":{"fields":{"slug":"/Django(7)-Search&CORS/"}}},{"node":{"id":"edcd3751-d5fc-5f9a-9826-0c0da687ecfa","excerpt":"저번까지는 model의 구조를 DB schema에 적용하는 migration을 알아보았다. 오늘은 데이터를 저장하고, 저장된 데이터를 가져와서 사용할 때 필요한 개념인 직렬화에 대하여 알아보자! 어렵지만 이해를 해야 다음으로 넘어갈 수 있으니 매우 중요하다고 볼 수 있다. DRF Serializer 장고에는 기본적으로 이라는 것이 있지만, 앞으로는 DRF(Django Rest Framework)에서 제공하는 를 사용할 예정이다. DRF를 사용하는 이유 REST api 서버를 구성하기 위해 초점이 맞춰진 기능들이 많음 장고보다 코드의 중복을 줄이는 몇가지 클래스들이 제공됨 우선 가상환경에 DRF를 설치해준다. 그리고, settings.py의 INSTALLED_APPS에서 를 추가해준다. 참고로, INSTALLED_APPS에는 pip로 설치해준 것도 추가해야할 경우가 있고, manage.py startapp 등으로 만든 appConfig의 name도 들어가야한다. (모든 pip 모듈을…","fields":{"slug":"/Django(5)-serailizer-django-orm/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [5-serializer와 Django ORM]","date":"April 14, 2023"}},"next":{"fields":{"slug":"/Django(4)-migration/"}},"previous":{"fields":{"slug":"/Django(6)-request-response/"}}},{"node":{"id":"565611de-2914-5d4f-af5d-738fe5e83e69","excerpt":"저번에 item 을 정의하는 것까지 해보았다. 이를 우리의 MySQL server에 적용시켜보자! 해야할 일은 크게 3가지로 나뉜다. model 정의 / 수정 migration file 생성 DB에 적용(migrate) 이 흐름을 이해하는 것이 중요하며, 직접 해보도록 하자. migration file 생성 가상환경이 활성화 되어있는 상태에서 위의 명령어를 입력한다. 을 하면 해당 앱에 존재하는 모델의 변경사항 등을 위치에 저장해준다. (app_name이 없다면 전체 앱을 탐색) 실제 위의 명령어가 정상 수행되면  파일이 생성되었다는 메시지가 나오는데, 파일을 열어보면 다음과 같다. 이러한 파일을 직접 만들어서 관리할 수도 있지만, 장고의 manage.py는 버전별로 나누어 이에 대한 관리를 용이하게 해준다. migrate migration 파일은 아직까지 파이썬 코드단으로 변경사항 등을 기록한 것이고, 이를 DB에 진짜로 반영하기 위해서는 migrate를 수행해주면 된다. 위와 …","fields":{"slug":"/Django(4)-migration/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [4 - DB(migration)]","date":"April 14, 2023"}},"next":{"fields":{"slug":"/Django(3)-model/"}},"previous":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}}},{"node":{"id":"e34e2492-ff4f-5260-be49-839350a0dc0e","excerpt":"장고 모델 저번에는 localhost:8000/item/ 를 브라우저에 입력하면 응답하도록 하였다. 이번에는 item model을 정의하고, 이를 DB에 적용(migrate)시켜보자. django에서 제공하는 model은 우리가 다루는 데이터의 객체를 의미한다고 볼 수 있고, 하나의 모델 클래스는 관계형 DB에서의 한 table이라고 볼 수 있다. 우리 프로젝트에서 다루는 ”상품”을 정의해보자. item 모델 정의 field type(mysql) info item_id(pk) auto increment int 상품코드(1부터 증가) name varchar 상품명 price int(positive) 상품가격 stock_count int(positive) 현재 상품의 남은 수량 우선 간단하게 이정도만 정의해보도록 하자. 이러한 필드들은 언제든지 수정이 가능하며, 충돌이 생긴다면 이에 대한 해결책을 제시해주는 것도 장고의 장점이다! 위의 모델을 만들기 위해서는 item/models.py…","fields":{"slug":"/Django(3)-model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [3 - Django model]","date":"April 13, 2023"}},"next":{"fields":{"slug":"/Django(2)-django-intro/"}},"previous":{"fields":{"slug":"/Django(4)-migration/"}}},{"node":{"id":"712a6369-c9cf-5e78-bf02-5ff42e5f5177","excerpt":"프로젝트를 시작하기에 앞서, 장고에 대하여 개략적으로 알아보고, 첫 장고 앱을 만들어보자! 장고란 장고는 간단하고 빠르게 웹 서비스를 구현할 수 있는 파이썬 기반의 웹 프레임워크이다. 다양하고 많은 기능들이 제공되지만, 우리는 프로젝트를 위한 기능들을 위주로 공부한다. 장고 서버가 http 요청에 대하여 응답을 하는 과정은 다음과 같다. urls.py (해당 app과 매핑) app의 어떤 기능을 사용할지 매핑 views.py 에서 로직의 결과를 리턴 장고 세팅 우선, 이 설치되어 있어야 한다. 프로젝트를 위한 디렉토리를 만들고, 아래와 같이 수행한다. 가상환경 만들기 다른 프로젝트들과 충돌이 나지 않게 해당 프로젝트를 위한 virtual environment가 구성되어야 한다. 가상환경에서 python library들을 설치하면 해당 환경에서만 유효한 독립적인 환경을 만들 수 있다. (참고로 깃으로 관리한다면 가상환경은 에다가 넣어놓는 것을 권장함) (guri-venv)로 시작하는…","fields":{"slug":"/Django(2)-django-intro/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [2-django 기초]","date":"April 12, 2023"}},"next":{"fields":{"slug":"/Django(0)-init/"}},"previous":{"fields":{"slug":"/Django(3)-model/"}}},{"node":{"id":"376d81e6-a8ee-5dcb-8dec-4337de0416a9","excerpt":"계기 방학동안 서비스를 운영하기 위해 api 서버로 장고를 사용한 경험이 있다. 우리 서비스에서 장고를 사용한 가장 큰 이유는, 비스니스 로직에서 필요한 라이브러리가 파이썬에서만 사용가능했기 때문이다. 물론, 해당 역할을 별개의 서버로 분리하는 방법도 가능하지만, 장고는 복잡한 설정 없이 admin page를 구현할 수 있고 소수의 인원이 여러 언어를 이용하는 것이 불편하고, 시간 단축에도 용이할 것 같아 선택하였다. 풀스택으로 단기간에 완성해야 하는 입장이였으므로 정리를 할 필요를 느껴, 장고를 다시 복기해보려고 한다. 또한, 장고에서 RESTful한 서버를 위한 많은 클래스와 기능이 제공되는 를 도입하여 많은 것들을 개선해보도록 하자. 간략한 소개 이 프로젝트에서는 간단한 회원제 쇼핑몰 페이지를 만들어보며 장고에 대하여 정리해보고자 한다. 서버는 api server로, 를 이용하여 구축할 예정이고, 프론트엔드는 로 간단하게 만들어볼 예정이다.! 서버 코드 링크 : https:/…","fields":{"slug":"/Django(0)-init/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [0-시작]","date":"April 11, 2023"}},"next":{"fields":{"slug":"/Django(1)-overall/"}},"previous":{"fields":{"slug":"/Django(2)-django-intro/"}}},{"node":{"id":"c25f6b47-0620-527d-9513-e5ec469005fd","excerpt":"서비스 내용 이름은 마켓 구리! (좀 구리지만 이름을 붙혀놔야 기억을 잘하니까) 구독 상품과 일반 상품을 구매할 수 있는 마켓 웹서비스를 구축해보자. 판매자(관리자)가 물건을 등록하고, 사용자는 물건을 구매하거나 정기 구매를 하도록 한다. use case 아주 간단한 유즈케이스 다이어그램을 그려보았다. 비회원의 경우, 상품목록까지만 볼 수 있고, 회원이 되어야만 상품을 구매할 수 있도록 할 예정이다. 판매자는 상품을 등록하고 판매내역을 볼 수 있게 할 예정이며, 이는 관리자 페이지의 형식으로 제공할 예정이다. 서비스 구조 프론트엔드와 백엔드를 분리하여 개발/운영한다. 일단은 on-premise로 개발하고, 시간이 된다면 AWS와 같은 서비스에 올려 직접 배포해보자.  하나의 서버 컴퓨터라고 생각하고, nginx와 같은 웹서버를 두어 요청에 따라 front 또는 api 서버에 요청을 전달하고 이에 맞는 응답을 해주도록 구성하였다. 규모가 커질수록 역할에 따라 서버컴퓨터(혹은 클라우드…","fields":{"slug":"/Django(1)-overall/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [1-서비스 기획 및 설계]","date":"April 11, 2023"}},"next":{"fields":{"slug":"/FE-React-VDOM/"}},"previous":{"fields":{"slug":"/Django(0)-init/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}