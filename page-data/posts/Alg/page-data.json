{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/Alg",
    "result": {"pageContext":{"currentCategory":"Alg","categories":["All","BE","Alg","WEB","OS","FE","블로그","ADsP"],"edges":[{"node":{"id":"b42ec5e0-aae0-562f-9b65-3158bbeffa0d","excerpt":"Intuition 뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. 링크 백준 16928과 거의 같은 문제이다. 뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다. Approach 방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다. 하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다. 아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다. Complexity Time complexity: O(n^2) 노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사…","fields":{"slug":"/Alg-LC-909/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 909. Snakes and Ladders","date":"September 14, 2023"}},"next":{"fields":{"slug":"/Alg-LC-133/"}},"previous":{"fields":{"slug":"/BE-n+1/"}}},{"node":{"id":"978ac032-18aa-54da-b2a7-1ec04a7419f7","excerpt":"Intuition graph가 주어졌을 때, 깊은 복사를 수행한 그래프의 사본을 리턴하는 문제이다. 링크 python에서는 원시 타입이 아닌 경우 참조형 객체에서 대입연산을 수행하는 경우 얕은 복사가 일어난다. 이는 원본 값이 바뀌면 사본 역시 바뀌게 되는 경우가 생기게 된다. 깊은 복사의 경우, 독립된 객체이므로 원본과 사본이 독립적이다. Approach 깊은 복사를 수행하는 방법은 크게 두가지가 있다. copy.deepcopy 함수를 이용 원본 값의 마지막 depth까지 그래프를 탐색하며 새로운 값을 만들기 그래프를 탐색하면서, 원본 노드의 값을 이용하여 새로운 노드를 만들고, 그래프의 연결관계를 초기화해주면 된다. 여기서 그래프를 탐색하는 방법에는 여러가지가 있는데 나의 경우 리스트로 간단하게 처리할 수 있는 DFS 탐색을 수행하였다. 그래프를 탐색하다보면 같은 값의 노드를 여러번 생성하게 될 수도 있는데, 이를 방지하기 위해 사본 그래프의 모든 노드를 저장하는 diction…","fields":{"slug":"/Alg-LC-133/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 133. Clone Graph","date":"September 14, 2023"}},"next":{"fields":{"slug":"/Alg-LC-127/"}},"previous":{"fields":{"slug":"/Alg-LC-909/"}}},{"node":{"id":"79adc579-2fb2-564c-8a24-62a4c576ade5","excerpt":"Intuition 단어에서 한 글자만 바뀐 단어로 바꿀 수 있을 때, 목표 단어까지 도달하는데 최소 얼마나 걸리는지를 구하는 문제이다. 링크 바뀐 단어 역시 주어진 wordList 안에 있어야하므로, search space를 탐색해야한다고 유추할 수 있다. 참고로, 입력되는 단어의 길이는 모두 같다고 가정한다. Approach search space에서 root node에서 정답 노드까지의 최단거리를 구해야하므로 를 떠올려볼 수 있다. 한 글자만 다른 단어로 해공간을 확장하는 것이 약간 어렵지만, 나의 경우 단순한 문자열 비교를 통하여 구현하였다. (그래서 그런지 너무 느리다) 단어마다 visited를 두어, 이미 방문했다면 에 넣지 않도록 하였고, 거리를 구하기 위하여 큐에 넣을 때, 를 넣어주도록 하였다. Complexity Time complexity: O(w*n^2) 단어의 길이가 w이고, 갯수가 n개일 때, w개의 글자들을 각각 비교하는 연산(w*n)이 단어마다 존재하므로…","fields":{"slug":"/Alg-LC-127/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 127. Word Ladder","date":"September 14, 2023"}},"next":{"fields":{"slug":"/progress-event/"}},"previous":{"fields":{"slug":"/Alg-LC-133/"}}},{"node":{"id":"8ab6fe9a-0b1a-5ff8-b900-b8bbe721f0d9","excerpt":"Intuition 저번에 구현한  자료구조를 이용하여 search함수를 구현하는 문제이다. 링크 search함수는 208번 문제와 다르게 ’.’가 포함될 수 있는데, 이는 모든 문자가 가능한 경우를 의미한다. 예를 들어, ‘dad’, ‘pad’, ‘mad’가 들어있는 트라이에서 는 3 단어를 모두 리턴할 것이다. Approach 트라이에 대한 구현은 208번에서 했으니, 이번에는 search함수에서 ’.’를 처리하는 부분에 중점 두어 해결해보자. 여러 방법이 존재하겠지만, ’.’의 경우에는 결국 해당 노드에서 가능한 모든 다음 노드로 각각 search를 수행해야 한다. 나는  자료구조를 이용하여 search 함수를 구현하였다. trie를 탐색하면서, 입력 문자열을 하나씩 matching하다가 ’.’를 만나면, 특정 노드가 아닌 모든 노드로 뻗어나가야 한다. 나는 이를 BFS의 구조와 유사하다고 판단하여 탐색할 노드들을 queue에 넣고, depth별로(문자별로) 모든 큐의 노드들을…","fields":{"slug":"/Alg-LC-211/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 211. Design Add and Search Words Data Structure","date":"September 11, 2023"}},"next":{"fields":{"slug":"/Alg-LC-208/"}},"previous":{"fields":{"slug":"/progress-event/"}}},{"node":{"id":"a9e59f51-8a31-5d15-af62-f704e38b40a4","excerpt":"Intuition Trie 자료구조를 직접 구현해보는 문제이다. 링크 요구되는 메서드로는 해당 단어가 존재하는지 찾는 , prefix로 시작하는 단어가 존재하는지 찾는 가 있다. Approach 트라이(Trie)는 여러 문자열을 트리구조로 저장하는 자료구조로, root(head)에서부터 한 문자씩 이어나가면 된다. 단어의 마지막 문자에는 끝났는지 여부를 기록한다. 예를 들어, ‘dad’를 저장하면,와 같이 저장하면 된다. 이를 위해 python에서는  자료형을 이용하는 것이 가장 간편하다. key에 문자를 넣고, value에는 다음 node인 dictionary를 넣으면 된다. Trie의 장점은 여러 문자열이 저장되어 있을 때, 한 문자열을 찾는 속도가 빠르며 특히 prefix가 같은 문자열을 찾는데 의 시간이 걸리므로 좋다. 예를 들어, prefix가 같은 문자열을 Trie로 표현해보자. 위는 dad, daddy, dart의 세 단어를 저장한 Trie를 시각화한 예시이다. 여기서…","fields":{"slug":"/Alg-LC-208/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 208. Implement Trie (Prefix Tree)","date":"September 11, 2023"}},"next":{"fields":{"slug":"/Alg-LC-215&373/"}},"previous":{"fields":{"slug":"/Alg-LC-211/"}}},{"node":{"id":"ddc7f7fe-0304-568c-8919-ca52755b1610","excerpt":"Intuition 배열에서 k번째로 큰 원소를 리턴하는 문제이다. 링크 매우 간단하지만, 여러 방법이 존재한다. Approach 가장 기본적으로 배열을 정렬한 후, k번째 원소를 리턴하면 된다. 하지만, 문제에서 이를 정렬없이 해결할 방법을 물어봤는데, 이는  자료구조를 이용하면 될 것이다. python의 는 기본적으로 min-heap이므로, 큰 것을 남기기 위해서는 작은 것들을 빼주면 될 것이다. Complexity Time complexity: O(nlogk) 정렬의 경우 nlogn이 걸릴 것이다. heap을 이용하더라도 push하는데 log(n), pop하는데 log(n)이 걸리므로, 평균적으로 nlog(k)이 걸린다고 볼 수 있다. n과 k중에서 n이 더 크지만, 배열의 형태에 따라 시간이 달라질 수 있다. Space complexity: O(k) heap의 크기를 k개로 유지시킨다면 정렬에 비하여 공간복잡도를 줄일 수 있을 것이다. Code 처음 방법은 단순하게 정렬하여 …","fields":{"slug":"/Alg-LC-215&373/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 215. Kth Largest Element in an Array, 373. Find K Pairs with Smallest Sums","date":"September 11, 2023"}},"next":{"fields":{"slug":"/Alg-LC-530/"}},"previous":{"fields":{"slug":"/Alg-LC-208/"}}},{"node":{"id":"1b983a40-3c79-583e-87f1-9093beae7e0b","excerpt":"Intuition Binary Search Tree(BST)에서 두 노드의 차이가 최소가 되도록 하는 값을 찾는 문제이다. 링크 두 노드간 차이는 양수이며, 자식-부모관계가 아니여도 된다. 그리고 각각의 노드는 모두 다른 값을 갖는다. Approach 기본적으로 Brute Force로 생각해보면, 트리를 순회하면서 한 노드를 고르고 그것과 차이가 가장 작은 노드를 찾으면 될 것이다. 하지만, 이는 시간이 오래걸리므로, 재귀적으로 문제를 해결해보자. BST이므로 특징을 떠올려볼 수 있는데, 한 노드를 root로 하는 subtree에서 root와의 최소 차이를 갖는 값은 둘 중 하나이다. 오른쪽 자식의 맨 왼쪽 leaf(오른쪽 자식을 root로 하는 subtree에서 가장 작은 값) 왼쪽 자식의 맨 오른쪽 leaf(왼쪽 자식을 root로 하는 subtree에서 가장 큰 값) 그리고, 차이가 가장 적은 두 노드를 찾을 때, 두 노드의 관계는 조상~손자의 관계일 것이다. 왜냐하면 sibl…","fields":{"slug":"/Alg-LC-530/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 530. Minimum Absolute Difference in BST","date":"September 07, 2023"}},"next":{"fields":{"slug":"/Alg-LC-230/"}},"previous":{"fields":{"slug":"/Alg-LC-215&373/"}}},{"node":{"id":"77f7754e-455a-5da3-8f07-a2054063c837","excerpt":"Intuition Binary Search Tree(BST)에서 k번째로 작은 원소를 찾는 문제이다. 링크 각각의 노드는 다른 값을 갖고, 가장 작은 원소는 1번째로 작다고 한다. Approach BST를 직접 그려보고, 정렬된 값을 추출하는 과정을 생각해보면 몇가지 특징이 존재한다. 한 노드를 루트로 하는 서브트리에서 가장 큰 값은, 가장 오른쪽에 있고 가장 작은 값은 왼쪽에 있다. 왼쪽 자식의 어떠한 값도 자기자신보다는 작고, 오른쪽 자식의 어떠한 값도 자기 자신보다는 크다! 따라서, 의 순서로 순회하는  traverse를 수행하면 BST는 정렬된 순서로 나오게 될 것이다! 이는 재귀적으로 해결하거나, stack을 이용한 while문으로도 해결할 수 있으나 후자의 방법이 더 좋다. (단순히 출력하는 거라면 상관없지만, 갯수를 세서 중간에 리턴해야하는데, 재귀는 이것이 어렵다) Complexity Time complexity: O(n) 각 노드를 한번씩 탐색하므로 O(n)정도 걸…","fields":{"slug":"/Alg-LC-230/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 230. Kth Smallest Element in a BST","date":"September 07, 2023"}},"next":{"fields":{"slug":"/Alg-LC-199&637/"}},"previous":{"fields":{"slug":"/Alg-LC-530/"}}},{"node":{"id":"8614b553-d529-54be-9f6b-3531b1d8847d","excerpt":"Intuition Binary Tree에서 각 레벨 별로, 가장 오른쪽의 원소를 출력하는 문제이다. 링크 문제에서는 오른쪽에 서서 봤을 때, 제일 앞에 보이는 노드를 출력하라고 하였다. Approach 단순하게 depth를 추가한 BFS로 문제를 해결할 수 있다. 각 depth마다 값을 저장하면서, BFS로 왼쪽부터 값을 탐색한다면 가장 오른쪽 값이 마지막에 저장될 것이다. Complexity Time complexity: O(n) 각 노드를 한번씩 탐색하므로 O(n)정도 걸릴 것이다. Space complexity: O(n) stack에 노드를 넣고 빼므로 트리가 커질수록 스택의 크기가 커질 것이다. Code BFS는 FIFO를 이용해야하므로, python deque를 이용하였다. result 배열을 만들어서 값을 넣는데, 단순하게 값이 없다면 새로 만들어주고 아니라면 덮어씌우는 것이다. Intuition Binary Tree에서 각 레벨 별로 원소의 값의 평균을 구하는 문제이다…","fields":{"slug":"/Alg-LC-199&637/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 199. Binary Tree Right Side View, 637. Average of Levels in Binary Tree","date":"September 07, 2023"}},"next":{"fields":{"slug":"/Alg-LC-162/"}},"previous":{"fields":{"slug":"/Alg-LC-230/"}}},{"node":{"id":"3d8199f8-c0b6-5d78-8105-5a9a62409798","excerpt":"Intuition 배열에서 극댓값의 인덱스를 찾는 문제이다. 링크 주의해야할 점은, 연속된 인덱스의 값은 서로 다르고 양 끝은 음의 무한대라고 가정한다는 점이다. 이 조건이 문제를 빠르게 풀 수 있게 만들어준다. Approach 연속된 값이 서로 다르므로, 우리는 단순하게 3개만 비교하면 극댓값인지 아닌지 여부를 판단할 수 있다. 고원(plateau)이 존재하지 않고 양 끝은 가장 작은 수 이므로, 어떠한 인덱스에서 증가하고 있다면 오른쪽에 극대값이 존재할 것이며, 감소하고 있다면 왼쪽에 극값이 존재한다는 것을 알 수 있다. 계속 증가한다면 오른쪽 끝값이 극댓값일 것이고, 단조 감소하고 있는 경우에도 역시 왼쪽 끝이 극댓값일 것이다. Complexity Time complexity: O(log(n)) Space complexity: O(1) Code 처음에 배열의 크기가 1인 경우에는 단순하게 0을 리턴해주면 된다. 그리고 양끝값을 먼저 비교한 이후에 strt를 1부터, end를 …","fields":{"slug":"/Alg-LC-162/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 162. Find Peak Element","date":"September 04, 2023"}},"next":{"fields":{"slug":"/Alg-LC-148/"}},"previous":{"fields":{"slug":"/Alg-LC-199&637/"}}},{"node":{"id":"eb9647f7-9464-53b7-9445-3d46c9a20c0d","excerpt":"Intuition singly linked list를 sorting하는 문제이다. 링크 head가 인자로 들어왔을 때, 정렬된 링크드리스트로 바꿔준 head를 리턴한다. Approach sol1 LinkedList를 python list로 바꿔준 후, list sort를 진행해주었다. python sort는 최적화가 잘 되어있어 우리가 직접 구현하는 것보다 속도가 훨씬 빠르다..! 이를 위해 를 가리키는  배열을 만들어주고, pointList의 값을 기준으로 정렬한 이후, head를 차례로 업데이트 해주었다. 문제에서 의도한 방향은 아니지만, 속도는 매우 빠르게 구현할 수 있을 것이다. 하지만, 추가적인 배열을 만들어야한다는 점에서 메모리가 더 많이 들 것이다. sol2 이 문제의 의도에 맞게 직접 sort를 구현해볼 수 있다. Complexity Time complexity: O(nlog(n)) Space complexity: O(n) Code solution1 으로만 일단 풀어…","fields":{"slug":"/Alg-LC-148/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 148. Sort List","date":"September 04, 2023"}},"next":{"fields":{"slug":"/Alg-LC-33/"}},"previous":{"fields":{"slug":"/Alg-LC-162/"}}},{"node":{"id":"2284ba99-84fe-5dbd-82f6-3e2e3a4eb03b","excerpt":"Intuition 정렬된 배열이 임의의 인덱스에서 rotate되어 있을 때, target의 위치를 찾는 문제이다. 링크 target이 없다면 -1을 리턴한다. Approach 정렬된 배열이 [1,2,3,4,5]라고 했을 때, rotate된 배열의 예시는 다음과 같다. 문제에서는 에 해결할 것을 주문하였으므로, 선형탐색이 아닌 다른 방법을 선택해야한다. 배열은 rotate된 위치를 중심으로 왼쪽 오른쪽 subarray가 모두 정렬된 상태임을 이용해볼 수 있다. 즉, 정렬된 구간에서는 binary search를 이용할 수 있으니 정렬된 구간을 찾아가는 식으로 문제를 해결해 볼 수 있을 것이다. 배열을 두 부분으로 나눈다. 왼쪽 혹은 오른쪽 부분은 항상 정렬되어 있을 것이다. (rotate는 한 곳에서 일어나므로) 정렬된 부분에서는 를 수행한다. 정렬되지 않은 부분은 다시 정렬된 부분을 찾기 위해 탐색 범위를 좁혀나간다. Complexity Time complexity: O(log(n)…","fields":{"slug":"/Alg-LC-33/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 33. Search in Rotated Sorted Array","date":"September 03, 2023"}},"next":{"fields":{"slug":"/Alg-LC-153/"}},"previous":{"fields":{"slug":"/Alg-LC-148/"}}},{"node":{"id":"5ebc27c9-9855-510a-afde-bb80c4c8b382","excerpt":"Intuition 정렬된 배열이 임의의 인덱스에서 rotate되어 있을 때, 최솟값의 위치를 찾는 문제이다. 링크 이는 33번과 매우 유사하지만, 좀 더 간단하다. Approach 33번과 유사하게, 배열의 범위를 보며 정렬된 구간을 줄여나가면 된다. 원소의 값이 모두 다르므로, 정렬된 구간이라면 첫번째 인덱스가 마지막 인덱스보다 작음을 이용할 수 있다. 나는 이라는 tuple을 선언하여 (인덱스, 현재까지의 최솟값)을 저장하여 비교하도록 하였다. Complexity Time complexity: O(log(n)) Space complexity: O(1) Code mid값을 우선적으로 current_min과 비교하고, 구간을 줄일 때에는 mid+1, mid-1을 넣어주어 범위를 log(n)으로 줄여나갈 수 있다.","fields":{"slug":"/Alg-LC-153/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 153. Find Minimum in Rotated Sorted Array","date":"September 03, 2023"}},"next":{"fields":{"slug":"/Alg-LC-383&242/"}},"previous":{"fields":{"slug":"/Alg-LC-33/"}}},{"node":{"id":"861f34c0-c233-5990-af4c-6d52e87d78e5","excerpt":"Intuition ransomNote에 사용된 문자들이 모두 magazine에 포함되는지를 판단하는 문제이다. 링크 예를 들어, ‘aa’는 ‘aba’에 포함되며, ‘ab’에 포함되지는 않는다. Approach python dict를 이용하여 갯수를 기록할 수 있지만, 간단하게 를 이용하여 구현할 수 있다. 파이썬 문서 링크 iterable한 것들의 갯수를 셀 때 Counter 클래스를 이용하는 장점이 몇가지가 있다. 중복된 것들의 갯수를 알아서 세준다. 만 해주면 된다. 만약 없다면 0을 반환한다. (dict의 경우 in 연산이 아닌 index접근의 경우 KeyError가 발생) 과 같이 최빈값을 뽑을때 간단하게 사용할 수 있다. 연산이 가능하다. 이를 통하여 차집합 연산을 수행할 수 있다. 이 문제는 4번째의 특성을 이용하여 아주 간단하게 해결할 수 있다. Complexity Time complexity: O(n) Counter 인스턴스를 초기화하는데 O(n)의 시간이 걸린다. …","fields":{"slug":"/Alg-LC-383&242/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 383. Ransom Note, 242. Valid Anagram","date":"August 30, 2023"}},"next":{"fields":{"slug":"/Alg-LC-1/"}},"previous":{"fields":{"slug":"/Alg-LC-153/"}}},{"node":{"id":"61493ac7-9107-5b2a-b8bd-433bac4e0549","excerpt":"Intuition 배열의 두 숫자의 합으로 target을 표현할 수 있을때, 그 위치를 반환하는 문제이다. 링크 Approach sol1 (Brute Force) 가장 간단하게 2중 loop를 돌며 nums[i] + nums[j] == target이 되는 지점을 탐색한다. sol2 (Hash Table) python dict를 이용하여 배열을 선형탐색한다. i번째 값이 num일 때, num을 dict에 넣어준다. 그리고, target-num이 dict에 있다면 그곳이 합이 target이 되는 지점이다. Complexity Time complexity: O(n) 배열을 선형탐색하면서 dict에 값이 있는지 여부를 확인하고 값을 업데이트하거나 넣어준다. dict의 경우 접근이 O(1)이기 때문이다. Space complexity: O(n) Code 간단하게 탐색하면 된다. j는 i보다 뒤에 있으면 된다. 최악의 경우 (n^2)/2 만큼 걸리지만 매우 느리다. 주의할 점은, 은 해당 k…","fields":{"slug":"/Alg-LC-1/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 1. Two Sum","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-155/"}},"previous":{"fields":{"slug":"/Alg-LC-383&242/"}}},{"node":{"id":"586e2d05-dd2f-5771-90db-35e8f2ac39fd","excerpt":"Intuition 값 이외에 최소값을 리턴할 수 있는 스택을 구현하는 문제이다. 링크 기본적으로, 스택은 LIFO(Last In First Out)이며 보통 배열로 구현하기 위해서는 가장 위를 가리키는 top pointer를 두고 구현할 수 있다. Approach 스택을 만들기 위해 가장 간단하게 생각할 수 있는 것은 python list인데, stack과 관련한 모든 기능이 구현되어 있기 때문이다. top을 추가적으로 가리킬 필요도 없는게 를 통하여 마지막 원소에 접근이 가능하기 때문이다. min_value를 리턴하기 위하여 생각할 수 있는 방법은 크게 두가지를 고려해볼 수 있는데, global min value를 property로 갖고 있도록 한다. 하지만 이 방법은 min value가 pop이 되면 다음 min value를 업데이트하는 과정에서 선형 탐색을 해야하므로, 비효율적이라고 볼 수 있다. stack의 원소를 (value, 현재까지의 min value)로 구성한다. 이…","fields":{"slug":"/Alg-LC-155/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 155. Min Stack","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-150/"}},"previous":{"fields":{"slug":"/Alg-LC-1/"}}},{"node":{"id":"72bf24fd-3ac5-5496-81e1-355ea20d5c0c","excerpt":"Intuition Reverse Polish Notation(후위표기법, postfix)으로 구성된 배열을 이용하여 계산을 수행하는 문제이다. 링크 후위표기법은 1+1을  [1,1,+] 과 같이 표현한다. 중위표기식에서 괄호 등으로 연산자의 우선순위를 지정하는데, 후위표기법은 (식이 유효한 경우) 괄호를 사용하지 않으며 계산을 바로 해가며 결과를 구한다. Approach 후위표기법의 계산은 스택(LIFO)으로 간단하게 구현이 가능하다. 주요 알고리즘은 다음과 같다. 스택에 후위표기식의 숫자/연산자를 하나씩 넣는다. 만약 연산자가 추가된 경우, 연산자에 필요한 숫자(사칙연산은 2개)를 pop하여 계산한다. 계산의 결과를 stack에 넣는다. 계산을 수행하고, 마지막 남은 값이 후위표기법의 결괏값이다. 해당 문제에서 주의할 점은, 나머지 연산에 대하여 정수형으로 casting해야하는 것이다. Complexity Time complexity: O(n) 입력 배열을 선형탐색하면서 스택의 …","fields":{"slug":"/Alg-LC-150/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 150. Evaluate Reverse Polish Notation","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-35&74/"}},"previous":{"fields":{"slug":"/Alg-LC-155/"}}},{"node":{"id":"276625a8-66ba-5e44-b07a-5fa0c6b71f4a","excerpt":"35번. Intuition 정렬된 배열에서 특정 값의 위치를 찾는다. 링크 Approach 정렬된 배열에서 값을 찾는 문제는 (이분탐색) 알고리즘을 이용하면 편하게 풀 수 있다. 이분탐색은 정렬된 배열에서 특정 조건을 만족시키는 원소의 인덱스를 찾는데 O(log(n))에 해결할 수 있다. 이분탐색의 알고리즘은 다음과 같다. 처음과 끝을 가리킨다. 처음은 가장 작은 값, 끝은 가장 큰 값일 것이다. 처음과 끝 중간값을 target과 비교한다. target이 더 크다면 오른쪽으로 시야를 옮기고, 더 작다면 왼쪽으로 시야를 옮긴다. (시야를 옮긴다는 것은 처음이나 끝 값을 중간값+-1로 옮김을 의미) 처음과 끝 값이 cross가 될때까지 이를 반복한다. 그 값이 중요 포인트가 될 것이다. Complexity Time complexity: O(log(n)) 이분탐색은 2부분으로 나눠서 탐색하는 것이므로 log_2(n)만큼의 시간이 걸릴 것이다. Space complexity: O(1) 배…","fields":{"slug":"/Alg-LC-35&74/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 35. Search Insert Position, 74. Search a 2D Matrix","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-3/"}},"previous":{"fields":{"slug":"/Alg-LC-150/"}}},{"node":{"id":"833b0fc7-e393-5ac3-900a-23654561e0b4","excerpt":"Intuition 문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. 링크 나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다. bbbbb -> b abcabcbb -> abc or bca or cab pwwkew -> wke or kew dvdf -> vdf Approach Brute Force 단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다. s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다 Set 이용하여 개선 처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어…","fields":{"slug":"/Alg-LC-3/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 3. Longest Substring Without Repeating Characters","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-219/"}},"previous":{"fields":{"slug":"/Alg-LC-35&74/"}}},{"node":{"id":"09f2600a-238d-539b-a6cb-12be5be29d44","excerpt":"Intuition 중복된 숫자의 위치(인덱스) 차이가 k이하인지 여부를 반환하는 문제이다. 링크 하나라도 k 이하인 것이 있다면 true를 반환한다. Approach 배열을 선형 탐색하며 python dict에 값을 key, 위치를 value로 넣어주면 된다. 해당 key가 이미 있다면, 기존 value와 현재 위치를 비교하고, k 이하라면 다음 탐색을 위하여 value를 업데이트해준다. Complexity Time complexity: O(n) 배열을 선형탐색하면서 dict에 값이 있는지 여부를 확인하고 값을 업데이트하거나 넣어준다. dict의 경우 접근이 O(1)이기 때문이다. Space complexity: O(n) Code dict의 get 연산은 key error를 발생시키지 않아 try catch로 감싸지 않을 수 있고, O(1)에 실행가능하다. 또한, value의 차이는 절댓값을 계산하는 abs함수를 이용하여 계산할 수 있다.","fields":{"slug":"/Alg-LC-219/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 219. Contains Duplicate II","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-21/"}},"previous":{"fields":{"slug":"/Alg-LC-3/"}}},{"node":{"id":"b207f215-d203-5091-b441-0dc404142c60","excerpt":"Intuition 정렬된 두개의 Singly Linked List를 하나로 merge하는 문제이다. 링크 Approach 둘 중 하나가 빈 배열이라면, 나머지를 그대로 리턴한다. 둘 다 원소가 있는 링크드 리스트라면, 더 작은 원소를 붙이고, 더 작은 원소가 있던 링크드 리스트는 다음 노드를 가리키도록 갱신한다. 이를 반복한다. 반복문 이후에 원소가 존재하는 리스트가 남아있다면, 결과 리스트에 이어붙여서 리턴해준다. Complexity Time complexity: O(n+m) => n,m 은 각각 두 링크드 리스트의 크기 Space complexity: O(1) 기존 LinkedList를 head와 current를 이용하여 가리키도록 하였으므로, 공간복잡도는 크기에 따라 달라지지 않을 것이다. Code 결과 linkedlist는 head에서부터 시작한다. 그리고 루프를 돌며 list1와 list2 중 더 작은 값을 current에 이어주면 된다.","fields":{"slug":"/Alg-LC-21/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 21. Merge Two Sorted Lists","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-2/"}},"previous":{"fields":{"slug":"/Alg-LC-219/"}}},{"node":{"id":"6d3838d9-493d-5c76-9a54-a6ec6a49a57f","excerpt":"Intuition Singly Linked List(next만 존재)로 십진수 숫자를 표현할 때, 두 숫자를 더한 결과를 Linked List로 리턴하는 문제이다. 링크 주의할 점으로는, 숫자는 작은 자리부터 거꾸로 표현이 되어있다는 것이다. 예를 들어, 123은 3->2->1로 표현되어 있다. Approach 컴퓨터 구조에서 배운 가산기와 비슷하게 더하기 연산을 구현해볼 수 있다. 올림이 발생하는 경우에 다음 자릿수로 1을 넘겨주면 된다. 이를 재귀적으로 수행하면 될 것이다. 추가적으로 두 list의 길이가 다른 경우에도 고려해야하는데, 더 짧은 list의 경우에는 더할 것이 없기 때문에 0으로 처리하였다. 짧은 리스트의 값이 남아있지 않더라도 올림수가 있을 수 있으므로, 위의 연산은 끝까지 수행해줘야한다. 더 긴 리스트 끝까지 수행했을 때에도 올림수가 남아있다면 (ex 9999 + 1 => 10000) 1을 추가적으로 1을 연결해주는 작업도 필요할 것이다. Complexity …","fields":{"slug":"/Alg-LC-2/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 2. Add Two Numbers","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-125/"}},"previous":{"fields":{"slug":"/Alg-LC-21/"}}},{"node":{"id":"5b09cc10-3279-5365-ac10-2e55df99beb3","excerpt":"Intuition 주어진 문자열에서 숫자와 영어만(대문자는 소문자로) 남겼을 때, 팰린드롬(Palindrome, 좌우 대칭인 문자열)인지를 판단하는 문제이다. 링크 Approach 우선, 정규표현식을 이용하여 알파벳과 숫자를 제외한 문자열을 제거한 후, lowercase로 바꿔준다. 이후 앞에서부터 오는 방향과 뒤에서부터 오는 방향을 비교하며 문자열의 대칭 여부를 판단하였다. Complexity Time complexity: O(n) 문자열을 제거하는 시간복잡도는 이며, 대칭을 판단하는 것 역시 에 수행이 가능하다. Space complexity: O(n) 새로운 문자열을 만들어서 처리하므로, 의 공간복잡도를 가질 것이다. Code forward와 backward가 한번이라도 다르다면 return 해주는 것이 더 빠르게 끝낼 수 있다. 추가적으로, for loop 에서 절반만 돌아 시간을 아낄 수 있을 것이다.","fields":{"slug":"/Alg-LC-125/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 125. Valid Palindrome","date":"August 27, 2023"}},"next":{"fields":{"slug":"/Alg-LC-167/"}},"previous":{"fields":{"slug":"/Alg-LC-2/"}}},{"node":{"id":"8fe1d79e-afca-5825-b14c-e9c8484a4a7f","excerpt":"Intuition 정렬된 숫자 배열에서 index1와 index2의 원소의 합이 target이 되도록 하는 인덱스 쌍을 찾는 문제이다. 링크 Approach Brute Force for loop를 두개 돌면서, 합이 target이 되도록 하는 i와 j를 찾는 방법을 고려해볼 수 있다. 하지만 이 방법은 이 걸릴 것이다. (실제로 시간초과가 난다) 배열의 크기가 까지 가므로, 최악의 경우  이 걸린다… 이를 줄이기 위해 투 포인터를 도입해볼 수 있다. Two Pointer 배열이 정렬되어 있으므로, 전수탐색하지 않아도 된다. i<=j 라면 nums[i] <= nums[j] 임을 이용하자! nums[i] + nums[j]가 target보다 크다면, 값을 줄이기 위해 j를 앞당기고, target보다 작다면 i를 뒤로 보내면 될 것이다. 물론, target보다 큰 경우에 i를 앞으로 보내도 되지만 그렇게 되면 경우의 수가 많아지므로 가장 큰 값을 내는 조합인 양 끝값으로 시작하여 방향을 …","fields":{"slug":"/Alg-LC-167/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 167. Two Sum II - Input Array Is Sorted","date":"August 27, 2023"}},"next":{"fields":{"slug":"/Alg-LC-169/"}},"previous":{"fields":{"slug":"/Alg-LC-125/"}}},{"node":{"id":"64876a6e-8bd3-50b5-acf0-34fff2b71273","excerpt":"Intuition 항상 과반수의 원소가 존재할 때, 해당 수를 찾는 문제이다링크 Approach 단순하게 배열을 정렬한 뒤, 가운데 값을 리턴하도록 하였다. Complexity Time complexity: O(nlogn) 정렬만 하면 된다. Space complexity: O(n) 기존 배열에서 처리가 가능하므로 O(n)의 공간 복잡도를 가질 것이다. Code","fields":{"slug":"/Alg-LC-169/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 169. Majority Element","date":"August 25, 2023"}},"next":{"fields":{"slug":"/Alg-LC-121/"}},"previous":{"fields":{"slug":"/Alg-LC-167/"}}},{"node":{"id":"4d7fdc3c-41f0-57a1-ba2f-80bcb15b1806","excerpt":"Intuition 가격이 주어졌을 때, 언제 팔고 언제 팔아야 최대의 이익을 얻을 수 있는지 묻는 문제이다. 링크 주의할 점으로는, 최대-최소 는 답이 아니다. 공매도는 불가능하기 때문이다. 주식을 사야 팔 수 있으므로 차이가 최대가 되는 극소지점은 극대지점보다 앞에 있어야한다. Approach 배열을 탐색하며, 최솟값을 먼저 찾는다. 동시에 최솟값에서 현재 값을 뺀 값의 최댓값을 구한다. Complexity Time complexity: O(n) 선형 탐색이므로 O(n)에 끝난다. Space complexity: O(n) Code","fields":{"slug":"/Alg-LC-121/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 121. Best Time to Buy and Sell Stock","date":"August 24, 2023"}},"next":{"fields":{"slug":"/Alg-LC-88/"}},"previous":{"fields":{"slug":"/Alg-LC-169/"}}},{"node":{"id":"84cdebb8-0dd6-5891-83bc-1d21aa4bc811","excerpt":"Intuition merge sort에서, 정렬된 두 배열을 합치는 merge algorithm에 대한 문제이다. 링크 유의해야할 점은 nums1과 nums2 배열을 합칠 때, nums1로 합쳐진다는 것이다. (그래서 nums1은 0으로 빈값이 들어있음) 두 배열을 합치면서 정렬상태를 유지하기 위해서는 하나씩 꺼내가면서 더 작은 값을 넣으면 될 것이다. 진 팀은 다음 선수로 넘어가는 가위바위보 밀어내기 팀전을 생각하면 편할 것 같다. Approach 처음 풀었을 때는 메모리 성능이 좋지 않게 나와 두번째 방법을 생각하게 되었다. sol1. 새로운 배열에 하나씩 넣기 result라는 배열을 만들어, nums1 배열과 nums2 배열의 원소를 하나씩 비교하며 넣어주었다. 만약 두 배열 중 남은 원소가 없어지는 배열이 생기면, 다른 배열의 값들을 차례대로 result에 넣어주면 된다. sol2. 새로운 배열 없이 뒤에서부터 넣기 위의 방법은 새로운 배열을 만들고, nums1에 resul…","fields":{"slug":"/Alg-LC-88/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 88. merge sorted array(python)","date":"August 23, 2023"}},"next":{"fields":{"slug":"/Alg-LC-26/"}},"previous":{"fields":{"slug":"/Alg-LC-121/"}}},{"node":{"id":"30a585f6-14f0-5e91-8fc5-a19cfbfde638","excerpt":"Intuition 정렬된 배열에서 중복을 제거하고 제거된 배열의 크기를 리턴하는 문제이다. 링크 배열의 정렬 상태가 유지되어야하고 파라미터로 들어온 배열을 변형해야한다. Approach 처음에는 python의 set 자료형을 통하여 중복을 제거하는 방법을 생각해보았다. 하지만, 이는 순서를 유지하기 위해 sort를 수행해야하므로 선형탐색 하는 방법도 구현해보았다. sol1. set(집합) 자료형으로 중복 제거 를 해주면 중복을 제거하고 정렬상태를 유지시킬 수 있다. 하지만 새롭게 만들어진 배열을 nums에다가 대입해주는 과정이 추가로 필요하다. sol2. 선형탐색하면서 중복 제거 가장 간단하게 생각해볼 수 있는 방법으로, 새로운 배열을 만들고 nums 배열을 선형탐색하며 중복되지 않는다면 값을 하나씩 넣어주면 된다. 여기서 잘 생각해보면 새로운 배열 없이 nums 안에서도 처리할 수 있다. Complexity Time complexity: sol1 : set 연산은 만큼 들고, 이…","fields":{"slug":"/Alg-LC-26/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 26. Remove Duplicates from Sorted Array","date":"August 23, 2023"}},"next":{"fields":{"slug":"/Alg-LC-27/"}},"previous":{"fields":{"slug":"/Alg-LC-88/"}}},{"node":{"id":"d604be56-daee-5aa4-a1ea-0862cb317fbb","excerpt":"Intuition 배열에서 인자로 들어온 val과 같은 원소를 제거하고, 제거한 갯수를 리턴한다. 링크 해당 갯수까지의 배열의 구성이 같은지 확인한다. Approach sol1. replace val to LARGE_NUM 선형탐색을 하며 val을 세면서 val을 LARGE_NUM으로 바꾼다. 이후, sorting하여 val이 뒤로 밀려나게 한다. sol2. 선형 탐색 선형탐색을 하며 val을 제외한 값들을 nums에 넣어준다. 넣어주면서 인덱스를 기록한다. Complexity Time complexity sol1 : 소팅하므로 O(nlogn) sol2 : 선형탐색만 하므로 O(n) Space complexity: O(n) Code 두번째 방법이 좀 더 classic하다고 볼 수 있다. new_list를 두고 val이 아닌 값을 추가할 수도 있겠지만, new_list의 사이즈는 항상 nums보다 작으므로 nums에서 처리가 가능하다! 결과는 의외로 sol1가 더 빠르게 나왔다. v…","fields":{"slug":"/Alg-LC-27/"},"frontmatter":{"categories":"Alg","title":"(Alg) LeetCode Top Interview 150 - 27. Remove Element","date":"August 23, 2023"}},"next":{"fields":{"slug":"/OS(5) - Scheduling Policy/"}},"previous":{"fields":{"slug":"/Alg-LC-26/"}}},{"node":{"id":"5b0b9dd5-ebb1-5e97-afe5-96b81e72e2d6","excerpt":"배열은 저번에 공부했듯이 고정된 크기의 연속된 주소에 저장된 자료구조이다. 배열도 저장하는 방법(위치, 정렬)에 따라 크게 4가지로 나눌 수 있다. 배열의 종류 데이터가 몰려있냐에 따라 packed 배열안의 데이터(의미있는)가 한쪽에 몰려있는 경우이다. unpacked 배열안의 데이터가 산발적으로 존재하는 경우이다. 빈 공간에는 의미없는 값이나, 특정 값(예를 들어 의미없음을 뜻하는 -1 등)이 들어가 있을 수 있다. 데이터가 정렬되어있냐에 따라 sorted 배열안의 데이터가 정렬되어(숫자면 값이 크거나 작은 순서대로) 있다. unsorted 배열안의 데이터가 정렬되어 있지 않다. (데이터의 크고 작음이 순서에 영향을 미치지 않는다) 두 기준으로 보았을 때 4가지 조합이 존재하는데, 배열에서 가장 중요한 연산인 , , 를 직접 구현해보면서 각 배열의 특징에 대하여 알아보도록 하자! (단, insert 또는 delete 시 배열 전체의 크기 변화는 없다고 가정) search는 해당 …","fields":{"slug":"/CDS01-array-2/"},"frontmatter":{"categories":"Alg","title":"(DS) 자료구조 정리 02- 다양한 종류의 배열 (packed~unpacked, sorted~unsorted)","date":"July 08, 2022"}},"next":{"fields":{"slug":"/CDS01-array-1/"}},"previous":{"fields":{"slug":"/mac-setup-openmp/"}}},{"node":{"id":"74408fa6-45a8-50c5-90bc-2d58f542b7aa","excerpt":"자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다. 수학적 귀납법 컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다. BASE : P(1)이 참이다. STEP : P(n-1) -> P(n)이 참이다. 따라서, 모든 자연수 n에 대하여 P(n)은 참이다. BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 P(n-1)이 참이라고 믿는 것인데, 이유는 무엇일까. P->Q의 의미 예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자. 100점을 맞고, 치킨을 사주었다. => 참 100점을 맞고, 치킨을 안사주었다. => 거짓 100점을 안맞았고, 치…","fields":{"slug":"/CDS01-array-1/"},"frontmatter":{"categories":"Alg","title":"(DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort","date":"July 01, 2022"}},"next":{"fields":{"slug":"/Alg-Dijkstra/"}},"previous":{"fields":{"slug":"/CDS01-array-2/"}}},{"node":{"id":"e1e5d260-58e0-58af-a974-6c589aef1c8d","excerpt":"Dijkstra(다익스트라) Algorithm은 그래프에서, 한 노드에서 출발하여 다른 노드로 가는 최단 거리를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다. 문제 설명 input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight) output : 1번노드에서 n번노드까지의 최단 거리 ​\t(입력 예시) 그래프를 표현하는 방법 weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데, 노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다. 4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, 와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다. 한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)…","fields":{"slug":"/Alg-Dijkstra/"},"frontmatter":{"categories":"Alg","title":"(Alg) 그래프 알고리즘 - Dijkstra와 최단 경로 출력","date":"May 28, 2022"}},"next":{"fields":{"slug":"/FE-input-custom-hook-ts/"}},"previous":{"fields":{"slug":"/CDS01-array-1/"}}},{"node":{"id":"a31e2810-4fcd-59b5-a65f-0bd325e9597f","excerpt":"Greedy 알고리즘의 개념에 대하여 익히고, 문제를 몇개 풀어보는 시간을 가져보자. Greedy란 욕심쟁이기법이라고도 한다. 매 과정에서 최적 선택을 고르고, 이것이 곧 전체의 최적 선택이 되는 것을 의미한다. Greedy 문제의 증명 방법 문제를 greedy하게 풀어야겠다는 생각이 들면, 보통 문제의 제약 조건 안에서 최적의 선택을 수행하면 된다. 뭔가 그렇게 푸는게 맞을거 같은데, 확신하기 어려운(증명하기 어려운) 경우가 종종 발생하는데, 이는 간단하게 귀류적으로 생각하면 된다. A, B, … , C 중에서 현재 가장 최적의 A를 골랐다고 해보자. 만약 A를 선택하지 않고 다른 B나 C를 선택하였을 경우, A를 선택하였을 경우보다 더 좋은 답을 얻지는 못한다는 것을 보이면 된다. 따라서 A를 선택하는 것이 최적이고, 답이라는 결론을 얻을 수 있다. 문제 풀이 codeforces 734B B. Anton and Digits 2,3,5,6이 적혀 있는 카드들이 있을 때, 여기서 …","fields":{"slug":"/Alg-Greedy/"},"frontmatter":{"categories":"Alg","title":"(Alg) Greedy Algorithm. 그리디(탐욕) 기법으로 문제 해결하기","date":"March 19, 2022"}},"next":{"fields":{"slug":"/Alg-Prefix-Sum/"}},"previous":{"fields":{"slug":"/ADsP-Review/"}}},{"node":{"id":"6c91f294-9e28-56aa-b3f8-eb63842f97f9","excerpt":"prefix sum은 자주 등장하는 주제이고, 알고 있으면 매우 유용하다. 개념에 대하여 익히고, 문제를 몇개 풀어보는 시간을 가져보자. Prefix sum 이란 숫자형 데이터로 이루어진 배열에서, 현재까지의 원소들의 합을 의미한다. 예를 들어, a = [1,3,-5,2,7]의 prefix sum array를 구하면 P= [1,4,-1,1,8] 이다. 누적합이라고 보면 편할 것이다! Prefix sum 배열을 앞으로 P라고 부르겠다. prefix sum을 이용하여 구간합 구하기 몇가지의 특징이 있는데, 우선 P의 마지막 원소는 배열 원소의 총합이라는 것이다. 또한 구간의 합을 구할때, P를 이용하여 다음과 같이 구할 수 있다. a[3]~a[7]까지의 합은 P[7]-P[2]와 같다. 굳이 공식화 하자면, summation from a[i] to a[j] = P[j]- P[i-1] 라고 할 수 있겠다. 이는 구간의 합을 O(1)에 구할 수 있는 매우 좋은 방법이다! 물론 초기화하는데 …","fields":{"slug":"/Alg-Prefix-Sum/"},"frontmatter":{"categories":"Alg","title":"(Alg) Prefix Sum 부분합 문제 해결하기","date":"March 14, 2022"}},"next":{"fields":{"slug":"/FE-NextJS-2/"}},"previous":{"fields":{"slug":"/Alg-Greedy/"}}},{"node":{"id":"1ba33787-0d65-5547-85b1-f5f258c16047","excerpt":"이제 백준 문제를 풀어보려고 한다. 최대힙과 관련된 문제이다. 단순하게 최댓값만 뽑아서 리턴해도 되지만, 최대힙을 사용하라해서 문제에 맞게 다시 구현해보았다. 백준에서 JS를 사용하는 방법 백준에서는 node js만 가능하고, 입력을 file system을 통하여 받아야한다. 따라서 기본적으로 모듈의 으로 가져오며 이후에 입력에 따라 재가공하면 된다. 나는 로컬에 stdin.txt파일을 만들어서 테스트한 후 제출하였다. 최대힙 최대힙은 부모 노드의 값이 자식노드의 값보다 크거나 같은 완전이진트리이다. 0번째 인덱스가 인 배열로 자식과 부모간 인덱스 이동이 가능하므로 간단하게 구현 가능하다. 런타임에러가 나서 사례를 검색하였는데, console.log()를 여러번 해주지 말고 버퍼에 넣어놨다가 마지막에 출력만 해주니 해결되었다!","fields":{"slug":"/Alg-BOJ-11279/"},"frontmatter":{"categories":"Alg","title":"(Alg) 백준 11279 최대힙 JS","date":"February 19, 2022"}},"next":{"fields":{"slug":"/full-stack-in-js/"}},"previous":{"fields":{"slug":"/ADsP-3-(3)-1/"}}},{"node":{"id":"f83049d2-462d-55ec-b98f-2ddec347a1a4","excerpt":"Tree의 종류인 Heap에 대하여 알아보도록 하자. Heap (힙)이란  부모노드가 자식노드보다 큰(혹은 작은) 완전 이진 트리를 의미한다. 형제 노드간의 대소관계는 상관없이 오직 부모와 자식관의 대소관계만 보면 된다. 완전이진트리는 마지막 레벨을 제외한 모든 노드가 가득차있고, 마지막 레벨은 왼쪽부터 순서대로 채워져 있는 이진트리이다. 부모가 자식보다 큰 힙을 , 부모가 자식보다 작은 힙을 이라고 한다. 최대힙의 경우 모든 노드의 값 중 최댓값이 루트 노드로 오게 되며, 최소힙은 최솟값이 루트노드로 오게 되는 것이 자명하다. 이러한 힙의 속성을 이용하여 루트 노드를 반복적으로 하는 (힙 정렬)을 구현할 수 있다. 또한 우선순위에 따라 선순선출(?)이 되는(우선순위 큐) 추상자료형을 구현할 수 있다. 완전 이진 트리 구현 우선 힙의 구조적인 형태는 Complete Binary Tree(완전 이진 트리)이다. 이는 이전 게시글과 같이 노드간의 레퍼런스로 구현할 수도 있지만, 배열로…","fields":{"slug":"/DS05-Heap/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) Heap","date":"November 15, 2021"}},"next":{"fields":{"slug":"/DS04-Tree/"}},"previous":{"fields":{"slug":"/FE-Webpack-1/"}}},{"node":{"id":"19b36e89-13e5-59ef-85e9-e9ac1c6d5531","excerpt":"(트리)는 계층적인 구조를 나타내기 위한 자료구조이다. 나무를 뒤집어 놓은 듯한 구조로 보통 표현되며, 뿌리인 root node에서부터 자식 노드로 단방향으로 뻗어져 나간다. 파일 디렉토리가 트리의 경로와 같이 표현되어 있으며 (ex C>>Desktop>>Document>>index.md), ,   등에도 사용된다. 트리 위키백과 Tree 용어  root(루트) : 최상위 계층에 있는 노드. 한 트리에서 루트 노드는 유일하게 존재한다. level(레벨) : 루트에서 특정노드까지의 거리(엣지의 수) parent/child node(부모-자식 노드) : 한 노드와 직접 연결되어 있는 경우, 부모 자식 노드의 관계이다. 가리키는 노드가 부모, 아닌 노드가 자식 노드라고 보면 된다. sibing nodes(형재 노드) : 같은 부모 노드를 갖는 노드 height(높이) : 트리의 높이 ==  sub tree(서브 트리) : 한 노드를 기준으로 하는 트리. 트리를 재귀적으로 볼 수 있게 해…","fields":{"slug":"/DS04-Tree/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS)트리와 이진트리 탐색 Tree & Binary Tree traverse","date":"November 05, 2021"}},"next":{"fields":{"slug":"/FE-JS-copy/"}},"previous":{"fields":{"slug":"/DS05-Heap/"}}},{"node":{"id":"1f5b55d1-79b3-570b-83ef-83ed55f01a39","excerpt":"추상자료형에 대하여 공부해보고, stack과 queue에 대하여 알아보자. Abstract Data Type(ADT, 추상자료형) 스택은이다. 추상자료형은 자료구조를 추상화한 것으로, 구현보다는 기능에만 초점을 맞춘다. 를 배울 때 에 대하여 배운 적이 있을텐데, 이는 실제 구현된 것이 아니고 기능에 대한 메서드만 명시되어 있다. 이를 implement한 클래스가 정해놓은 기능을 구현하는 방식으로 되어있다. list, set, dictionary, stack, queue는 모두 추상자료형으로 정해진 기능만을 담고 있으며 다양한 방법으로 구현될 수 있다. 예를 들어 스택은 다양하게 구현할 수 있지만, 우리는 array를 이용하여 직접 구현해볼 것이다. Stack이란 Stack(스택)은 메모리의 끝에서만 operation이 이루어지는 선형 자료구조로, 차곡차곡 쌓아올린 형태를 생각하면 이해하기 편하다.  (물론 메모리가 저렇게 생기지는 않았을 것이다. 단지 스택을 그릴때 저렇게 표현한…","fields":{"slug":"/DS03-ADT/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS)ADT 추상자료형 - Stack & Queue","date":"October 09, 2021"}},"next":{"fields":{"slug":"/DS02-LinkedList/"}},"previous":{"fields":{"slug":"/FE-React-hooks-1/"}}},{"node":{"id":"d2a012e0-3dba-5c82-b90f-2a0682b200c8","excerpt":"LinkedList란 LinkedList(연결리스트)는 리스트라는 추상자료형을 구현하는 선형 자료구조 중 하나로, 끼리 참조를 통하여 연결되어 선형적인 형태를 이루고 있는 자료구조이다. Array는 크기가 정해져 있고 메모리에서 연속적으로 존재하였지만, 링크드 리스트는 각 노드에 데이터가 저장되어 있으며 이웃한 노드의 정보(주소)를 가리키고 있는 형태로 여러 데이터를 저장한다.  간단하게 위의 그림으로 Array와 LinkedList를 비교해볼 수 있다. 연결리스트에서는 데이터가 노드에 저장되며, 노드끼리의 연결관계가 존재한다. 또한 head와 tail은 각각 처음과 마지막 노드를 가리키고 있어 모든 노드에 접근할 수 있게 되는 것이다. 따라서 각 노드는 메모리상에서 연속적으로 존재할 필요가 없으며, 데이터의 자료형이 같을 필요도 없을 것이다. LinkedList 구현 요구 사항 LinkedList에서는 배열과 다르게 데이터를 에서 갖고 있도록 한다. 노드는 데이터를 갖고 있으며,…","fields":{"slug":"/DS02-LinkedList/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) LinkedList","date":"October 04, 2021"}},"next":{"fields":{"slug":"/DS01-ArrayList/"}},"previous":{"fields":{"slug":"/DS03-ADT/"}}},{"node":{"id":"85417fbe-3e19-5b0b-a846-28bfdfe681cb","excerpt":"언어마다 다른 자료구조 JavaScript의 Array의 MDN 설명을 보면 다음과 같다. 배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체입니다. JavaScript에서 배열의 길이와 요소의 자료형은 고정되어 있지 않습니다. 배열의 길이가 언제든지 늘어나거나 줄어들 수 있기 때문에 JavaScript 배열들은 밀집도가 보장되지 않습니다. JS의 Array는 key가 int type index인 이다. 배열은 length라는 특별한 프로퍼티를 갖고 있으며, 이와 관련된 함수가 제공된다. 배열의 길이는 정해져 있지 않으며 각 원소의 크기 또한 정해져 있지 않다. 메모리상에서 연속된 형식으로 저장되어 있다고 보장을 못하는 이다. C, Java의 Array는 크기와 타입이 정해져 있는 **정적배열(static array)**이다. 따라서 선언시에 메모리 공간이 할당되며 모든 원소의 타입이 고정되어 있다. 크기가 정해져 있으므로 요소의 삽입과 삭제가 …","fields":{"slug":"/DS01-ArrayList/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) ArrayList","date":"September 12, 2021"}},"next":{"fields":{"slug":"/how-to-md/"}},"previous":{"fields":{"slug":"/DS02-LinkedList/"}}},{"node":{"id":"ecfecc2e-61ee-57a4-a949-6cb53e7fa025","excerpt":"자료구조 도서관에서 책을 찾을 때를 생각해보자. 만약 ‘로미오와 줄리엣’책을 찾는다면,  순으로 찾는다. 도서관에서 책을 찾을 수 있는 이유는 도서관에서 일정한 기준으로 책을 구조화하였기 때문이다. 일정한 약속대로 짜여진 구조가 있으므로 누구나 원하는 책을 찾을 수 있게 된다.\n컴퓨터에 데이터를 저장할 때에도 일정한 구조에 맞게 데이터를 저장한다. 우리는 이를 라고 한다. 도서관의 책을 ‘출판일자’순으로 배치하였다면 우리는 찾기 힘들 것이다. 이와 같이 각 자료구조에는 더 나은(빠르고 편한) 방법이 존재할 수 있다. 데이터를 저장하고 관리하기 위해 사용하는 구조 자료구조는 데이터의 효율적인 접근 및 조작을 가능하게 해주는 저장 및 관리 방식이라고 볼 수 있다.\n우리는 상황에 따라 최선의 자료구조 선택을 통하여 효율적인 프로그램을 짤 수 있을 것이다! 자료구조의 종류  향후 학습 방향 상황에 따라 더 맞는 자료구조가 있으며, 우리는 이를 성능(시간, 공간 복잡도)으로 판단할 수 있어…","fields":{"slug":"/DS00-start/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) 자료구조 시작","date":"September 03, 2021"}},"next":{"fields":{"slug":"/first-post/"}},"previous":{"fields":{"slug":"/how-to-md/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}