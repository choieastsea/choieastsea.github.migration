{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"861f34c0-c233-5990-af4c-6d52e87d78e5","excerpt":"Intuition ransomNote에 사용된 문자들이 모두 magazine에 포함되는지를 판단하는 문제이다. 링크 예를 들어, ‘aa’는 ‘aba’에 포함되며, ‘ab’에 포함되지는 않는다. Approach python dict를 이용하여 갯수를 기록할 수 있지만, 간단하게 를 이용하여 구현할 수 있다. 파이썬 문서 링크 iterable한 것들의 갯수를 셀 때 Counter 클래스를 이용하는 장점이 몇가지가 있다. 중복된 것들의 갯수를 알아서 세준다. 만 해주면 된다. 만약 없다면 0을 반환한다. (dict의 경우 in 연산이 아닌 index접근의 경우 KeyError가 발생) 과 같이 최빈값을 뽑을때 간단하게 사용할 수 있다. 연산이 가능하다. 이를 통하여 차집합 연산을 수행할 수 있다. 이 문제는 4번째의 특성을 이용하여 아주 간단하게 해결할 수 있다. Complexity Time complexity: O(n) Counter 인스턴스를 초기화하는데 O(n)의 시간이 걸린다. …","fields":{"slug":"/Alg-LC-383&242/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 383. Ransom Note, 242. Valid Anagram","date":"August 30, 2023"}},"next":{"fields":{"slug":"/Alg-LC-155/"}},"previous":null},{"node":{"id":"586e2d05-dd2f-5771-90db-35e8f2ac39fd","excerpt":"Intuition 값 이외에 최소값을 리턴할 수 있는 스택을 구현하는 문제이다. 링크 기본적으로, 스택은 LIFO(Last In First Out)이며 보통 배열로 구현하기 위해서는 가장 위를 가리키는 top pointer를 두고 구현할 수 있다. Approach 스택을 만들기 위해 가장 간단하게 생각할 수 있는 것은 python list인데, stack과 관련한 모든 기능이 구현되어 있기 때문이다. top을 추가적으로 가리킬 필요도 없는게 를 통하여 마지막 원소에 접근이 가능하기 때문이다. min_value를 리턴하기 위하여 생각할 수 있는 방법은 크게 두가지를 고려해볼 수 있는데, global min value를 property로 갖고 있도록 한다. 하지만 이 방법은 min value가 pop이 되면 다음 min value를 업데이트하는 과정에서 선형 탐색을 해야하므로, 비효율적이라고 볼 수 있다. stack의 원소를 (value, 현재까지의 min value)로 구성한다. 이…","fields":{"slug":"/Alg-LC-155/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 155. Min Stack","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-150/"}},"previous":{"fields":{"slug":"/Alg-LC-383&242/"}}},{"node":{"id":"72bf24fd-3ac5-5496-81e1-355ea20d5c0c","excerpt":"Intuition Reverse Polish Notation(후위표기법, postfix)으로 구성된 배열을 이용하여 계산을 수행하는 문제이다. 링크 후위표기법은 1+1을  [1,1,+] 과 같이 표현한다. 중위표기식에서 괄호 등으로 연산자의 우선순위를 지정하는데, 후위표기법은 (식이 유효한 경우) 괄호를 사용하지 않으며 계산을 바로 해가며 결과를 구한다. Approach 후위표기법의 계산은 스택(LIFO)으로 간단하게 구현이 가능하다. 주요 알고리즘은 다음과 같다. 스택에 후위표기식의 숫자/연산자를 하나씩 넣는다. 만약 연산자가 추가된 경우, 연산자에 필요한 숫자(사칙연산은 2개)를 pop하여 계산한다. 계산의 결과를 stack에 넣는다. 계산을 수행하고, 마지막 남은 값이 후위표기법의 결괏값이다. 해당 문제에서 주의할 점은, 나머지 연산에 대하여 정수형으로 casting해야하는 것이다. Complexity Time complexity: O(n) 입력 배열을 선형탐색하면서 스택의 …","fields":{"slug":"/Alg-LC-150/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 150. Evaluate Reverse Polish Notation","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-1/"}},"previous":{"fields":{"slug":"/Alg-LC-155/"}}},{"node":{"id":"61493ac7-9107-5b2a-b8bd-433bac4e0549","excerpt":"Intuition 배열의 두 숫자의 합으로 target을 표현할 수 있을때, 그 위치를 반환하는 문제이다. 링크 Approach sol1 (Brute Force) 가장 간단하게 2중 loop를 돌며 nums[i] + nums[j] == target이 되는 지점을 탐색한다. sol2 (Hash Table) python dict를 이용하여 배열을 선형탐색한다. i번째 값이 num일 때, num을 dict에 넣어준다. 그리고, target-num이 dict에 있다면 그곳이 합이 target이 되는 지점이다. Complexity Time complexity: O(n) 배열을 선형탐색하면서 dict에 값이 있는지 여부를 확인하고 값을 업데이트하거나 넣어준다. dict의 경우 접근이 O(1)이기 때문이다. Space complexity: O(n) Code 간단하게 탐색하면 된다. j는 i보다 뒤에 있으면 된다. 최악의 경우 (n^2)/2 만큼 걸리지만 매우 느리다. 주의할 점은, 은 해당 k…","fields":{"slug":"/Alg-LC-1/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 1. Two Sum","date":"August 29, 2023"}},"next":{"fields":{"slug":"/Alg-LC-219/"}},"previous":{"fields":{"slug":"/Alg-LC-150/"}}},{"node":{"id":"09f2600a-238d-539b-a6cb-12be5be29d44","excerpt":"Intuition 중복된 숫자의 위치(인덱스) 차이가 k이하인지 여부를 반환하는 문제이다. 링크 하나라도 k 이하인 것이 있다면 true를 반환한다. Approach 배열을 선형 탐색하며 python dict에 값을 key, 위치를 value로 넣어주면 된다. 해당 key가 이미 있다면, 기존 value와 현재 위치를 비교하고, k 이하라면 다음 탐색을 위하여 value를 업데이트해준다. Complexity Time complexity: O(n) 배열을 선형탐색하면서 dict에 값이 있는지 여부를 확인하고 값을 업데이트하거나 넣어준다. dict의 경우 접근이 O(1)이기 때문이다. Space complexity: O(n) Code dict의 get 연산은 key error를 발생시키지 않아 try catch로 감싸지 않을 수 있고, O(1)에 실행가능하다. 또한, value의 차이는 절댓값을 계산하는 abs함수를 이용하여 계산할 수 있다.","fields":{"slug":"/Alg-LC-219/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 219. Contains Duplicate II","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-35&74/"}},"previous":{"fields":{"slug":"/Alg-LC-1/"}}},{"node":{"id":"276625a8-66ba-5e44-b07a-5fa0c6b71f4a","excerpt":"35번. Intuition 정렬된 배열에서 특정 값의 위치를 찾는다. 링크 Approach 정렬된 배열에서 값을 찾는 문제는 (이분탐색) 알고리즘을 이용하면 편하게 풀 수 있다. 이분탐색은 정렬된 배열에서 특정 조건을 만족시키는 원소의 인덱스를 찾는데 O(log(n))에 해결할 수 있다. 이분탐색의 알고리즘은 다음과 같다. 처음과 끝을 가리킨다. 처음은 가장 작은 값, 끝은 가장 큰 값일 것이다. 처음과 끝 중간값을 target과 비교한다. target이 더 크다면 오른쪽으로 시야를 옮기고, 더 작다면 왼쪽으로 시야를 옮긴다. (시야를 옮긴다는 것은 처음이나 끝 값을 중간값+-1로 옮김을 의미) 처음과 끝 값이 cross가 될때까지 이를 반복한다. 그 값이 중요 포인트가 될 것이다. Complexity Time complexity: O(log(n)) 이분탐색은 2부분으로 나눠서 탐색하는 것이므로 log_2(n)만큼의 시간이 걸릴 것이다. Space complexity: O(1) 배…","fields":{"slug":"/Alg-LC-35&74/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 35. Search Insert Position, 74. Search a 2D Matrix","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-3/"}},"previous":{"fields":{"slug":"/Alg-LC-219/"}}},{"node":{"id":"833b0fc7-e393-5ac3-900a-23654561e0b4","excerpt":"Intuition 문자열에서 반복되지 않는 substring 중 최대의 길이를 찾는 문제이다. 링크 나는 여기서 반복되지 않는 substring이 이해가 되지 않았는데, 몇가지 예시를 살펴보면 다음과 같다. bbbbb -> b abcabcbb -> abc or bca or cab pwwkew -> wke or kew dvdf -> vdf Approach Brute Force 단순하게 문자열을 하나씩 탐색하며, 반복되지 않도록 substr를 만들어주었다. 그리고, substr이 바뀔 때마다 길이의 최댓값을 갱신하도록 하였다. s의 i 번째 문자를 탐색할 때, substr에 이미 해당 문자가 존재하는 경우, substr의 해당 문자까지를 없애고, i번째 문자를 추가해주는 방식으로 substr를 갱신해준다 Set 이용하여 개선 처음에 1과 같이 풀었지만, substr에 해당 문자가 존재하는 경우를 판단하는 과정에서 만큼 소요되므로, 이를 set으로 개선해보았다. set은 find에 있어…","fields":{"slug":"/Alg-LC-3/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 3. Longest Substring Without Repeating Characters","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-21/"}},"previous":{"fields":{"slug":"/Alg-LC-35&74/"}}},{"node":{"id":"b207f215-d203-5091-b441-0dc404142c60","excerpt":"Intuition 정렬된 두개의 Singly Linked List를 하나로 merge하는 문제이다. 링크 Approach 둘 중 하나가 빈 배열이라면, 나머지를 그대로 리턴한다. 둘 다 원소가 있는 링크드 리스트라면, 더 작은 원소를 붙이고, 더 작은 원소가 있던 링크드 리스트는 다음 노드를 가리키도록 갱신한다. 이를 반복한다. 반복문 이후에 원소가 존재하는 리스트가 남아있다면, 결과 리스트에 이어붙여서 리턴해준다. Complexity Time complexity: O(n+m) => n,m 은 각각 두 링크드 리스트의 크기 Space complexity: O(1) 기존 LinkedList를 head와 current를 이용하여 가리키도록 하였으므로, 공간복잡도는 크기에 따라 달라지지 않을 것이다. Code 결과 linkedlist는 head에서부터 시작한다. 그리고 루프를 돌며 list1와 list2 중 더 작은 값을 current에 이어주면 된다.","fields":{"slug":"/Alg-LC-21/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 21. Merge Two Sorted Lists","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-2/"}},"previous":{"fields":{"slug":"/Alg-LC-3/"}}},{"node":{"id":"6d3838d9-493d-5c76-9a54-a6ec6a49a57f","excerpt":"Intuition Singly Linked List(next만 존재)로 십진수 숫자를 표현할 때, 두 숫자를 더한 결과를 Linked List로 리턴하는 문제이다. 링크 주의할 점으로는, 숫자는 작은 자리부터 거꾸로 표현이 되어있다는 것이다. 예를 들어, 123은 3->2->1로 표현되어 있다. Approach 컴퓨터 구조에서 배운 가산기와 비슷하게 더하기 연산을 구현해볼 수 있다. 올림이 발생하는 경우에 다음 자릿수로 1을 넘겨주면 된다. 이를 재귀적으로 수행하면 될 것이다. 추가적으로 두 list의 길이가 다른 경우에도 고려해야하는데, 더 짧은 list의 경우에는 더할 것이 없기 때문에 0으로 처리하였다. 짧은 리스트의 값이 남아있지 않더라도 올림수가 있을 수 있으므로, 위의 연산은 끝까지 수행해줘야한다. 더 긴 리스트 끝까지 수행했을 때에도 올림수가 남아있다면 (ex 9999 + 1 => 10000) 1을 추가적으로 1을 연결해주는 작업도 필요할 것이다. Complexity …","fields":{"slug":"/Alg-LC-2/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 2. Add Two Numbers","date":"August 28, 2023"}},"next":{"fields":{"slug":"/Alg-LC-167/"}},"previous":{"fields":{"slug":"/Alg-LC-21/"}}},{"node":{"id":"8fe1d79e-afca-5825-b14c-e9c8484a4a7f","excerpt":"Intuition 정렬된 숫자 배열에서 index1와 index2의 원소의 합이 target이 되도록 하는 인덱스 쌍을 찾는 문제이다. 링크 Approach Brute Force for loop를 두개 돌면서, 합이 target이 되도록 하는 i와 j를 찾는 방법을 고려해볼 수 있다. 하지만 이 방법은 이 걸릴 것이다. (실제로 시간초과가 난다) 배열의 크기가 까지 가므로, 최악의 경우  이 걸린다… 이를 줄이기 위해 투 포인터를 도입해볼 수 있다. Two Pointer 배열이 정렬되어 있으므로, 전수탐색하지 않아도 된다. i<=j 라면 nums[i] <= nums[j] 임을 이용하자! nums[i] + nums[j]가 target보다 크다면, 값을 줄이기 위해 j를 앞당기고, target보다 작다면 i를 뒤로 보내면 될 것이다. 물론, target보다 큰 경우에 i를 앞으로 보내도 되지만 그렇게 되면 경우의 수가 많아지므로 가장 큰 값을 내는 조합인 양 끝값으로 시작하여 방향을 …","fields":{"slug":"/Alg-LC-167/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 167. Two Sum II - Input Array Is Sorted","date":"August 27, 2023"}},"next":{"fields":{"slug":"/Alg-LC-125/"}},"previous":{"fields":{"slug":"/Alg-LC-2/"}}},{"node":{"id":"5b09cc10-3279-5365-ac10-2e55df99beb3","excerpt":"Intuition 주어진 문자열에서 숫자와 영어만(대문자는 소문자로) 남겼을 때, 팰린드롬(Palindrome, 좌우 대칭인 문자열)인지를 판단하는 문제이다. 링크 Approach 우선, 정규표현식을 이용하여 알파벳과 숫자를 제외한 문자열을 제거한 후, lowercase로 바꿔준다. 이후 앞에서부터 오는 방향과 뒤에서부터 오는 방향을 비교하며 문자열의 대칭 여부를 판단하였다. Complexity Time complexity: O(n) 문자열을 제거하는 시간복잡도는 이며, 대칭을 판단하는 것 역시 에 수행이 가능하다. Space complexity: O(n) 새로운 문자열을 만들어서 처리하므로, 의 공간복잡도를 가질 것이다. Code forward와 backward가 한번이라도 다르다면 return 해주는 것이 더 빠르게 끝낼 수 있다. 추가적으로, for loop 에서 절반만 돌아 시간을 아낄 수 있을 것이다.","fields":{"slug":"/Alg-LC-125/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 125. Valid Palindrome","date":"August 27, 2023"}},"next":{"fields":{"slug":"/Alg-LC-169/"}},"previous":{"fields":{"slug":"/Alg-LC-167/"}}},{"node":{"id":"64876a6e-8bd3-50b5-acf0-34fff2b71273","excerpt":"Intuition 항상 과반수의 원소가 존재할 때, 해당 수를 찾는 문제이다링크 Approach 단순하게 배열을 정렬한 뒤, 가운데 값을 리턴하도록 하였다. Complexity Time complexity: O(nlogn) 정렬만 하면 된다. Space complexity: O(n) 기존 배열에서 처리가 가능하므로 O(n)의 공간 복잡도를 가질 것이다. Code","fields":{"slug":"/Alg-LC-169/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 169. Majority Element","date":"August 25, 2023"}},"next":{"fields":{"slug":"/Alg-LC-121/"}},"previous":{"fields":{"slug":"/Alg-LC-125/"}}},{"node":{"id":"4d7fdc3c-41f0-57a1-ba2f-80bcb15b1806","excerpt":"Intuition 가격이 주어졌을 때, 언제 팔고 언제 팔아야 최대의 이익을 얻을 수 있는지 묻는 문제이다. 링크 주의할 점으로는, 최대-최소 는 답이 아니다. 공매도는 불가능하기 때문이다. 주식을 사야 팔 수 있으므로 차이가 최대가 되는 극소지점은 극대지점보다 앞에 있어야한다. Approach 배열을 탐색하며, 최솟값을 먼저 찾는다. 동시에 최솟값에서 현재 값을 뺀 값의 최댓값을 구한다. Complexity Time complexity: O(n) 선형 탐색이므로 O(n)에 끝난다. Space complexity: O(n) Code","fields":{"slug":"/Alg-LC-121/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 121. Best Time to Buy and Sell Stock","date":"August 24, 2023"}},"next":{"fields":{"slug":"/Alg-LC-88/"}},"previous":{"fields":{"slug":"/Alg-LC-169/"}}},{"node":{"id":"84cdebb8-0dd6-5891-83bc-1d21aa4bc811","excerpt":"Intuition merge sort에서, 정렬된 두 배열을 합치는 merge algorithm에 대한 문제이다. 링크 유의해야할 점은 nums1과 nums2 배열을 합칠 때, nums1로 합쳐진다는 것이다. (그래서 nums1은 0으로 빈값이 들어있음) 두 배열을 합치면서 정렬상태를 유지하기 위해서는 하나씩 꺼내가면서 더 작은 값을 넣으면 될 것이다. 진 팀은 다음 선수로 넘어가는 가위바위보 밀어내기 팀전을 생각하면 편할 것 같다. Approach 처음 풀었을 때는 메모리 성능이 좋지 않게 나와 두번째 방법을 생각하게 되었다. sol1. 새로운 배열에 하나씩 넣기 result라는 배열을 만들어, nums1 배열과 nums2 배열의 원소를 하나씩 비교하며 넣어주었다. 만약 두 배열 중 남은 원소가 없어지는 배열이 생기면, 다른 배열의 값들을 차례대로 result에 넣어주면 된다. sol2. 새로운 배열 없이 뒤에서부터 넣기 위의 방법은 새로운 배열을 만들고, nums1에 resul…","fields":{"slug":"/Alg-LC-88/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 88. merge sorted array(python)","date":"August 23, 2023"}},"next":{"fields":{"slug":"/Alg-LC-27/"}},"previous":{"fields":{"slug":"/Alg-LC-121/"}}},{"node":{"id":"d604be56-daee-5aa4-a1ea-0862cb317fbb","excerpt":"Intuition 배열에서 인자로 들어온 val과 같은 원소를 제거하고, 제거한 갯수를 리턴한다. 링크 해당 갯수까지의 배열의 구성이 같은지 확인한다. Approach sol1. replace val to LARGE_NUM 선형탐색을 하며 val을 세면서 val을 LARGE_NUM으로 바꾼다. 이후, sorting하여 val이 뒤로 밀려나게 한다. sol2. 선형 탐색 선형탐색을 하며 val을 제외한 값들을 nums에 넣어준다. 넣어주면서 인덱스를 기록한다. Complexity Time complexity sol1 : 소팅하므로 O(nlogn) sol2 : 선형탐색만 하므로 O(n) Space complexity: O(n) Code 두번째 방법이 좀 더 classic하다고 볼 수 있다. new_list를 두고 val이 아닌 값을 추가할 수도 있겠지만, new_list의 사이즈는 항상 nums보다 작으므로 nums에서 처리가 가능하다! 결과는 의외로 sol1가 더 빠르게 나왔다. v…","fields":{"slug":"/Alg-LC-27/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 27. Remove Element","date":"August 23, 2023"}},"next":{"fields":{"slug":"/Alg-LC-26/"}},"previous":{"fields":{"slug":"/Alg-LC-88/"}}},{"node":{"id":"30a585f6-14f0-5e91-8fc5-a19cfbfde638","excerpt":"Intuition 정렬된 배열에서 중복을 제거하고 제거된 배열의 크기를 리턴하는 문제이다. 링크 배열의 정렬 상태가 유지되어야하고 파라미터로 들어온 배열을 변형해야한다. Approach 처음에는 python의 set 자료형을 통하여 중복을 제거하는 방법을 생각해보았다. 하지만, 이는 순서를 유지하기 위해 sort를 수행해야하므로 선형탐색 하는 방법도 구현해보았다. sol1. set(집합) 자료형으로 중복 제거 를 해주면 중복을 제거하고 정렬상태를 유지시킬 수 있다. 하지만 새롭게 만들어진 배열을 nums에다가 대입해주는 과정이 추가로 필요하다. sol2. 선형탐색하면서 중복 제거 가장 간단하게 생각해볼 수 있는 방법으로, 새로운 배열을 만들고 nums 배열을 선형탐색하며 중복되지 않는다면 값을 하나씩 넣어주면 된다. 여기서 잘 생각해보면 새로운 배열 없이 nums 안에서도 처리할 수 있다. Complexity Time complexity: sol1 : set 연산은 만큼 들고, 이…","fields":{"slug":"/Alg-LC-26/"},"frontmatter":{"categories":"ALG","title":"(Alg) LeetCode Top Interview 150 - 26. Remove Duplicates from Sorted Array","date":"August 23, 2023"}},"next":{"fields":{"slug":"/OS(5) - Scheduling Policy/"}},"previous":{"fields":{"slug":"/Alg-LC-27/"}}},{"node":{"id":"673fdb45-03b2-5faa-82e9-8bda9f41a585","excerpt":"저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지()에 대하여 공부해보았다. 오늘은 scheduling을 할 때 순서를 결정짓는  에 대하여 공부해보도록 하자. 란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다. 오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다. Scheduling의 목표 우선 CPU burst time에 대하여 알 필요가 있다. CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간 만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임 scheduling의 목표는 다음과 같다. Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다 Minimize average  : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화 Minimize …","fields":{"slug":"/OS(5) - Scheduling Policy/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [5. Scheduling Policies]","date":"July 26, 2023"}},"next":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}},"previous":{"fields":{"slug":"/Alg-LC-26/"}}},{"node":{"id":"f8a99189-165d-5bbd-9e80-a64a0c519a84","excerpt":"이번에는 실제 프로세스가 실행되는 과정을 운영체제의 역할에 초점을 맞추어 공부해보도록 하자. Process Execution (Direct Execution) Process를 실행할 때 단순한 운영체제가 하는 일들을 순서대로 알아보자. 간단하게 하나의 CPU에서 하나의 Process가 실행된다고 가정하자. OS는 메모리를 할당하고 memory image를 만든다. 메모리 이미지는 저번에도 언급했듯 code, data, stack, heap 영역을 포함한다. CPU의 Program Counter, 그리고 기타 레지스터(Stack Pointer)들이 초기화된다. 위의 세팅 과정이 끝나고, Process는 CPU를 점유하고 명령어들을 실행하게 된다 (명령어 실행 과정에서 OS는 개입하지 않음) 일반 함수의 실행 과정 예를 들어, 어떠한 함수를 실행한다고 하자. 함수 실행시, 메모리에서는 함수의 내용이 존재하는 위치로 하게 된다. 이때, 함수 종료 이후의 실행을 위해 기존의 메모리 위치(…","fields":{"slug":"/OS(4)-Process Execution Mechanisms/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [4. Process Execution Mechanisms]","date":"July 16, 2023"}},"next":{"fields":{"slug":"/OS(3)- Process API/"}},"previous":{"fields":{"slug":"/OS(5) - Scheduling Policy/"}}},{"node":{"id":"2c803dde-8b03-5489-ae45-f640fcdf8b24","excerpt":"OS는 이라는 함수들로 Process를 생성/제어할 수 있는 API(Application Programming Interface)를 제공한다. 시스템 콜을 통하여 우리는 하드웨어에 대한 권한을 일부 부여받을 수 있게 된다. System call OS에서 에 들어왔을 때 사용할 수 있는 함수. 즉, system call은 일반 함수와 다른 높은 권한을 갖는 함수라고 볼 수 있다. H/W에 직접 접근하는 등의 민감한 작업들은 오직 에서만 가능하므로 system call을 사용해야 한다. IO 작업과 같은해주는 system call들은 process를 blocked상태로 descheduled 시키게 될 것이다. 즉, 하드웨어의 동작에 긴밀하게 연관되어 있다고 볼 수 있다. Should we rewrite programs for each OS? 시스템 콜은 운영체제마다 조금씩 다르다. 하지만, 거의 모든 현대의 운영체제는 라는 시스템 콜의 표준이 존재하므로, OS마다 다른 프로그램을 작성…","fields":{"slug":"/OS(3)- Process API/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [3. Process API]","date":"July 15, 2023"}},"next":{"fields":{"slug":"/OS(2)-Process/"}},"previous":{"fields":{"slug":"/OS(4)-Process Execution Mechanisms/"}}},{"node":{"id":"ef679d0a-8051-5f57-a48b-1868cb4bba1b","excerpt":"Process Process는 실행중인 프로그램(running program)으로 정의할 수 있다. 반면에 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 하나의 프로세스가 하나의 CPU를 점유하는 것처럼 보이도록 을 해서, 여러 프로그램이 동시에 실행되는 illusion을 만들어준다. 여기서 시간을 잘게 나누어 여러 Process를 수행하도록 하는 방법을 이라고 하며, 이를 구현하기 위해 운영체제는 저수준의 메커니즘인 부터, 고수준의 scheduling과 같은 까지 포함한다. 그렇다면 운영체제는 process를 어떻게 표현할 수 있을까? 프로세스 표현하기(Process Abstraction) 프로세스를 표현하기 위해서는 실행되는 동안 필요한 자원(하드웨어)의 목록이 있어야 할 것이다. 프로세스는 실행동안에 하드웨어의 상태()를 읽거나, 업데이트하거나 할 것이기 때문에 다음과 같은 정보들이 필요하다. PID (프로세스를 구분하기 위해 프로세…","fields":{"slug":"/OS(2)-Process/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [2. Process Abstraction]","date":"June 28, 2023"}},"next":{"fields":{"slug":"/OS(1)-computer-architecture/"}},"previous":{"fields":{"slug":"/OS(3)- Process API/"}}},{"node":{"id":"84137e27-ee51-5a2b-8271-d1e61c57eda6","excerpt":"운영체제에 앞서 컴퓨터 구조를 한번 복습하고 가보자! Von Neumann Architecture 폰 노이만 구조 컴퓨터 프로그램은 많은 명령어들로 구성되어 있으며, 명령어들은 각각 로부터 fetch, decode, execute, writeback의 과정을 거치며, 이는 프로그램이 종료될 때까지 수행된다. 명령어들은 에 올라가(load)있어야하며, CPU는  레지스터를 통해 명령어를 가져오고, 그 뒤의 과정을 거치게 된다. CPU, memory와 같은 device들은 서로 bus(역할에 따라 data, control, address bus 존재)를 통해서 연결되어 있다. 이러한 형식으로 프로그램만 바꾸어가며 메모리에 (버스를 통해) 적재된 후 실행할 수 있는 구조를 라고 한다. 이는 현대의 컴퓨터 구조의 기반이 된다. 프로그램은 실행되기 위해 ‘파일’의 형태로 저장장치에 저장되지만, 이를 실제 실행하기 위해서는 메모리에 로드가 되어야 한다는 것을 알 필요가 있다. CPU Cent…","fields":{"slug":"/OS(1)-computer-architecture/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [1. 컴퓨터 구조 skim]","date":"June 27, 2023"}},"next":{"fields":{"slug":"/OS(0)-intro/"}},"previous":{"fields":{"slug":"/OS(2)-Process/"}}},{"node":{"id":"2417c2da-54ea-589c-8580-8f3be2b8e4b0","excerpt":"운영체제란? OS Operating System 운영체제가 없는 컴퓨터도 존재할 수 있지만, 문구점에서 살 수 있는 계산기와 같이 고정된 기능만 수행할 수 있을 것이다. Programmable한 기계에는 운영체제가 필요할 것이다..! 운영체제는 프로그램들이 실행되고, 사용자와 상호작용하기 위해 자원을 효율적으로 관리하거나, 자원을 보호하는 역할을 수행하는 소프트웨어이다. 운영체제는 자원을 어떻게 관리하고 보호할까? OS는 physical(cpu, memory, HDD 등 모든 장치)에 대하여 사용자가 직접 접근할 수 없도록 한다. 이러한 자원에 접근할 수 있는 를 통하여 사용자가 자원에 정해진 방법으로 접근할 수 있도록 제공한다. 이러한 역할을 (가상화)라고 하며, OS를 virtural machine으로 보는 견해도 존재한다. 자동차를 보면, 사용자가 엔진을 직접 제어한다기 보다는 엑셀과 기어 등으로(정해진 방법을 통해서) 엔진을 컨트롤하고 엔진을 직접 보는 것이 아닌 계기판을 …","fields":{"slug":"/OS(0)-intro/"},"frontmatter":{"categories":"OS","title":"(OS) 운영체제 복습 [0. 운영체제의 개요]","date":"June 26, 2023"}},"next":{"fields":{"slug":"/Django(12)- nested model /"}},"previous":{"fields":{"slug":"/OS(1)-computer-architecture/"}}},{"node":{"id":"d29ae45e-a773-5de5-b305-65de5395c632","excerpt":"저번까지 Item 모델과 연관된 Question과 Answer 모델을 구현해보았다. 질문을 남긴 사람만 해당 질문을 변경할 수 있고, 답변은 관리자 페이지를 통해서만 달 수 있다. 오늘은 쇼핑몰의 핵심 기능인 사용자가 물건을 장바구니에 담고, 구매하는 기능을 구현해보도록 하자. 장바구니(Cart) 모델 만들기 장바구니에 대한 요구사항을 간단하게 정리해보자. 장바구니는 User model과 Item model을 으로 연결해주는 테이블이므로, 별도의 모델로 작성하도록 한다. 로 장바구니 앱을 만들자. 사용자 물건(item) & 물건의 현재 가격 수량 장바구니 추가/업데이트 시점(추가, 수정 등으로 7일 지나면 장바구니 삭제되도록 할 수 있을 것) 위의 요구사항을 에 구현해보자. 다음으로는, serializer를 구현한다. serializer에서는 아래의 두가지 필드가 추가되면 좋을 것 같다. 총 금액 주문이 가능한지 여부(품절이 되면 주문이 불가능) 사용자에게 해당 필드를 제공하면서,…","fields":{"slug":"/Django(12)- nested model /"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [12- nested model & serializer, 장바구니 모델 추가]","date":"June 16, 2023"}},"next":{"fields":{"slug":"/Django(11)- model advanced/"}},"previous":{"fields":{"slug":"/OS(0)-intro/"}}},{"node":{"id":"743c8dd2-f602-5a45-9e46-65b1f6265e9d","excerpt":"저번까지 Django User model과 이를 처리하는 SessionAuthentication에 대하여 알아보았다. 오늘은 “상품”에 해당하는 Item model을 구체적으로 구현해보고, 서비스를 위한 몇가지 모델을 추가로 만들어보자. 우선, 상품에 대하여 질문과 답변을 남길 수 있도록 Question 모델과 QNA 모델을 만들어주도록 한다. Model with ForeignKey 질문 모델에 대한 정의는 별도의 app을 만들어서 진행하였다. 질문에 대한 모델과 답변에 대한 모델이 존재하는데, 질문은 2개의 Foriegn key를 가져야 한다. 어떤 아이템에 대한 질문인지 (item) 누가 작성한 질문인지 (user) 로 정의한 필드들은 origin이 어디에 있는지, 참조하고 있는 데이터가 삭제되었을 때에 대한 정의를 해줄 수 있다. 추가적으로, 우리처럼 custom user model을 사용한 경우에는, 를 해주고, 로 가져와야 한다!! settings.py에서 AUTH_USE…","fields":{"slug":"/Django(11)- model advanced/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [11- 모델 구체화, 참조 모델 구현]","date":"May 12, 2023"}},"next":{"fields":{"slug":"/Django(10)-Signal and Permissions/"}},"previous":{"fields":{"slug":"/Django(12)- nested model /"}}},{"node":{"id":"55e8c2c3-78dc-5102-bb2b-c19c4883d54c","excerpt":"장고의 세션 기능은 생각보다 많은 기능들이 제공된다. Django Session DB 관리하기 세션 만료 기본적으로, 세션의 만료 시간이 정해져 있다. setttings.py에서 설정할 수 있는데, 몇가지 옵션들을 알아보자. SESSION_EXPIRE_AT_BROWSER_CLOSE (default : False) 브라우저가 종료될 때 세션이 만료되도록 하는 옵션 SESSION_COOKIE_AGE 위의 옵션이 False일 때, 세션의 유효 기간 (초 단위) SESSION_SAVE_EVERY_REQUEST (default : False) 요청이 올때, 세션의 유효기간을 갱신할 지 여부 중복 로그인 방지 장고에서는 로그인 시,  signal이 발생하게 된다. 이는 비동기/GUI 프로그래밍의 event와 비슷한 것으로, eventHandler(listener)를 달아주는 것처럼 장고에서는 를 달아주면 된다! signals은 장고에서 제공하는 몇가지가 있고, 커스텀으로도 특정 시그널을 만들…","fields":{"slug":"/Django(10)-Signal and Permissions/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [10- 세션 기능 추가 + DRF permissions]","date":"May 03, 2023"}},"next":{"fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"}},"previous":{"fields":{"slug":"/Django(11)- model advanced/"}}},{"node":{"id":"9faef788-f40a-5db0-97c2-24efd7802c83","excerpt":"저번까지 User model을 1:1 매핑하여 Profile model을 만들어서 usermodel을 커스텀 하는 방법으로 구현해보았다. 하지만, 쓸모 없이 복잡한 부분들도 많고 이는 그렇게 권장되는 방향이 아닐 것이다. 따라서, 장고에서 제공하는 User model의 상위 클래스인 를 이용하여 사용자 모델을 커스텀하는 방법으로 전환해보자..! 힘들겠지만, 지금이라도 바꿔야 좋을 것이다. Abstract User Model 우선, 우리는 이미 기존 user model을 마이그레이트해서 사용한 적이 있으므로, 이를 지워줄 필요가 있다. 우선, migration파일 내용을 지워준다. DB에서  를 실행해준다. myuser/models.py에 Profile class를 없애주고, 다음을 추가한다. settings.py에서 기본 사용자 객체를 우리가 정한 User로 바꿔준다. 다시 migration을 진행해준다. 해당 커밋은 여기를 참고한다. 다시 로 새로운 관리자 계정을 만들고 들어가보…","fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [9-django user model (AbstractUser & SessionAuthentication in DRF)]","date":"April 28, 2023"}},"next":{"fields":{"slug":"/Django(8)-User Model/"}},"previous":{"fields":{"slug":"/Django(10)-Signal and Permissions/"}}},{"node":{"id":"547ad7ca-81ab-59f0-8b59-28fabce02cf6","excerpt":"이전까지 장고와 리액트 서버를 연결해보았고, 이때 생길 수 있는 문제인 CORS 정책을 해결하는 것까지 알아보았다. 오늘은 간단하게 장고에서 지원하는 사용자 모델에 대하여 알아보고, 회원가입과 로그인/로그아웃 등의 기능을 구현해보자. 장고에서 제공하는 User Model 장고에서는 사용자와 관련한 많은 기능들이 포함된 User Model class가 기본적으로 제공된다. 공식문서 settings.py에서 User관련한 것들을 추가하지 않고 migration을 진행하였다면 DB에 auth_~로 시작하는 테이블이 만들어져있을 것이다. 하지만, 여기서 제공하는 user의 필드는 id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined 정도이다. 로그인은 username과 password를 기반으로 이루어지며, is_active한 사용자만 aut…","fields":{"slug":"/Django(8)-User Model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [8-django user model (1 to 1)]","date":"April 23, 2023"}},"next":{"fields":{"slug":"/Django(7)-Search&CORS/"}},"previous":{"fields":{"slug":"/Django(9)- Abstract User model & SessionAuthentication/"}}},{"node":{"id":"2216b6bb-30a6-5f7e-8c55-546e561f0708","excerpt":"이전까지 DRF의 CBV를 어떻게 구현하는지 알아보았다. ModelViewSet이 가장 간단하게 구현이 가능했는데, 이를 기반으로 검색기능을 만들어보자. Item 모델의 이름(name)에 해당 검색어가 포함되는지를 판단하여 리턴하는 api를 기존 ModelViewSet에다가 만들어보려고 한다. 그리고 가능하다면 실제 브라우저와 연결해보도록 하자!! 요구사항 [GET] localhost:8000/item/search?name=I I를 포함한 name을 갖는 item list를 리턴하도록 우선, 앞으로는 ModelViewSet으로만 처리하기 위해 items/urls.py를 간단하게 해주었다. ModelViewSet 클래스 수정  오버라이딩 ModelViewSet에서는 질의가 들어왔을 때, 내부적으로 함수를 사용한다. 따라서 이를 오버라이딩하여 쿼리 문자열을 처리할 수 있다. 쿼리 문자열은 으로 접근할 수 있다. Django ORM에서 를 하면 해당 문자열(대소문자 구분 없이)이 포함되…","fields":{"slug":"/Django(7)-Search&CORS/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [7-Search, 브라우저와 연결하기]","date":"April 16, 2023"}},"next":{"fields":{"slug":"/Django(6)-request-response/"}},"previous":{"fields":{"slug":"/Django(8)-User Model/"}}},{"node":{"id":"14ee35cd-9837-5380-8e94-1042bcaa938f","excerpt":"저번까지는 DRF의 serailizer에 대하여 공부하였고, 새로운 item을 만드는 api까지 간단하게 만들어보았다. 오늘은 좀 더 다양한 method에 대하여 알아보고, DRF(Django Rest Framework)의 을 도입하여 rest api에 최적화된 간단한 view구조를 설계해보도록 한다. 다양한 request에 대한 response 장고에서는 request와 response를 이렇게 처리한다. 장고에서는 요청을 HttpRequest객체에서 처리하도록 하고, 응답은 HttpResponse객체에서 처리하도록 한다. 이렇게 요청에 대하여 함수에서 처리하도록 하는 것을 라고 하며, 뷰 클래스에서 처리하도록 하는  역시 존재한다. in drf DRF에서도 request와 response를 받는 방법을 CBV,FBV로 나눠볼 수 있다. 우리가 저번에  데코레이터를 이용해 처리한 방법이 FBV이며, 오늘은 CBV에 대하여 알아보자. 가장 기본적인  클래스를 상속하여 뷰 클래스를 …","fields":{"slug":"/Django(6)-request-response/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [6-DRF CBV(APIView부터 ViewSet까지)]","date":"April 15, 2023"}},"next":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}},"previous":{"fields":{"slug":"/Django(7)-Search&CORS/"}}},{"node":{"id":"edcd3751-d5fc-5f9a-9826-0c0da687ecfa","excerpt":"저번까지는 model의 구조를 DB schema에 적용하는 migration을 알아보았다. 오늘은 데이터를 저장하고, 저장된 데이터를 가져와서 사용할 때 필요한 개념인 직렬화에 대하여 알아보자! 어렵지만 이해를 해야 다음으로 넘어갈 수 있으니 매우 중요하다고 볼 수 있다. DRF Serializer 장고에는 기본적으로 이라는 것이 있지만, 앞으로는 DRF(Django Rest Framework)에서 제공하는 를 사용할 예정이다. DRF를 사용하는 이유 REST api 서버를 구성하기 위해 초점이 맞춰진 기능들이 많음 장고보다 코드의 중복을 줄이는 몇가지 클래스들이 제공됨 우선 가상환경에 DRF를 설치해준다. 그리고, settings.py의 INSTALLED_APPS에서 를 추가해준다. 참고로, INSTALLED_APPS에는 pip로 설치해준 것도 추가해야할 경우가 있고, manage.py startapp 등으로 만든 appConfig의 name도 들어가야한다. (모든 pip 모듈을…","fields":{"slug":"/Django(5)-serailizer-django-orm/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [5-serializer와 Django ORM]","date":"April 14, 2023"}},"next":{"fields":{"slug":"/Django(4)-migration/"}},"previous":{"fields":{"slug":"/Django(6)-request-response/"}}},{"node":{"id":"565611de-2914-5d4f-af5d-738fe5e83e69","excerpt":"저번에 item 을 정의하는 것까지 해보았다. 이를 우리의 MySQL server에 적용시켜보자! 해야할 일은 크게 3가지로 나뉜다. model 정의 / 수정 migration file 생성 DB에 적용(migrate) 이 흐름을 이해하는 것이 중요하며, 직접 해보도록 하자. migration file 생성 가상환경이 활성화 되어있는 상태에서 위의 명령어를 입력한다. 을 하면 해당 앱에 존재하는 모델의 변경사항 등을 위치에 저장해준다. (app_name이 없다면 전체 앱을 탐색) 실제 위의 명령어가 정상 수행되면  파일이 생성되었다는 메시지가 나오는데, 파일을 열어보면 다음과 같다. 이러한 파일을 직접 만들어서 관리할 수도 있지만, 장고의 manage.py는 버전별로 나누어 이에 대한 관리를 용이하게 해준다. migrate migration 파일은 아직까지 파이썬 코드단으로 변경사항 등을 기록한 것이고, 이를 DB에 진짜로 반영하기 위해서는 migrate를 수행해주면 된다. 위와 …","fields":{"slug":"/Django(4)-migration/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [4 - DB(migration)]","date":"April 14, 2023"}},"next":{"fields":{"slug":"/Django(3)-model/"}},"previous":{"fields":{"slug":"/Django(5)-serailizer-django-orm/"}}},{"node":{"id":"e34e2492-ff4f-5260-be49-839350a0dc0e","excerpt":"장고 모델 저번에는 localhost:8000/item/ 를 브라우저에 입력하면 응답하도록 하였다. 이번에는 item model을 정의하고, 이를 DB에 적용(migrate)시켜보자. django에서 제공하는 model은 우리가 다루는 데이터의 객체를 의미한다고 볼 수 있고, 하나의 모델 클래스는 관계형 DB에서의 한 table이라고 볼 수 있다. 우리 프로젝트에서 다루는 ”상품”을 정의해보자. item 모델 정의 field type(mysql) info item_id(pk) auto increment int 상품코드(1부터 증가) name varchar 상품명 price int(positive) 상품가격 stock_count int(positive) 현재 상품의 남은 수량 우선 간단하게 이정도만 정의해보도록 하자. 이러한 필드들은 언제든지 수정이 가능하며, 충돌이 생긴다면 이에 대한 해결책을 제시해주는 것도 장고의 장점이다! 위의 모델을 만들기 위해서는 item/models.py…","fields":{"slug":"/Django(3)-model/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [3 - Django model]","date":"April 13, 2023"}},"next":{"fields":{"slug":"/Django(2)-django-intro/"}},"previous":{"fields":{"slug":"/Django(4)-migration/"}}},{"node":{"id":"712a6369-c9cf-5e78-bf02-5ff42e5f5177","excerpt":"프로젝트를 시작하기에 앞서, 장고에 대하여 개략적으로 알아보고, 첫 장고 앱을 만들어보자! 장고란 장고는 간단하고 빠르게 웹 서비스를 구현할 수 있는 파이썬 기반의 웹 프레임워크이다. 다양하고 많은 기능들이 제공되지만, 우리는 프로젝트를 위한 기능들을 위주로 공부한다. 장고 서버가 http 요청에 대하여 응답을 하는 과정은 다음과 같다. urls.py (해당 app과 매핑) app의 어떤 기능을 사용할지 매핑 views.py 에서 로직의 결과를 리턴 장고 세팅 우선, 이 설치되어 있어야 한다. 프로젝트를 위한 디렉토리를 만들고, 아래와 같이 수행한다. 가상환경 만들기 다른 프로젝트들과 충돌이 나지 않게 해당 프로젝트를 위한 virtual environment가 구성되어야 한다. 가상환경에서 python library들을 설치하면 해당 환경에서만 유효한 독립적인 환경을 만들 수 있다. (참고로 깃으로 관리한다면 가상환경은 에다가 넣어놓는 것을 권장함) (guri-venv)로 시작하는…","fields":{"slug":"/Django(2)-django-intro/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [2-django 기초]","date":"April 12, 2023"}},"next":{"fields":{"slug":"/Django(1)-overall/"}},"previous":{"fields":{"slug":"/Django(3)-model/"}}},{"node":{"id":"c25f6b47-0620-527d-9513-e5ec469005fd","excerpt":"서비스 내용 이름은 마켓 구리! (좀 구리지만 이름을 붙혀놔야 기억을 잘하니까) 구독 상품과 일반 상품을 구매할 수 있는 마켓 웹서비스를 구축해보자. 판매자(관리자)가 물건을 등록하고, 사용자는 물건을 구매하거나 정기 구매를 하도록 한다. use case 아주 간단한 유즈케이스 다이어그램을 그려보았다. 비회원의 경우, 상품목록까지만 볼 수 있고, 회원이 되어야만 상품을 구매할 수 있도록 할 예정이다. 판매자는 상품을 등록하고 판매내역을 볼 수 있게 할 예정이며, 이는 관리자 페이지의 형식으로 제공할 예정이다. 서비스 구조 프론트엔드와 백엔드를 분리하여 개발/운영한다. 일단은 on-premise로 개발하고, 시간이 된다면 AWS와 같은 서비스에 올려 직접 배포해보자.  하나의 서버 컴퓨터라고 생각하고, nginx와 같은 웹서버를 두어 요청에 따라 front 또는 api 서버에 요청을 전달하고 이에 맞는 응답을 해주도록 구성하였다. 규모가 커질수록 역할에 따라 서버컴퓨터(혹은 클라우드…","fields":{"slug":"/Django(1)-overall/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [1-서비스 기획 및 설계]","date":"April 11, 2023"}},"next":{"fields":{"slug":"/Django(0)-init/"}},"previous":{"fields":{"slug":"/Django(2)-django-intro/"}}},{"node":{"id":"376d81e6-a8ee-5dcb-8dec-4337de0416a9","excerpt":"계기 방학동안 서비스를 운영하기 위해 api 서버로 장고를 사용하였다. 우리 서비스에서 장고를 사용한 가장 큰 이유는, 비스니스 로직에서 필요한 라이브러리가 파이썬에서만 사용가능했기 때문이다. 물론, 해당 역할을 별개의 서버로 분리하는 방법도 가능하지만, 장고는 복잡한 설정 없이 admin page를 구현할 수 있으므로 시간 단축에도 용이할 것 같아 선택하였다. 풀스택으로 단기간에 완성해야 하는 입장이였으므로 정리를 할 필요를 느껴, 장고를 다시 복기해보려고 한다. 또한, 장고에서 REST 서버를 위한 많은 클래스와 기능이 제공되는 DRF를 도입하여 많은 것들을 개선해보도록 하자. 간략한 소개 이 프로젝트에서는 간단한 회원제 쇼핑몰 페이지를 만들어보며 장고에 대하여 정리해보고자 한다. 서버는 api server로, 를 이용하여 구축할 예정이고, 프론트엔드는 로 간단하게 만들어볼 예정이다.! 서버 코드 링크 : https://github.com/choieastsea/market-gu…","fields":{"slug":"/Django(0)-init/"},"frontmatter":{"categories":"BE","title":"(Django) 장고 api 서버를 이용한 프로젝트 [0-시작]","date":"April 11, 2023"}},"next":{"fields":{"slug":"/FE-React-VDOM/"}},"previous":{"fields":{"slug":"/Django(1)-overall/"}}},{"node":{"id":"b1a7cbae-d422-5854-a437-30b308f2df7a","excerpt":"기존 브라우저의 DOM 트리를 어떻게 처리하는지 간단하게 알아보고, react의 Virtual DOM이 어떤 방법으로 개선하려고 했는지 알아보도록 하자. (일부 정확하지 않을 수 있음) 브라우저에서 페이지를 보여주는 과정 기존 브라우저에서 html, css, js, 각종 정적인 파일들로 구성된 페이지를 보여주는 아주 개략적인 과정은 다음과 같다. 우선, HTTP 프로토콜을 통한 리소스 요청 등(url을 입력한다던가, 특정 버튼을 누른다던가)에 의하여 서버로부터 위의 파일들을 받는다. 브라우저는 렌더링엔진(ex. Gecko, webkit 등 브라우저마다 상이)의 html parser를 이용하여 HTML tag에 각각 대응이 되는 (Document Object Model) tree를 만든다. 또한 CSS parser를 이용하여 (CSS Object Model) tree를 만들고 이를 합쳐 를 만든다. 파싱이 다 되고 나서야 render tree를 만드는 것은 아니고 되는대로(네트워크를…","fields":{"slug":"/FE-React-VDOM/"},"frontmatter":{"categories":"FE","title":"(React) Virtual DOM에 대하여 알아보자","date":"March 12, 2023"}},"next":{"fields":{"slug":"/FE-JS-type/"}},"previous":{"fields":{"slug":"/Django(0)-init/"}}},{"node":{"id":"7df92e5c-18d2-56fc-b495-408cfe132637","excerpt":"JS 타입 우리는 타입을 크게 신경쓰지않으며 변수를 선언하지만, 실제 js에서는 크게 7가지 타입이 있다. 타입에 따라 js엔진이 저장, 처리하는 방법이 다르고 결과에 영향을 미치기에 우리는 타입에 대하여 알 필요가 있다. js 변수에는 주소가 할당된다. 변수는 결국 사람이 보기 위해 만든 ‘식별자’이며, 변수는 어떠한 값을 갖는 주소로 대치된다. 여기서는 구체적으로 js가 stack, heap의 공간에 적재하는 방법보다는 그 값들을 어떻게 사용하는지, 즉 타입에 대한 정책을 공부해보고자 한다. 원시 타입(Primitive type) -> immutable Boolean Null Undefined Number BigInt String Symbol 위의 타입들은 원시 타입에 해당하며, 원시값은 불변하다. 불변한 값들은 바뀌지 않고, 대입 연산자(=)를 통하여 새로운 값이 할당 된다. 여기서 말하는 값은 변수가 가리키는 주소에 적혀있는 내용! 그걸 값이라고 생각하자. a는 새로운 값(…","fields":{"slug":"/FE-JS-type/"},"frontmatter":{"categories":"FE","title":"(JS) 자바스크립트 타입","date":"March 05, 2023"}},"next":{"fields":{"slug":"/deploy-2-drf_signup/README/"}},"previous":{"fields":{"slug":"/FE-React-VDOM/"}}},{"node":{"id":"63f88978-7671-5bed-a256-0aebaa0739cb","excerpt":"웹서비스의 기본인 회원가입부터 해보자. nest js로 하려다가 db 구축이 매우 쉽다고 판단되는 (Django Rest Framework)를 이용하여 만들어보려고 한다. 회원가입 시, 서버의 요구사항은 회원들의 정보를 구분되도록, 추가적으로 안전하게 저장하는 것이다. 장고 세팅 장고에 대하여는 이전글을 참고해보자. 나도 생활코딩님의 강의를 보고 약간의 블로그와 공식문서를 읽은 정도의 수준이니 따라올 수 있을 것이다. auth_project/settings.py에서 config(db 세팅) 해준다.  로 member app을 생성해준다.(회원에 대한 모듈)\nls >> auth_project   member  project_env\nsettings.py의 INSTALLED_APPS에 ‘member’ 추가해줘야 이후 만들 model을 인식할 수 있다. auth_project/urls.py 수정 ( 추가)\nmember/urls.py 생성하여 아래와 같이 작성해준다. member/views…","fields":{"slug":"/deploy-2-drf_signup/README/"},"frontmatter":{"categories":"WEB","title":"(배포) 웹서비스 배포하기 (2)(backend)회원가입과 암호화","date":"January 08, 2023"}},"next":{"fields":{"slug":"/DRF_serializer/"}},"previous":{"fields":{"slug":"/FE-JS-type/"}}},{"node":{"id":"bb64831b-04c3-554c-a783-af377795429b","excerpt":"Django를 이용하여 서버를 구축하는 과정에 있어서, model을 설계하고 Serailizer를 이용하여 데이터를 CRUD하면서 헷갈리는 개념을 공부해보았다. 우선, DRF는 설치되어 있어야한다. (가상 환경 만들고, drf project 생성하고, app 생성하고 실행하기) DRF 데이터 흐름 DB ↔ QuerySet/Model ↔ OrderdDict(ReturnDict) ↔ JSON 우리가 사용할 데이터는 보통 DB에 테이블로서 존재하는데, 여기서는 하나의 테이블이 하나의 모델이 될 것이다. DB의 값을 바로 가져와 python 코드레벨에서 사용하는 것은 불가능하고, 위의 과정을 거쳐서 JSON으로 사용할 수 있게 된다. (역으로 JSON 데이터를 DB에 넣거나 수정할 때에도 마찬가지) DRF에서는 model에서 dictionary로 변환하는 과정을 (직렬화,,, 의역하여 객체화.?) 라고 정의하고, dictionary에서 model로 변환하는 과정을 라고 정의한다. DRF에…","fields":{"slug":"/DRF_serializer/"},"frontmatter":{"categories":"WEB","title":"(DRF) Django Rest Framework, Serialize 개념 이해하기","date":"January 03, 2023"}},"next":{"fields":{"slug":"/deploy-1-basic/"}},"previous":{"fields":{"slug":"/deploy-2-drf_signup/README/"}}},{"node":{"id":"b16b8c18-01f9-539f-9955-57e778d6453e","excerpt":"목표 CRA를 이용한  프론트 개발, 와 을 이용한 api 서버 개발 모두 할 줄 안다면, 이제 배포를 해볼 차례이다.! 배포까지 해보아야 웹 서비스가 어떤 식으로 구성되는지 알 수 있을 것 같아서 공부해보았고, 그 기록을 남기고자 한다. 목표는 다음과 같다. 클라우드 환경을 이용하여 웹서비스(풀스택) 배포하기 회원제 웹 서비스 풀스택으로 구현하기 docker 이용하여 배포 환경 구축하기 (optional) 도메인 구입해서 쉽게 접속하기 Web Service Architecture 출처: https://fractalideas.com/blog/making-react-and-django-play-well-together/ asdf 크게 4가지 방법이 있고, 각각에 대하여 이해해보자. 두개(front, api)의 서버를 두는 구조이다. client가 브라우저를 통하여 url(app.example.com)을 입력하면, front-server에서 이를 처리하여 html, css, js 파일…","fields":{"slug":"/deploy-1-basic/"},"frontmatter":{"categories":"WEB","title":"(배포) 웹서비스 배포하기 (1) 서비스 아키텍쳐","date":"December 30, 2022"}},"next":{"fields":{"slug":"/mac-setup-openmp/"}},"previous":{"fields":{"slug":"/DRF_serializer/"}}},{"node":{"id":"07f2f54e-ace1-532a-a1df-277dcd13e4d5","excerpt":"병렬프로그래밍 수업을 위해 를 mac os에 설치해야하는데, 헷갈려서 정리해놓는다. clang이 아닌 gcc로 실습환경을 구성하려고 한다.(mac의 gcc도 clang 계열이지만, 여기서는 몇가지 이유로 gcc로 진행한다) 로 설치하였고, 이것은 필수이다.! gcc 설치 및 버전 확인 나는 c++로 진행하였기에 gcc가 아닌 g++로 진행하였다. brew info 명령어로 gcc 컴파일러의 버전정보를 얻을 수 있다. openmp 실행 방법 우선, 소스코드에 이 main 함수 안에 선언되어 있어야 한다. 나는 다음과 같이 적어주었다. 그리고 컴파일 할 때,  옵션을 주면 되는데, 여기서 버전정보를 알 필요가 있다. 버전에 맞게 다음과 같이 컴파일해준다. 최종 확인 실행~ 실행환경의 Thread 수만큼 Hello World가 찍혀서 나오는 것을 볼 수 있다. 이러면 openmp환경이 세팅되었다고 보면 될 것 같다.  나의 경우, m1 pro칩이 들어간 mac book pro를 사용중인…","fields":{"slug":"/mac-setup-openmp/"},"frontmatter":{"categories":"블로그","title":"m1 mac에서 병렬프로그래밍을 위해 openmp 설치하기","date":"September 05, 2022"}},"next":{"fields":{"slug":"/CDS01-array-2/"}},"previous":{"fields":{"slug":"/deploy-1-basic/"}}},{"node":{"id":"5b0b9dd5-ebb1-5e97-afe5-96b81e72e2d6","excerpt":"배열은 저번에 공부했듯이 고정된 크기의 연속된 주소에 저장된 자료구조이다. 배열도 저장하는 방법(위치, 정렬)에 따라 크게 4가지로 나눌 수 있다. 배열의 종류 데이터가 몰려있냐에 따라 packed 배열안의 데이터(의미있는)가 한쪽에 몰려있는 경우이다. unpacked 배열안의 데이터가 산발적으로 존재하는 경우이다. 빈 공간에는 의미없는 값이나, 특정 값(예를 들어 의미없음을 뜻하는 -1 등)이 들어가 있을 수 있다. 데이터가 정렬되어있냐에 따라 sorted 배열안의 데이터가 정렬되어(숫자면 값이 크거나 작은 순서대로) 있다. unsorted 배열안의 데이터가 정렬되어 있지 않다. (데이터의 크고 작음이 순서에 영향을 미치지 않는다) 두 기준으로 보았을 때 4가지 조합이 존재하는데, 배열에서 가장 중요한 연산인 , , 를 직접 구현해보면서 각 배열의 특징에 대하여 알아보도록 하자! (단, insert 또는 delete 시 배열 전체의 크기 변화는 없다고 가정) search는 해당 …","fields":{"slug":"/CDS01-array-2/"},"frontmatter":{"categories":"Alg","title":"(DS) 자료구조 정리 02- 다양한 종류의 배열 (packed~unpacked, sorted~unsorted)","date":"July 08, 2022"}},"next":{"fields":{"slug":"/CDS01-array-1/"}},"previous":{"fields":{"slug":"/mac-setup-openmp/"}}},{"node":{"id":"74408fa6-45a8-50c5-90bc-2d58f542b7aa","excerpt":"자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다. 수학적 귀납법 컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다. BASE : P(1)이 참이다. STEP : P(n-1) -> P(n)이 참이다. 따라서, 모든 자연수 n에 대하여 P(n)은 참이다. BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 P(n-1)이 참이라고 믿는 것인데, 이유는 무엇일까. P->Q의 의미 예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자. 100점을 맞고, 치킨을 사주었다. => 참 100점을 맞고, 치킨을 안사주었다. => 거짓 100점을 안맞았고, 치…","fields":{"slug":"/CDS01-array-1/"},"frontmatter":{"categories":"Alg","title":"(DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort","date":"July 01, 2022"}},"next":{"fields":{"slug":"/Alg-Dijkstra/"}},"previous":{"fields":{"slug":"/CDS01-array-2/"}}},{"node":{"id":"e1e5d260-58e0-58af-a974-6c589aef1c8d","excerpt":"Dijkstra(다익스트라) Algorithm은 그래프에서, 한 노드에서 출발하여 다른 노드로 가는 최단 거리를 구할 때 사용할 수 있는 알고리즘이다. 더 나아가, 출발해서 도착할 때까지의 최단 경로를 구할 수도 있다. 문제 설명 input : 첫줄에는 노드갯수와 엣지갯수, 두번째줄부터 엣지 정보(노드 번호 두개와 edge weight) output : 1번노드에서 n번노드까지의 최단 거리 ​\t(입력 예시) 그래프를 표현하는 방법 weighted graph를 표현하는 방법은 크게 두가지로 나눠볼 수 있는데, 노드~노드간의 관계이므로, 노드가 n개일때 n*n matrix를 만들고, cell에 weight를 적는다. 4번 노드와 3번 노드를 잇는 엣지의 길이가 5이면, 와 같이 표현하면 된다. 다만, 이는 두 노드를 잇는 여러 엣지가 존재할 때 구조의 변경이 불가피하다. 한 노드에 인접한 노드에 대하여 (weight, 노드번호)를 모든 노드마다 갖도록 한다. (노드번호, weight)…","fields":{"slug":"/Alg-Dijkstra/"},"frontmatter":{"categories":"Alg","title":"(Alg) 그래프 알고리즘 - Dijkstra와 최단 경로 출력","date":"May 28, 2022"}},"next":{"fields":{"slug":"/FE-input-custom-hook-ts/"}},"previous":{"fields":{"slug":"/CDS01-array-1/"}}},{"node":{"id":"e0bdf019-16fc-5372-b49e-2db69640ff06","excerpt":"react로 이것저것 할때마다 가장 귀찮은 것 중 하나가 input을 다루는 일이였다. 회원가입페이지 등을 구성하면서, input을 객체로 갖고 관리하지만 중복되는 코드가 매우 많아 귀찮다. 그래서 customHook을 만들어보았는데, 케이스에 맞게 적용할 수 있을 것 같아 업로드한다. 우선, 해당 hook에서 대응가능한 event는 다음과 같다. Text Input event Select event : mui를 이용하여 프론트를 구성하였기에 해당 이벤트를 처리하였음 check event 사용법은 다음과 같다. 우선, 인풋 객체와 초기화 객체를 만들어준다. react input component에 사용할 때, custom hook을 호출하여 state, setState function, onChangeFunction을 할당받는다 input 태그에 value는 , onChange는 으로 적어준다. 내가 주로 사용하는 mui에서도 편하게 사용이 가능하므로 input과 관련된 별도의 처…","fields":{"slug":"/FE-input-custom-hook-ts/"},"frontmatter":{"categories":"FE","title":"(React TS) 다양한 input을 다룰 수 있는 custom hook","date":"April 23, 2022"}},"next":{"fields":{"slug":"/ADsP-Review/"}},"previous":{"fields":{"slug":"/Alg-Dijkstra/"}}},{"node":{"id":"d992bf3f-f7f6-5d35-b6e4-c199d5db8768","excerpt":"ADsP 32회 시험을 본지 거의 한달이 되었는데 아직도 시험결과가 나오지 않아 까먹고 있었는데, 이런 문자가 도착했다. 바로 들어가서 확인했는데, 불합격이다…? 근데, 문자 내용을 다시보니, 아직 최종 결과 발표전이라 모두 “불합격”으로 표시된다는 것이였다!!(휴…) 그래서 ‘시험 결과 확인’ 버튼을 눌러보니  다행히 합격이다~ 응시료가 50000원으로 비싸서 다시 보지 않으려 했는데 다행이다. 아직 합격증은 나오지 않았지만, 짧게 시험 리뷰를 해보려고 한다. 준비기간 우선, 나는 고등학교 확률과 통계 과정을 이해정도만 하고 있는 사람이고, 현재 컴퓨터공학과에서 공부하고 있어 R 스크립트 작성에 부담을 가지진 않았다. 나는 한달간 준비를 했는데, 방학이라 평일에 23시간정도 하고 주말에는 쉬면서 했다. 마지막 주에는 4시간 넘게도 했다. 블로그에 기록하면서 공부하지 않았다면 23주면 가능할 것 같다고 생각한다! 추천 하는 자료 보통 기출문제를 많이 담고 있는 책을 하나 갖고 있는…","fields":{"slug":"/ADsP-Review/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 데이터분석준전문가 32회 합격 후기","date":"March 22, 2022"}},"next":{"fields":{"slug":"/Alg-Greedy/"}},"previous":{"fields":{"slug":"/FE-input-custom-hook-ts/"}}},{"node":{"id":"a31e2810-4fcd-59b5-a65f-0bd325e9597f","excerpt":"Greedy 알고리즘의 개념에 대하여 익히고, 문제를 몇개 풀어보는 시간을 가져보자. Greedy란 욕심쟁이기법이라고도 한다. 매 과정에서 최적 선택을 고르고, 이것이 곧 전체의 최적 선택이 되는 것을 의미한다. Greedy 문제의 증명 방법 문제를 greedy하게 풀어야겠다는 생각이 들면, 보통 문제의 제약 조건 안에서 최적의 선택을 수행하면 된다. 뭔가 그렇게 푸는게 맞을거 같은데, 확신하기 어려운(증명하기 어려운) 경우가 종종 발생하는데, 이는 간단하게 귀류적으로 생각하면 된다. A, B, … , C 중에서 현재 가장 최적의 A를 골랐다고 해보자. 만약 A를 선택하지 않고 다른 B나 C를 선택하였을 경우, A를 선택하였을 경우보다 더 좋은 답을 얻지는 못한다는 것을 보이면 된다. 따라서 A를 선택하는 것이 최적이고, 답이라는 결론을 얻을 수 있다. 문제 풀이 codeforces 734B B. Anton and Digits 2,3,5,6이 적혀 있는 카드들이 있을 때, 여기서 …","fields":{"slug":"/Alg-Greedy/"},"frontmatter":{"categories":"Alg","title":"(Alg) Greedy Algorithm. 그리디(탐욕) 기법으로 문제 해결하기","date":"March 19, 2022"}},"next":{"fields":{"slug":"/Alg-Prefix-Sum/"}},"previous":{"fields":{"slug":"/ADsP-Review/"}}},{"node":{"id":"6c91f294-9e28-56aa-b3f8-eb63842f97f9","excerpt":"prefix sum은 자주 등장하는 주제이고, 알고 있으면 매우 유용하다. 개념에 대하여 익히고, 문제를 몇개 풀어보는 시간을 가져보자. Prefix sum 이란 숫자형 데이터로 이루어진 배열에서, 현재까지의 원소들의 합을 의미한다. 예를 들어, a = [1,3,-5,2,7]의 prefix sum array를 구하면 P= [1,4,-1,1,8] 이다. 누적합이라고 보면 편할 것이다! Prefix sum 배열을 앞으로 P라고 부르겠다. prefix sum을 이용하여 구간합 구하기 몇가지의 특징이 있는데, 우선 P의 마지막 원소는 배열 원소의 총합이라는 것이다. 또한 구간의 합을 구할때, P를 이용하여 다음과 같이 구할 수 있다. a[3]~a[7]까지의 합은 P[7]-P[2]와 같다. 굳이 공식화 하자면, summation from a[i] to a[j] = P[j]- P[i-1] 라고 할 수 있겠다. 이는 구간의 합을 O(1)에 구할 수 있는 매우 좋은 방법이다! 물론 초기화하는데 …","fields":{"slug":"/Alg-Prefix-Sum/"},"frontmatter":{"categories":"Alg","title":"(Alg) Prefix Sum 부분합 문제 해결하기","date":"March 14, 2022"}},"next":{"fields":{"slug":"/FE-NextJS-2/"}},"previous":{"fields":{"slug":"/Alg-Greedy/"}}},{"node":{"id":"60ff4daf-5019-5625-93a4-ec86c0a0fe00","excerpt":"저번에 이어 Next js를 공부해보자! (공식사이트와 유튜브를 돌아다니며 공부했다) 오늘은 fetch하여 데이터 받아오기와 Next.js에서의 SSR에 대하여 공부해보려고 한다. 데이터 가져오기(react ) 저번에 공부한 내용으로는 간단하게 정적인 페이지를 만들어 보았는데, 오늘은 동적인 페이지를 만들어보자! index.js에서 영화 api를 가져와서 정보를 보여주도록 하자. 원래 리액트에서 하는 것 처럼, useEffect hook을 사용하여 페이지가 로드될때 데이터를 fetch해올 수 있다. flex로 간단하게 이미지 배치를 하였다. 사진에 hover event도 달아주었고, 결과는 아래와 같다. + 이미지 태그 그냥 img를 사용하면 Next.js에서 제공하는 가 권장된다는 경고 문구가 나온다. 이는 두가지 케이스로 나뉜다. 로컬 이미지 : public 폴더에다가 넣고 import해주면 된다. url등으로 경로가 설정된 외부 이미지 를 건드려줘야 하는데 공식문서에 나온대로…","fields":{"slug":"/FE-NextJS-2/"},"frontmatter":{"categories":"FE","title":"(React) NextJS 입문해보기 - (2) data fetching, localtunnel 이용하여 공개하기","date":"March 10, 2022"}},"next":{"fields":{"slug":"/FE-NextJS-1/"}},"previous":{"fields":{"slug":"/Alg-Prefix-Sum/"}}},{"node":{"id":"9a688842-eb40-50d7-b34e-347257440a0e","excerpt":"React로 웹사이트를 만드는 가장 대표적인 3가지 방법이 있는데, CRA, NextJS, Gatsby이다. 그중에서, Gatsby는 정적 페이지 생성에 대한 것이고, CRA는 가장 쉽고 입문하기 좋은 보일러 플레이트라고 알려져있다. 나도 CRA로만 리액트 공부를 했었는데, 라우팅, SSR, 코드 스플리팅 등의 세팅에 어려움이 있었다. 이에 반해, Next.JS는 리액트를 위한 프레임워크로 몇가지 규칙을 이해한다면 간편하게 기능을 이용할 수 있다. 또한 기본적으로 서버사이드렌더링(SSR)을 제공하여 이의 장점을 이용할 수도 있다. 이외에도 다양한 기능들이 제공되니 한번 시간 내서 배워보자! 오늘은 넥스트로 간단한 정적인 페이지를 만드는 방법에 대하여 공부해보겠다. Next.js Project 시작하기 우선, node js(12.22.0 이후)와 npm이 깔려 있어야 한다. 간단하게 만 해주면 된다! yarn의 경우, 을 해주면 된다. 프로젝트 기본 정보를 입력한 이후,  또는 로 …","fields":{"slug":"/FE-NextJS-1/"},"frontmatter":{"categories":"FE","title":"(React) NextJS 입문해보기 - (1)","date":"March 10, 2022"}},"next":{"fields":{"slug":"/ADsP-3-(3)-2/"}},"previous":{"fields":{"slug":"/FE-NextJS-2/"}}},{"node":{"id":"3140942d-5372-5876-9cee-3909ea6fb3a7","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 군집분석 비지도학습인 군집분석에 대해 학습한다. 군집분석을 통해 인사이트를 얻는 과정을 학습한다. 군집분석 군집분석이란 여러 변수로 표현된 자료들 사이의 유사성을 측정하고 유사한 자료들끼리 몇 개의 군집(cluster)으로 묶고 다변량 분석(상관분석, 회귀분석, 주성분 분석 등)을 활용하여 각 군집에 대한 특징을 파악하는 기법이다. 생물학에서의 종의 분류, 마케팅에서의 시장 세분화, 금융에서 산업 분석 등에 활용되며 같은 추천 서비스가 등장하는 기반을 제공하였다. 거리측도 변수가 연속형인 경우 유클라디안 거리(Euclidean) 두 점 사이의 가장 짧은 거리를 계산. 통계적이지 않고 수학적인 거리로 변수들의 산포정도를 감안하지 않는다. == 좌표계에서 점과 점 사이의 거리 맨하튼 거리(Manhattan) 길을 따라 갔을 때…","fields":{"slug":"/ADsP-3-(3)-2/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 3과목(데이터 분석) 3장. 정형 데이터 마이닝 (下)","date":"February 24, 2022"}},"next":{"fields":{"slug":"/ADsP-2-(2)/"}},"previous":{"fields":{"slug":"/FE-NextJS-1/"}}},{"node":{"id":"57436365-88f7-5a32-9a15-c159d50da15a","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 마스터플랜 수립 데이터 분석을 위한 마스터플랜을 수립하는 과정을 이해한다. 마스터플랜 수립 후 수행 과제를 도출하고 우선 순위를 정한 다음, 이행 계획을 수립하는 일련의 프로세스를 잘 숙지한다. 마스터플랜 수립 분석 마스터플랜이란 어떤 하나의 분석 프로젝트를 위한 전체 설계도와 같다. 분석방법론과 과제발굴 수행과정을 모두 아우르는 개념이다. 우선 하향식 접근법으로 분석 과제를 선정한 후, 분석과제의 우선순위를 결정하고 기업의 상황을 고려하여 분석 구현 로드맵을 수립한다. 분석 마스터플랜 수립 프레임워크 전략적 중요도, 비즈니스 성과 및 ROI, 분석과제의 실행 용이성을 기준으로 분석과제의 우선순위를 정한다. 분석과제의 우선순위와 함께 분석과제의 적용범위 및 방식을 정해야한다. 분석과제를 업무에 내재화할지, 분석 데이터를 내…","fields":{"slug":"/ADsP-2-(2)/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 2과목(데이터 분석 기획) 2장. 분석 마스터플랜","date":"February 23, 2022"}},"next":{"fields":{"slug":"/ADsP-3-(3)-1/"}},"previous":{"fields":{"slug":"/ADsP-3-(3)-2/"}}},{"node":{"id":"1e1e8a77-f2ae-56b5-afae-ff002c7c40ae","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 데이터 마이닝 데이터 마이닝의 기초 개념들을 학습한다. 분석모형 구축과 테스트를 위한 데이터 분할에 대해 학습한다. 데이터 마이닝 개요 데이터마이닝(Data Mining)은 방대한 양의 데이터 속에서 숨겨진 규칙, 패턴 등을 찾아내어 예측하거나 의사결정에 활용하는 것을 목적으로 한다. 가설과 검정의 과정이 선택적이라는 점에서 통계분석과 구분된다. 데이터 마이닝의 종류 데이터 마이닝 방법에 따라… 지도학습 vs 비지도학습 정답지가 주어지냐에 따라 나뉜다. 독립변수에 따라 종속변수가 있다면 지도학습으로 볼 수 있다. 지도학습 비지도학습 회귀(연속형) : 선형회귀분석, 의사결정나무, SVR, 신경망 모형, 릿지, 라쏘 군집 : K-means, SOM, DBSCAN, 병합 군집, 계층 군집연관 : Apriori 분류(범주형) : …","fields":{"slug":"/ADsP-3-(3)-1/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 3과목(데이터 분석) 3장. 정형 데이터 마이닝 (上)","date":"February 20, 2022"}},"next":{"fields":{"slug":"/Alg-BOJ-11279/"}},"previous":{"fields":{"slug":"/ADsP-2-(2)/"}}},{"node":{"id":"1ba33787-0d65-5547-85b1-f5f258c16047","excerpt":"이제 백준 문제를 풀어보려고 한다. 최대힙과 관련된 문제이다. 단순하게 최댓값만 뽑아서 리턴해도 되지만, 최대힙을 사용하라해서 문제에 맞게 다시 구현해보았다. 백준에서 JS를 사용하는 방법 백준에서는 node js만 가능하고, 입력을 file system을 통하여 받아야한다. 따라서 기본적으로 모듈의 으로 가져오며 이후에 입력에 따라 재가공하면 된다. 나는 로컬에 stdin.txt파일을 만들어서 테스트한 후 제출하였다. 최대힙 최대힙은 부모 노드의 값이 자식노드의 값보다 크거나 같은 완전이진트리이다. 0번째 인덱스가 인 배열로 자식과 부모간 인덱스 이동이 가능하므로 간단하게 구현 가능하다. 런타임에러가 나서 사례를 검색하였는데, console.log()를 여러번 해주지 말고 버퍼에 넣어놨다가 마지막에 출력만 해주니 해결되었다!","fields":{"slug":"/Alg-BOJ-11279/"},"frontmatter":{"categories":"Alg","title":"(Alg) 백준 11279 최대힙 JS","date":"February 19, 2022"}},"next":{"fields":{"slug":"/full-stack-in-js/"}},"previous":{"fields":{"slug":"/ADsP-3-(3)-1/"}}},{"node":{"id":"f6ef8e8f-999b-58d3-89ab-bab4c4f24f10","excerpt":"Web service with JavaScript(React and Express Js) + MySQL 자바스크립트로 프론트와 백엔드를 모두 구축해보며 웹서비스에 대한 전반적인 이해도를 높여보자! 개발 환경 아직 번들러를 다룰 줄 모르기에 간단하게 CRA로 웹서버를 구축해보았다. SQL도 할 줄 모르지만, 이 기회에 하면서 배워보도록 하자! React.js with Create React App () https://create-react-app.dev/ 을 참고한다. Express.js Node.js 기반의 웹 서버를 구축할 수 있도록 만들어진 framework로 순수 Node.js로 서버를 구축하는 것보다 훨씬 편한 기능을 제공한다. MySQL 관계형 DBMS로, SQL 쿼리를 통하여 데이터를 가져온다. api를 통하여 웹서버와 연동되어 CRUD를 수행하게 될 것이다. 설치 환경 node js & npm 와 로 확인 가능 MySQL 설치되었다면 로 MySQL server 실행 가…","fields":{"slug":"/full-stack-in-js/"},"frontmatter":{"categories":"WEB","title":"(WEB) 자바스크립트로 풀스택 환경 구축하기(feat mysql2)","date":"February 17, 2022"}},"next":{"fields":{"slug":"/ADsP-3-(2)-2/"}},"previous":{"fields":{"slug":"/Alg-BOJ-11279/"}}},{"node":{"id":"b0070ddb-50be-5b5e-8200-8fe6b2878c3f","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 회귀 분석 인과관계를 규명하고 예측하는 회귀분석의 개념에 대해 학습한다. 최적회귀방정식을 통해 모형의 성능을 높이는 방법을 숙지한다. 회귀분석 개요 회귀분석이란 하나 이상의 독립변수들이 종속변수에 얼마나 영향을 미치는지 추정하는 통계기법이다. 회귀분석을 이용하여 원인과 결과 사이의 인과관계를 알 수 있으며, 나아가 회귀함수를 이용하여 예측도 가능하다. 회귀분석의 가정(암기!) : 분산분석의 가정 + 선형성 추가 성질 설명 선형성 - 독립변수와 종속변수가 선형적이여야 한다- 예외적으로 2차함수 회귀선을 갖는 다항회귀분석에는 선형성을 갖지 않아도 된다- 산점도를 통해 분석하기 전에 변수 사이의 관계를 짐작할 수 있어 회귀분석 하기 전 상관분석은 거의 필수적으로 함께 따라온다 독립성 - 단순회귀분석에서는 잔차와 독립변수의 값이 …","fields":{"slug":"/ADsP-3-(2)-2/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 3과목(데이터 분석) 2장. 통계 분석 (下)","date":"February 14, 2022"}},"next":{"fields":{"slug":"/ADsP-3-(2)-1/"}},"previous":{"fields":{"slug":"/full-stack-in-js/"}}},{"node":{"id":"10543c4c-a783-5fc7-a846-da4b09093773","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 통계의 이해 통계의 기초 개념에 대해 학습한다. 추정과 가설검정은 통계에서 매우 중요한 개념이므로 반드시 숙지한다. 통계 개요 표본 조사 예컨데, 우리나라 국민들에 대한 통계분석을 한다고 가정해보자.  ‘우리나라 국민’은 너무 규모가 커서 전수조사는 불가능하다고 볼 수 있다. 그렇기에 모집단을 대표할 수 있는 을 선별하여 를 실시한다. 표본집단은 모집단을 대표할 수 있는 집단이여야 하며 이를 이라고 한다. 표본의 대표성을 신뢰할 수 있어야 표본조사를 통한 모집단의 통계분석 결과 또한 신뢰할 수  있다. 신뢰수준 & 오차범위 신뢰수준 95%에 오차범위 ±3%라는 말은, 100번 조사했을 때, 오차 범위내에서 동일한 결과가 나올 확률이 95%라는 것이다. %와 %포인트 %의 차이를 비교할 때, %포인트를 사용한다. ex) 작년…","fields":{"slug":"/ADsP-3-(2)-1/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 3과목(데이터 분석) 2장. 통계 분석 (上)","date":"February 09, 2022"}},"next":{"fields":{"slug":"/ADsP-2-(1)/"}},"previous":{"fields":{"slug":"/ADsP-3-(2)-2/"}}},{"node":{"id":"03abc6dd-e0ef-58b2-81d8-683f57de4018","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 분석 기획과 분석 방법론 분석 기획 분석 대상과 방법에 따른 4가지 분석 주제(OIDS) 분석방법(How)과 분석대상(What)를 아는지에 유무에 따라 분석 주제가 달라진다. SECI와 마찬가지로 OIDS의 순서로 알아두자! how\\what known unknown known 최적화Optimization 통찰력Insight unknown 해결책Solution 발견Discovery 목표 시점별 분석 기획 과제 해결의 시점에 따라 분석 기획을 두가지로 나눌 수 있음 과제 단위: 빠르게 해결해야 하는 경우, 빠른 수행과 문제 해결이 목적 마스터플랜 단위: 정확도와 무엇이 문제인지에 대한 문제 정의가 목적 분석 기획시 고려 사항(!) 가용 데이터 고려 : 데이터 확보에 대한 고려, 데이터 타입에 대한 분석 적절한 활용 방안과 유스…","fields":{"slug":"/ADsP-2-(1)/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 2과목(데이터 분석 기획) 1장. 데이터 분석 기획의 이해","date":"January 31, 2022"}},"next":{"fields":{"slug":"/ADsP-3-(1)/"}},"previous":{"fields":{"slug":"/ADsP-3-(2)-1/"}}},{"node":{"id":"5d2b3ccb-1112-5ef8-9f84-6831644f2da3","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ R 기초 (이번 장은 너무 자세하게 공부한다기 보단, R의 간단한 문법 메커니즘을 이해하고 함수를 익숙해질 정도로만 해도 될 것 같다) R 설치 → R Studio 설치(by ) 타입 함수로 해당 요소의 타입을 확인할 수 있다. 다음과 같은 종류들이 있다. 문자형 (character) ‘abc’,“abc”, … 숫자형 (numeric), double, integer, complex(복소수) 1, Inf, NaN(Not a number)… 논리형(logical) TRUE, FALSE, NA(not available, 결측값)… NULL 기본 연산자 대입 연산자: = <- <<- 등 방향에 따라 대입 위치가 달라질 수 있다. NA인지 판단하는 방법: is.na()로만 가능하다. ==로 판단 불가 몫 : %/%, 나머지 : %%…","fields":{"slug":"/ADsP-3-(1)/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 3과목(데이터 분석) 1장. R기초와 데이터 마트","date":"January 29, 2022"}},"next":{"fields":{"slug":"/ADsP-1-(2)/"}},"previous":{"fields":{"slug":"/ADsP-2-(1)/"}}},{"node":{"id":"cb22176c-6bb1-5952-999d-99cb48883ed0","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 빅데이터의 이해 빅데이터의 정의 큰 용량과 복잡성으로 기존 어플리케이션이나 툴로는 다루기 어려운 데이터셋의 집합을 의미한다. (다양한 기관 등에서 이에 대하여 다양한 정의를 내리고 있음) 빅데이터의 특징 == 기존 데이터와 차별되는 점 더그 래니의 3V (크기), (수집 및 처리 속도가 빨라짐), (다양성) 4V : 3V + Value(가치)/ Veracity(정확성) 방대한 양의 데이터에서 해당 데이터의 가치와 정확성(신뢰도)의 역할이 추가적으로 중요해졌다. 빅데이터의 출현 배경 데이터의 양적 증가, 산업계·학계의 변화, 관련기술(인터넷, 클라우드, 저장기술)의 발전 : 양적인 변화가 축적되면 질적인 변화가 이루어짐 클라우드 컴퓨팅은 결정적으로 빅데이터 처리 비용을 획기적으로 낮추었음 빅데이터의 기능과 변화 기능(빅데이터…","fields":{"slug":"/ADsP-1-(2)/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 1과목(데이터 이해) 2장. 데이터의 가치와 미래","date":"January 26, 2022"}},"next":{"fields":{"slug":"/ADsP-1-(1)/"}},"previous":{"fields":{"slug":"/ADsP-3-(1)/"}}},{"node":{"id":"e3d064b4-5905-5b17-b83d-69bf31d5654b","excerpt":"본 글은 본인이 ‘데이터 분석 준전문가’ 필기 시험을 준비하면서 개인적으로 작성하는 글이라 일부 이해가 되지 않고 부정확할 수 있음을 밝힙니다. 모두 화이팅^^ 데이터와 정보 데이터란 정의 객관적인 사실을 의미한다.(존재적 특성) 정보의 근거로 쓰인다.(당위적 특성) 유형 정성적 데이터 vs 정량적 데이터 : 집합으로 표현가능한지x/o (명확한지x/o) 정형 데이터, 비정형 데이터, 반정형 데이터 (정형 데이터) : csv, 관계형 DB의 table → 틀O, 연산O (반정형) : json, XML, 센서 데이터 → 틀O, 연산X (비정형) : img, video, 댓글… → 틀X, 연산X SECI model(암묵지와 형식지의 상호작용) 좌상단은 암묵지, 우하단은 형식지를 배치한다. 좌상단부터  SECI를 시계방향으로 작성해주면 완성 ↗ 암묵지 암묵지 ↘ 암묵지 Socialization(공통화) Externalization(표출화) 형식지 암묵지 Internaliztion(내면화)…","fields":{"slug":"/ADsP-1-(1)/"},"frontmatter":{"categories":"ADsP","title":"(ADsP) 1과목(데이터 이해) 1장. 데이터의 이해","date":"January 26, 2022"}},"next":{"fields":{"slug":"/my-plan/"}},"previous":{"fields":{"slug":"/ADsP-1-(2)/"}}},{"node":{"id":"58e58574-532c-58d8-b995-c3e9bc10bde6","excerpt":"드디어 블로그의 자잘한 오류들을 해결하였다. 사실 제대로 해결하지 못하여 다시 깃허브 저장소를 만들어서 클론해왔다(package-lock.json의 버전 충돌을 해결하라해서 했는데도 왜 해결이 안되는 거죠 ㅠ)… 깃허브에서 토큰으로 인증하여 저장소에 접근하는 것도 이번에 처음으로 해봤다. 앞으로 정기적으로 업데이트 체크를 해서 블로그 업로드가 먹통이 되는 일이 없도록 해야겠다. 블로그를 다시 동작하게 하면서 올해 나의 목표를 세워봐야겠다. 물론 계획세우기엔 늦었지만, 이 계획도 지킨다고 보장할 수 없으니까! (?) 웹 서비스에 대한 이해 React 나는 여태까지 가 곧 리액트인 줄 알았다. 는 리액트로 프론트엔드를 구성하기 위한 framework나 boilerplate에 가깝다. 이외에도 프론트를 리액트로 사용하는 프로젝트로는 ,  등이 있다는 것을 알게 되었다. 장단점을 고려하여 상황에 맞는 프로젝트를 사용하도록 해야겠다! 또한, 리액트에서 상태 관리를 하기 위해 사용하는 와 같…","fields":{"slug":"/my-plan/"},"frontmatter":{"categories":"블로그","title":"(2022) My Plan in 2022","date":"January 18, 2022"}},"next":{"fields":{"slug":"/FE-Webpack-2/"}},"previous":{"fields":{"slug":"/ADsP-1-(1)/"}}},{"node":{"id":"75b2f83b-37cb-5304-aaf9-7188e35f9e96","excerpt":"Webpack (2) config, mode와 loader 본 포스팅의 내용은 생활코딩님의 강의를 들으면서 간단하게 정리한 것입니다. webpack.config.js (웹팩 설정 파일) 만들어 설정해주기 웹팩에게 어떻게 번들링하는지 시키는 방법에 대한 것은 크게 두가지가 있다. 를 이용하여 명령어로 입력을 한다. 이전의 방법과 같이 등과 같이 명령어를 입력할 수도 있다. 하지만, 이는 번들링을 할때마다 어딘가에 명령어를 저장해놓거나 기억하고 있어야 한다. 설정 파일을 만든다. 웹팩 공식 document을 참고하여 파일을 작성하고 으로 번들링을 진행해줄 수도 있다. 간단하게 위의 내용을 설정 파일에다가 만들어보자. 파일이름을 라고 지었다면 간단하게 만으로 번들링이 된다. cli를 통하여 했을때랑 같은 결과가 나오게 되는 것을 확인할 수 있다. mode 설정하기 이전에는 아주 간단하게 웹팩설정을 해주었지만, 이라는 경고문구가 뜨는 것을 확인할 수 있다. 모드는 크게 developmen…","fields":{"slug":"/FE-Webpack-2/"},"frontmatter":{"categories":"FE","title":"(FE) Webpack (2) config, mode와 loader","date":"January 13, 2022"}},"next":{"fields":{"slug":"/FE-Webpack-1/"}},"previous":{"fields":{"slug":"/my-plan/"}}},{"node":{"id":"164cee99-59db-564e-ae2d-20184e5833e3","excerpt":"Webpack (1) 웹팩 기본 본 포스팅의 내용은 생활코딩님의 강의를 들으면서 간단하게 정리한 것입니다. 아주 간단하게 로컬 웹서버를 띄우는 방법 :  설치 후, 로 해당 디렉토리에서 웹서버 실행 가능! webpack-tutorial 폴더에  실행하여 노드 프로젝트로 세팅해주었다. 계기 : 리액트를 CRA없이 하려고 보니, 웹팩이라는 것이 있다는 것을 알게 되었다. 당연하게 생각하였던 과정들에 대한 이해를 통하여 발전할 수 있을 것이다! Why webpack? 많은 파일들이 모여 하나의 웹사이트를 만드는데, 다양한 문제가 발생할 수 있다. 기존 웹서비스의 문제점 1. 다양한 파일에서 충돌에 대응하기 어렵다.  이러고 를 통하여 로컬서버(localhost:8080)에 들어가보면 어떻게 보여질지 예상해보자. word라는 전역 변수는 hello.js에도 있고 world.js에도 존재하므로(confict 발생) 더 뒤에 선언된 world.js의 word로 덮어씌우기 될 것이다.  여러 …","fields":{"slug":"/FE-Webpack-1/"},"frontmatter":{"categories":"FE","title":"(FE) Webpack (1) 웹팩 기본","date":"January 12, 2022"}},"next":{"fields":{"slug":"/DS05-Heap/"}},"previous":{"fields":{"slug":"/FE-Webpack-2/"}}},{"node":{"id":"f83049d2-462d-55ec-b98f-2ddec347a1a4","excerpt":"Tree의 종류인 Heap에 대하여 알아보도록 하자. Heap (힙)이란  부모노드가 자식노드보다 큰(혹은 작은) 완전 이진 트리를 의미한다. 형제 노드간의 대소관계는 상관없이 오직 부모와 자식관의 대소관계만 보면 된다. 완전이진트리는 마지막 레벨을 제외한 모든 노드가 가득차있고, 마지막 레벨은 왼쪽부터 순서대로 채워져 있는 이진트리이다. 부모가 자식보다 큰 힙을 , 부모가 자식보다 작은 힙을 이라고 한다. 최대힙의 경우 모든 노드의 값 중 최댓값이 루트 노드로 오게 되며, 최소힙은 최솟값이 루트노드로 오게 되는 것이 자명하다. 이러한 힙의 속성을 이용하여 루트 노드를 반복적으로 하는 (힙 정렬)을 구현할 수 있다. 또한 우선순위에 따라 선순선출(?)이 되는(우선순위 큐) 추상자료형을 구현할 수 있다. 완전 이진 트리 구현 우선 힙의 구조적인 형태는 Complete Binary Tree(완전 이진 트리)이다. 이는 이전 게시글과 같이 노드간의 레퍼런스로 구현할 수도 있지만, 배열로…","fields":{"slug":"/DS05-Heap/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) Heap","date":"November 15, 2021"}},"next":{"fields":{"slug":"/DS04-Tree/"}},"previous":{"fields":{"slug":"/FE-Webpack-1/"}}},{"node":{"id":"19b36e89-13e5-59ef-85e9-e9ac1c6d5531","excerpt":"(트리)는 계층적인 구조를 나타내기 위한 자료구조이다. 나무를 뒤집어 놓은 듯한 구조로 보통 표현되며, 뿌리인 root node에서부터 자식 노드로 단방향으로 뻗어져 나간다. 파일 디렉토리가 트리의 경로와 같이 표현되어 있으며 (ex C>>Desktop>>Document>>index.md), ,   등에도 사용된다. 트리 위키백과 Tree 용어  root(루트) : 최상위 계층에 있는 노드. 한 트리에서 루트 노드는 유일하게 존재한다. level(레벨) : 루트에서 특정노드까지의 거리(엣지의 수) parent/child node(부모-자식 노드) : 한 노드와 직접 연결되어 있는 경우, 부모 자식 노드의 관계이다. 가리키는 노드가 부모, 아닌 노드가 자식 노드라고 보면 된다. sibing nodes(형재 노드) : 같은 부모 노드를 갖는 노드 height(높이) : 트리의 높이 ==  sub tree(서브 트리) : 한 노드를 기준으로 하는 트리. 트리를 재귀적으로 볼 수 있게 해…","fields":{"slug":"/DS04-Tree/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS)트리와 이진트리 탐색 Tree & Binary Tree traverse","date":"November 05, 2021"}},"next":{"fields":{"slug":"/FE-JS-copy/"}},"previous":{"fields":{"slug":"/DS05-Heap/"}}},{"node":{"id":"8b6696db-6098-577e-8a21-f90d144ae266","excerpt":"결론 복사 : 내용은 완전히 같지만, 주소는 완전히 다른 사본을 만들어내는 것 : 원본과 참조 공유가 있어 상황에 따라 문제가 생길 수 있는 복사, depth가 1인 복사 : 내용만 같고 모든 원소의 주소는 달라 원본과 완전히 독립된 복사 복사 판단방법 즉, 모든 원소의 내용은 같으면서 ===의 결과가 false가 나와야(다른 주소를 참조, 원본과 독립되어있다는 의미) 깊은 복사가 된 것이다. 같은 방법을 통하여 복사를 했더라도 객체의 깊이에 따라 얕은 복사가 될 수도, 깊은 복사가 될 수도 있다! 계기 React.js에서 state(상태)를 다루다보면 이라는 속성이 굉장히 중요 하게 여겨진다. 리액트에서 불변성이란, 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 의미한다. 새로운 값이라는 것은 원본과는 완전히 독립된 사본에서 변형이 이루어진 데이터이며, 이를 위해 깊은 복사의 개념을 익힐 필요를 느끼게 되었다. 사전 지식 Primitive type과 Refer…","fields":{"slug":"/FE-JS-copy/"},"frontmatter":{"categories":"FE","title":"(JS) 얕은복사와 깊은복사(shallow and deep copy) & aliasing","date":"October 24, 2021"}},"next":{"fields":{"slug":"/FE-React-hooks-2/"}},"previous":{"fields":{"slug":"/DS04-Tree/"}}},{"node":{"id":"ffd441a4-4019-57eb-90de-dea9ed0004e3","excerpt":"(React) Hooks (2) useCallback, useMemo 나는 여태까지 useState와 useEffect로만 모든 프로젝트를 진행하였다. 이제 기능구현은 되니까 성능 최적화를 해보도록 하자! useEffect는 특정 조건(변수의 값이 바뀌거나 마운트, 언마운트 되었을 때)에 일어날 행동들(side effects)을 수행하는 Hook이다. useCallback은 함수를 memoization시켜놓아 모든 렌더링 시 함수가 재실행되지 않고, 특정 조건시에만 함수를 반환하여 실행도록 한다. useMemo는 변수를 ~~ 배열인자에 들어있는 의존성이 바뀌었을때 실행되는 것은 같지만, useEffect는 안의 내용이 실행되고, useMemo는 안의 변수를 반환하고 useCallback은 안의 함수를 반환한다.","fields":{"slug":"/FE-React-hooks-2/"},"frontmatter":{"categories":"FE","title":"(React) Hooks (2) useCallback, useMemo","date":"October 22, 2021"}},"next":{"fields":{"slug":"/FE-React-hooks-1/"}},"previous":{"fields":{"slug":"/FE-JS-copy/"}}},{"node":{"id":"5ad2aee6-9e68-5a85-9917-d2af9e38d633","excerpt":"(React) Hooks (1) useState, useEffect Hooks는 함수형 컴포넌트에서 다양한 작업을 할 수 있도록 도와주는 함수이다. 기존에는 class형 컴포넌트에서만 가능했던 기능을 hook을 통하여 functional component에서 사용가능하게 되었으며, 로직을 재사용할 수 있게 되었고, 코드의 이해도를 높일 수 있게 되었다. 보통 hook은 , 와 같이 use~로 시작하는 경우가 많고, 리액트에서 제공하는 hook\n뿐만 아니라 customized 하여 사용할 수도 있다. 그 중 가장 기본적인 훅인 와 에 대하여 알아보자. useState 함수형 컴포넌트에서 state(상태)를 바꿔줄 수 있도록 하는 가장 기본적인 Hook이다. 의 인자로는 해당 state의 초깃값을 넣어주며, 로 구성된 배열을 반환한다. useState 사용법 우선 useState를 import하고 사용해야 한다. 다음 예제를 보도록 하자! 를 보면 value라는 이름을 갖고 초깃값이 …","fields":{"slug":"/FE-React-hooks-1/"},"frontmatter":{"categories":"FE","title":"(React) Hooks (1) useState, useEffect","date":"October 12, 2021"}},"next":{"fields":{"slug":"/DS03-ADT/"}},"previous":{"fields":{"slug":"/FE-React-hooks-2/"}}},{"node":{"id":"1f5b55d1-79b3-570b-83ef-83ed55f01a39","excerpt":"추상자료형에 대하여 공부해보고, stack과 queue에 대하여 알아보자. Abstract Data Type(ADT, 추상자료형) 스택은이다. 추상자료형은 자료구조를 추상화한 것으로, 구현보다는 기능에만 초점을 맞춘다. 를 배울 때 에 대하여 배운 적이 있을텐데, 이는 실제 구현된 것이 아니고 기능에 대한 메서드만 명시되어 있다. 이를 implement한 클래스가 정해놓은 기능을 구현하는 방식으로 되어있다. list, set, dictionary, stack, queue는 모두 추상자료형으로 정해진 기능만을 담고 있으며 다양한 방법으로 구현될 수 있다. 예를 들어 스택은 다양하게 구현할 수 있지만, 우리는 array를 이용하여 직접 구현해볼 것이다. Stack이란 Stack(스택)은 메모리의 끝에서만 operation이 이루어지는 선형 자료구조로, 차곡차곡 쌓아올린 형태를 생각하면 이해하기 편하다.  (물론 메모리가 저렇게 생기지는 않았을 것이다. 단지 스택을 그릴때 저렇게 표현한…","fields":{"slug":"/DS03-ADT/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS)ADT 추상자료형 - Stack & Queue","date":"October 09, 2021"}},"next":{"fields":{"slug":"/DS02-LinkedList/"}},"previous":{"fields":{"slug":"/FE-React-hooks-1/"}}},{"node":{"id":"d2a012e0-3dba-5c82-b90f-2a0682b200c8","excerpt":"LinkedList란 LinkedList(연결리스트)는 리스트라는 추상자료형을 구현하는 선형 자료구조 중 하나로, 끼리 참조를 통하여 연결되어 선형적인 형태를 이루고 있는 자료구조이다. Array는 크기가 정해져 있고 메모리에서 연속적으로 존재하였지만, 링크드 리스트는 각 노드에 데이터가 저장되어 있으며 이웃한 노드의 정보(주소)를 가리키고 있는 형태로 여러 데이터를 저장한다.  간단하게 위의 그림으로 Array와 LinkedList를 비교해볼 수 있다. 연결리스트에서는 데이터가 노드에 저장되며, 노드끼리의 연결관계가 존재한다. 또한 head와 tail은 각각 처음과 마지막 노드를 가리키고 있어 모든 노드에 접근할 수 있게 되는 것이다. 따라서 각 노드는 메모리상에서 연속적으로 존재할 필요가 없으며, 데이터의 자료형이 같을 필요도 없을 것이다. LinkedList 구현 요구 사항 LinkedList에서는 배열과 다르게 데이터를 에서 갖고 있도록 한다. 노드는 데이터를 갖고 있으며,…","fields":{"slug":"/DS02-LinkedList/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) LinkedList","date":"October 04, 2021"}},"next":{"fields":{"slug":"/DS01-ArrayList/"}},"previous":{"fields":{"slug":"/DS03-ADT/"}}},{"node":{"id":"85417fbe-3e19-5b0b-a846-28bfdfe681cb","excerpt":"언어마다 다른 자료구조 JavaScript의 Array의 MDN 설명을 보면 다음과 같다. 배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체입니다. JavaScript에서 배열의 길이와 요소의 자료형은 고정되어 있지 않습니다. 배열의 길이가 언제든지 늘어나거나 줄어들 수 있기 때문에 JavaScript 배열들은 밀집도가 보장되지 않습니다. JS의 Array는 key가 int type index인 이다. 배열은 length라는 특별한 프로퍼티를 갖고 있으며, 이와 관련된 함수가 제공된다. 배열의 길이는 정해져 있지 않으며 각 원소의 크기 또한 정해져 있지 않다. 메모리상에서 연속된 형식으로 저장되어 있다고 보장을 못하는 이다. C, Java의 Array는 크기와 타입이 정해져 있는 **정적배열(static array)**이다. 따라서 선언시에 메모리 공간이 할당되며 모든 원소의 타입이 고정되어 있다. 크기가 정해져 있으므로 요소의 삽입과 삭제가 …","fields":{"slug":"/DS01-ArrayList/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) ArrayList","date":"September 12, 2021"}},"next":{"fields":{"slug":"/how-to-md/"}},"previous":{"fields":{"slug":"/DS02-LinkedList/"}}},{"node":{"id":"a108727b-4453-5e00-8401-77b296782473","excerpt":"나는 에디터로 을 작성중이다. 툴에 따라 마크다운 문법이 조금씩 다르다고 알고 있다. 은 에디터에서 쉽게 사용할 수 있도록 고안된 방법으로, 읽고 쓰기 편하며 로의 변환이 편한 것이 장점이다. 웹사이트를 만들어서 글을 작성한다면, 일일이 HTML코드를 작성하기보다, 마크다운으로 작성한 후 HTML로 변환하여 업로드하는 것이 효과적이다. 나 를 운영한다면 ‘~.md’파일을 많이 접하게 될 것이다. 간단하게 문법을 알고 있으면 좋을 것 같아 정리해본다. markdown을 알기 위해서는 HTML의 간단한 태그들을 알고 있는 것이 좋을 것이다. md 파일이 아무래도 HTML을 고려하고 만들어진 형식이니까… HTML HTML 태그는 그냥 작성하면 된다. 모든 태그를 지원하지는 않는다. 애초에 HTML이 귀찮아서 markdown으로 작성하는 경우가 많은데, 굳이 HTML 문법을 사용할 필요는 많지 않아보인다. 가끔 줄띄우기같을 때는 사용해볼 수 있겠다. 이하는 내가 많이 작성하는 순서대로 적…","fields":{"slug":"/how-to-md/"},"frontmatter":{"categories":"블로그","title":"블로그를 위한 Markdown 작성법","date":"September 03, 2021"}},"next":{"fields":{"slug":"/DS00-start/"}},"previous":{"fields":{"slug":"/DS01-ArrayList/"}}},{"node":{"id":"ecfecc2e-61ee-57a4-a949-6cb53e7fa025","excerpt":"자료구조 도서관에서 책을 찾을 때를 생각해보자. 만약 ‘로미오와 줄리엣’책을 찾는다면,  순으로 찾는다. 도서관에서 책을 찾을 수 있는 이유는 도서관에서 일정한 기준으로 책을 구조화하였기 때문이다. 일정한 약속대로 짜여진 구조가 있으므로 누구나 원하는 책을 찾을 수 있게 된다.\n컴퓨터에 데이터를 저장할 때에도 일정한 구조에 맞게 데이터를 저장한다. 우리는 이를 라고 한다. 도서관의 책을 ‘출판일자’순으로 배치하였다면 우리는 찾기 힘들 것이다. 이와 같이 각 자료구조에는 더 나은(빠르고 편한) 방법이 존재할 수 있다. 데이터를 저장하고 관리하기 위해 사용하는 구조 자료구조는 데이터의 효율적인 접근 및 조작을 가능하게 해주는 저장 및 관리 방식이라고 볼 수 있다.\n우리는 상황에 따라 최선의 자료구조 선택을 통하여 효율적인 프로그램을 짤 수 있을 것이다! 자료구조의 종류  향후 학습 방향 상황에 따라 더 맞는 자료구조가 있으며, 우리는 이를 성능(시간, 공간 복잡도)으로 판단할 수 있어…","fields":{"slug":"/DS00-start/"},"frontmatter":{"categories":"Alg","title":"(자료구조 JS) 자료구조 시작","date":"September 03, 2021"}},"next":{"fields":{"slug":"/first-post/"}},"previous":{"fields":{"slug":"/how-to-md/"}}},{"node":{"id":"57e12155-0332-585f-a3eb-5992940c6021","excerpt":"블로그에 대하여 기존 jekyll을 이용한 블로그를 재편하면서 테마를 찾아봤는데, gatsby라는 정적 사이트 생성 툴을 이용한 경우도 많이 있다고 들었다. 그러다가 zoomkoding.com을 방문하게 되었고, 이 분이 정말 깔끔하게 블로그 테마를 만드셔서 이를 사용하게 되었다. 향후 방향 전공 공부 기록하기 자료구조 및 알고리즘 온라인 저지 문제 해결 프론트 엔드 공부하기  공부 컴포넌트 최적화 CRA 없이 리액트 프로젝트 만들기 Context, Redux와 같은 상태 관리 라이브러리 활용하기 SSR deep  자바스크립트 익숙해지기  공부 CSS flexbox, grid 등 기본적인 css tailwind, bootstrap과 같은 라이브러리 Browser와 통신 HTTP(s), 쿠키, DOM, BOM 등 웹서비스에 대한 전반적인 공부 PWA 검색엔진 최적화 서버 프로그래밍 프로젝트 실제 웹사이트 배포 github, prettier등 협업 툴 오픈 소스 만들어보기 블로그 카테…","fields":{"slug":"/first-post/"},"frontmatter":{"categories":"블로그","title":"gatsby를 이용한 블로그 첫 포스트","date":"September 01, 2021"}},"next":null,"previous":{"fields":{"slug":"/DS00-start/"}}}],"categories":["All","ALG","OS","BE","FE","WEB","블로그","Alg","ADsP"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}