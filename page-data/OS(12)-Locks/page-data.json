{"componentChunkName":"component---src-templates-blog-template-js","path":"/OS(12)-Locks/","result":{"data":{"cur":{"id":"db6352b0-91a9-5d92-91ca-fb220b7a3ec1","html":"<p>저번 글에서는 Process의 실행의 주체인 Thread에 대하여 공부하고, multi-thread computing 환경에서 CPU core의 수와 관계 없이 발생할 수 있는 문제인 <code class=\"language-text\">race condition</code>(경쟁 상태)에 대하여 경험하였다. 이는 <code class=\"language-text\">counter += 1;</code>의 저수준 명령어가 <code class=\"language-text\">atomic</code>하게 이뤄지지 않으며, 한 스레드가 실행중인 동안 <code class=\"language-text\">mutual clusion</code>(상호 배제)가 보장되지 않고 스케줄되기 때문이라고 배웠다.</p>\n<p>오늘은 <strong>여러 쓰레드가 동시에 특정 자원에 접근할 때, 공유되는 자원을 예상가능하게 관리하는 방법</strong>인 Lock 기법에 대하여 공부해보자.</p>\n<h1 id=\"locks\" style=\"position:relative;\"><a href=\"#locks\" aria-label=\"locks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Locks</h1>\n<p><code class=\"language-text\">counter = counter + 1;</code></p>\n<p>위의 코드는 <code class=\"language-text\">critical section</code>으로 지정되어야 하고, 이를 위해 <strong>lock variable</strong>을 도입한다. 락의 사용법을 간단하게 표현하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token class-name\">lock_t</span> mutex<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 전역변수로 락을 선언</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncounter <span class=\"token operator\">=</span> counter <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>lock 변수를 선언하고, 어떤 스레드에서 해당 <strong>lock을 얻어야만</strong> counter = counter + 1; 영역에 접근할 수 있다. 이후 unlock으로 락을 해제한다. 어떤 쓰레드가 락을 얻었다면 <strong>다른 쓰레드는 해당 영역에 접근하지 못한다</strong>(그동안 block되기도 한다). 이렇게 mutual exclusion을 구현할 수 있는 것이다.!</p>\n<h2 id=\"lock-구현하기좋은-lock의-조건\" style=\"position:relative;\"><a href=\"#lock-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0%EC%A2%8B%EC%9D%80-lock%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"lock 구현하기좋은 lock의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lock 구현하기(좋은 lock의 조건)</h2>\n<p>실제 lock은 어떤 메커니즘으로 구성되어 있을까?</p>\n<p>어떠한 lock을 평가하기 위한 조건은 세가지가 제안된다.</p>\n<ul>\n<li><strong>mutual exclusion</strong>을 보장</li>\n<li><strong>fairness</strong> : starvation 없이 공평하게 접근되어야 함</li>\n<li><strong>perfomance</strong> : thread나 cpu 수가 증가함에 따라 overhead 발생하는데, 적을수록 좋음</li>\n</ul>\n<p>이러한 lock을 구현하는 방법과 이를 위해 OS와 HW에서 지원해주는 일들을 알아보자.</p>\n<h2 id=\"1-controlling-interrupts\" style=\"position:relative;\"><a href=\"#1-controlling-interrupts\" aria-label=\"1 controlling interrupts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Controlling Interrupts</h2>\n<p>락을 획득한 쓰레드의 인터럽트를 막아야할까? <strong>그러면 편하지만, 문제가 생길 수 있다</strong>!</p>\n<ol>\n<li>한 프로그램이 시작하자마자 lock을 얻고 무한 루프를 호출하는 등 프로세서를 독점하는 문제가 생길 수 있다.</li>\n<li>멀티 프로세서 환경에서는 lock을 얻었고 해당 쓰레드의 인터럽트가 일어나지 않더라도, 다른 core에서 실행되고 있는 쓰레드는 critical section에 접근할 수 있다.</li>\n<li>lock을 위해 인터럽트를 중지하는 것은 최신 CPU에서 느리게 실행되는 경향이 있어 성능에 문제를 야기할 수 있다고 한다.</li>\n</ol>\n<p>따라서, 다른 방법을 찾아보자.</p>\n<h2 id=\"2-spin-lock-with-no-hw-support\" style=\"position:relative;\"><a href=\"#2-spin-lock-with-no-hw-support\" aria-label=\"2 spin lock with no hw support permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Spin lock with no HW support</h2>\n<p>인터럽트에 대한 컨트롤 없이 락을 한번 구현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">__lock_t</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token comment\">// 0 -> lock is available, 1 -> held </span>\n  mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// TEST the flag </span>\n  <span class=\"token punctuation\">;</span> <span class=\"token comment\">// spin-wait (do nothing) </span>\n\tmutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// now SET it! </span>\n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\tmutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>lock_t 구조체는 flag를 갖고, 1이면 누군가가 락을 acquire하여 접근하지 못하며, 0이면 락을 얻을 수 있는 상태이다.</p>\n<p>따라서, lock()함수는 위처럼 flag가 0이 될때까지 해당 쓰레드가 무한 루프를 돌며 기다리게 구현할 수 있다. 그러다가 락을 얻으면 flag를 1로 세팅하고 critical section을 수행하면 될 것이다. 이러한 방법을 <code class=\"language-text\">spin lock</code>이라고 한다. 그럴듯 하지만, 문제가 있다.</p>\n<ol>\n<li>\n<p>while 문에 mutual exclusion이 보장되지 않는다.</p>\n<p>flag가 0이 되어 <code class=\"language-text\">mutex->flag=1;</code>이 수행되기 직전에 context switching이 발생하게 되면 여러 쓰레드가 flag를 1로 세팅하고 락을 얻은 것처럼 행동하게 된다.! 즉, 상호 배제가 보장되지 않는다.</p>\n</li>\n<li>\n<p>while 문으로 상태를 계속 체크하는 것은 성능에 매우 좋지 않다! 한 쓰레드가 락을 얻지 못한다면 스케쥴되있는 동안 loop만 돌아야하므로 성능상 좋지 않다.</p>\n</li>\n</ol>\n<h2 id=\"3-hw-atomic-instructions-1-test-and-set\" style=\"position:relative;\"><a href=\"#3-hw-atomic-instructions-1-test-and-set\" aria-label=\"3 hw atomic instructions 1 test and set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. HW atomic instructions (1) Test-And-Set</h2>\n<p>mutual exclusion을 보장하기 위해 HW의 지원을 받으면 좀 더 편해질 것이다. 예를 들어, 다음의 Test-And-Set 함수가 하드웨어적으로 지원되는 atomic function이라고 가정해보자. (실제로는 회로로 구현되어 있을 것이고 아래 코드는 이해를 돕기 위함)</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>old_ptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> new<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">int</span> old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>old_ptr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// fetch old value at old_ptr</span>\n    <span class=\"token operator\">*</span>old_ptr <span class=\"token operator\">=</span> new<span class=\"token punctuation\">;</span> <span class=\"token comment\">// store ’new’ into old_ptr</span>\n    <span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span> <span class=\"token comment\">// return the old value</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>새로운 값을 대입하면서 이전 값을 리턴하는 함수이다. atomic하므로 한번에 처리된다고 가정하면 다음과 같이 활용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">__lock_t</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t\tlock<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token operator\">-></span>flag<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t\tmutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n</code></pre></div>\n<p>TestAndSet으로 spin lock을 구현하는 예제이다. 그렇다면 이를 위의 3가지 지표로 평가해보자.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">mutual exclusion</code>이 보장된다.</p>\n</li>\n<li>\n<p>여러 쓰레드가 동시 접근시, spin lock은 fairness에 대하여 신경쓰지 않는다.</p>\n</li>\n<li>\n<p>성능</p>\n<ul>\n<li>\n<p>단일 코어 성능</p>\n<p>락을 갖지 않은 다른 쓰레드들은 루프를 돌며 <u>계속 기다려야하므로 좋지 않다</u>.</p>\n</li>\n<li>\n<p>멀티 코어 성능</p>\n<p>락을 갖지 않은 다른 쓰레드들은 다른 코어에서 락을 얻으면 되므로 단일 코어보다 좋다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-hw-atomic-instructions-2-compare-and-swap\" style=\"position:relative;\"><a href=\"#4-hw-atomic-instructions-2-compare-and-swap\" aria-label=\"4 hw atomic instructions 2 compare and swap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. HW atomic instructions (2) Compare-And-Swap</h2>\n<p>다른 HW atomic function이 있다고 가정해보자. 아래는 이를 모사한 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">CompareAndSwap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> expected<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> new<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n\t<span class=\"token keyword\">int</span> actual <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>actual <span class=\"token operator\">==</span> expected<span class=\"token punctuation\">)</span> \n\t\t<span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> new<span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">return</span> actual<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Test-And-Set과의 차이점은 기존 값을 확인하고 expected와 일치한다면 바꾼다는 것이다. 그게 아니라면 아무것도 하지 않는다. 역시 아래와 같이 사용될 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSwap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token operator\">-></span>flag<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 flag가 0이라면 1로 바꾸고 락을 얻는 코드이다. 0을 리턴한다 락을 얻은 것이고, 1을 리턴한다면 누군가가 락을 이미 얻어 기다려야 할 것이다.</p>\n<p>CompareAndSwap 함수는 이후에 스핀 락 없이 동기화를 구현할 때 사용될 것이므로 알아두자.</p>\n<h2 id=\"5-spin-lock의-대체---sleeping-mutex\" style=\"position:relative;\"><a href=\"#5-spin-lock%EC%9D%98-%EB%8C%80%EC%B2%B4---sleeping-mutex\" aria-label=\"5 spin lock의 대체   sleeping mutex permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Spin Lock의 대체 - sleeping mutex</h2>\n<p>어쨌든 spinning은 시간적인 소모가 크다. 따라서, 무한루프를 돌며 기다리지 않고 deschedule되도록 (ready 상태가 되도록) 하는 방법이 제안된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token operator\">-></span>flag<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// CPU를 양보함</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 단일 프로세서 환경에서 기다리지 않고, state를 ready로 바꿈으로써 다른 thread가 진입(scheduled)할 수 있게 만들어준다.</p>\n<p>하지만, 단점 또한 존재한다. 단일 코어에서 100개의 쓰레드가 락을 얻기 위한 상황을 생각해보자.</p>\n<p>99%의 확률로 쓰레드는 yield하여 ready 상태로 가는 것을 반복하게 될 것이다. <strong>무한 루프를 돌지는 않지만, context switching에 대한 overhead가 크다</strong>. 또한 이는 fairness 측면에서도 좋지 않다.</p>\n<p>추가적으로, 운영체제(역시 프로세스지만, 독특한) 내부의 lock은 주로 spin lock으로 구현되어 있다고 한다. 왜냐하면 운영체제가 개입하는 시점에 yield를 하면 안되기 때문이다.! 또한, spin lock을 얻은 이후에는 interrupt를 실행하지 않고, blocking operation을 수행하는 코드를 절대 실행하지 않는다고 한다. (lock이 묶인 채로 잠들고, 다른 쓰레드는 lock을 기다리므로 deadlock 발생)</p>\n<h1 id=\"locks은-언제-어떻게-실행되어야-하는가\" style=\"position:relative;\"><a href=\"#locks%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"locks은 언제 어떻게 실행되어야 하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Locks은 언제, 어떻게 실행되어야 하는가</h1>\n<ul>\n<li>\n<p>한 프로세스에서 multi thread를 사용하는 경우, 어떠한 데이터에 접근하기 전 항상 lock을 얻도록 한다!</p>\n<ul>\n<li>따라서, 사용하는 함수가 <code class=\"language-text\">thread-safe</code>한지 알아보자! 만약 함수가 thread safe하다면 mutual exclusion이 보장되도록 구현되어 있다는 뜻이다.</li>\n</ul>\n</li>\n<li>\n<p>kernel data 역시 lock을 얻은 이후에 접근하도록 한다.</p>\n</li>\n<li>\n<p>Coarse-grained lock ↔️ Fine-grained lock</p>\n<p>모든 공유 변수에 대하여 하나의 락만 사용할 지, 변수마다 락을 사용할지 선택할 필요가 있다. fine-grained한 락이 좀 더 병렬성이 높을 것이다. 하지만, 너무 많아진다면 관리하기 어려워질 것이므로 적당한 것을 선택할 필요가 있다.</p>\n</li>\n<li>\n<p>OS는 lock에 대한 지원뿐이므로, 사용자가 lock을 올바르게 사용하기 위해서는 잘 알아봐야한다. 그렇지 않으면 문제가 생길 수 있다!</p>\n</li>\n</ul>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"저번 글에서는 Process의 실행의 주체인 Thread에 대하여 공부하고, multi-thread computing 환경에서 CPU core의 수와 관계 없이 발생할 수 있는 문제인 (경쟁 상태)에 대하여 경험하였다. 이는 의 저수준 명령어가 하게 이뤄지지 않으며, 한 스레드가 실행중인 동안 (상호 배제)가 보장되지 않고 스케줄되기 때문이라고 배웠다. 오늘은 여러 쓰레드가 동시에 특정 자원에 접근할 때, 공유되는 자원을 예상가능하게 관리하는 방법인 Lock 기법에 대하여 공부해보자. Locks  위의 코드는 으로 지정되어야 하고, 이를 위해 lock variable을 도입한다. 락의 사용법을 간단하게 표현하면 다음과 같다. lock 변수를 선언하고, 어떤 스레드에서 해당 lock을 얻어야만 counter = counter + 1; 영역에 접근할 수 있다. 이후 unlock으로 락을 해제한다. 어떤 쓰레드가 락을 얻었다면 다른 쓰레드는 해당 영역에 접근하지 못한다(그동안 block…","frontmatter":{"date":"December 07, 2023","title":"(OS) 운영체제 복습 [12. Locks]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(12)-Locks/"}},"next":{"id":"7ddd8ab6-bee4-537e-b771-8d7364afb737","html":"<p>저번까지 Virtualization에 대하여 공부했고, 오늘부터는 동시성/병행성 (Concurrency)에 대하여 공부해보자. 멀티 쓰레드 프로그램에서는 메모리 공간에 동시에 접근하는 상황이 일어나게 되는데, 이에 대해 운영체제는 충돌이 나지 않도록 몇가지 방법을 제공해주는데, 이것이 concurrency와 관련이 있다. 차근차근 알아보자.</p>\n<h1 id=\"thread\" style=\"position:relative;\"><a href=\"#thread\" aria-label=\"thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread</h1>\n<p><u>여태까지 우리는 단일 쓰레드 프로그래밍 환경</u>을 전제로 공부했다. 간단하게 복습해보면, 한 프로세스에 하나의 실행 흐름만 존재하는 것이다. 현재 실행되는 주소 공간 상의 위치를 알기 위하여 PC(Program Counter), SP(Stack Pointer)를 두어 프로세스의 실행을 관리한다.</p>\n<p>하지만, Process는 실행 중에 여러 Thread를 가질 수도 있다! 그럼 쓰레드가 뭐지?</p>\n<p>쓰레드는 프로세스에서 <strong>작업의 단위</strong>로, Process에서 필요한 부분만을 복사하여 실행되는 것이라고 볼 수 있다. 한 프로세스 내의 쓰레드들은 <strong>code, heap 영역은 공유하며, 독립적인 stack영역</strong>을 갖는다. 따라서, thread별로 독립적인 PC와 SP를 갖고 실행을 하게 될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABq0lEQVQoz3WS/2/SYBCH+///AUZ/0SUQEQyODQa4AVOZohtgYaVApRToN/kWxFhaxPYxLfvBuXHJ5XOXu3tyl/cVpKHEce2YYqNIvBgnlo9RaBQ4/XJKU2kSmh/4kW63W8pimbP6GclSkqPsEYmLBPl6ntx1julyijBdTJnMJpgLE83UIg9jfa5jz+0IFARBpJ7noX/XMWcmY2vMyBwxsScYMyPS9c81wtbbcsjCWgj7F1iVqpTbZbIfs6QraTIfMlFeEkv7DZ2Ng+/70VCokQf73HGcB0DVVFFtla7Wpa206Qw7qJaKYiis1iuEzWaD7wf3gHsIjwKDP8HBi1zXQ/Bc92BDWPsf6O9+P94c+Liui9DTLcrygJqq87bRpnAjRvG73hBpZDx4lJqiUf025qqvkavVqdz2+RT2ywNmqx8ILWVAqlIllr/gaTLNs9Qb4oUSry+vuJF7d98muDvJ5fz6K69K73lxkufJyxTPMzkS55ecVD9jzeYIq+USYzxCare4bYkMlD5Sq8VEG7JczO9tuNvtmNoWmjpAbDboyTI9uUNXkrANHcf5xV8NmZZA3YqXKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"threads\"\n        title=\"threads\"\n        src=\"/static/e510061b2aeabd2f68c2135fdf23b4cd/37523/threadspng.png\"\n        srcset=\"/static/e510061b2aeabd2f68c2135fdf23b4cd/e9ff0/threadspng.png 180w,\n/static/e510061b2aeabd2f68c2135fdf23b4cd/f21e7/threadspng.png 360w,\n/static/e510061b2aeabd2f68c2135fdf23b4cd/37523/threadspng.png 720w,\n/static/e510061b2aeabd2f68c2135fdf23b4cd/302a4/threadspng.png 1080w,\n/static/e510061b2aeabd2f68c2135fdf23b4cd/07a9c/threadspng.png 1440w,\n/static/e510061b2aeabd2f68c2135fdf23b4cd/387f2/threadspng.png 1518w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>왼쪽 그림은 기존 단일 쓰레드 프로그램의 Address space를 그려본 것이며, 오른쪽은 멀티 쓰레드 환경에 대한 그림이다. 멀티 쓰레드 환경은 독립적인 stack 공간을 부여받고, heap과 program code는 공유함을 볼 수 있다. code 영역은 정적이므로 쓰레드 마다 각각의 PC를 통해 공유되는 코드영역에 접근할 것이다.</p>\n<p>+) Heap영역은 왜 공유해도 상관없을까?</p>\n<p>heap영역에는 데이터가 산발적으로 존재하며, 동적으로 생성된 데이터는 그 데이터의 포인터를 갖는 형태로 heap 영역에 저장된다. 만약, 두 쓰레드에서 동적 변수를 만들었다면 같은 heap 영역일지라도 다른 주소를 가리키게 될 것이다.</p>\n<h2 id=\"process-vs-thread\" style=\"position:relative;\"><a href=\"#process-vs-thread\" aria-label=\"process vs thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process VS Thread</h2>\n<p>Thread는 Process를 일부 복사한 것이라는데, 과연 fork된 프로세스와는 어떤 차이가 있을까? fork는 부모 프로세스를 복사하여 새로운 프로세스를 만드는 system call인데, Thread를 생성하는 것과 차이를 비교해보자.</p>\n<ol>\n<li>\n<p>부모 프로세스 P가 자식 프로세스 C를 <strong>fork</strong></p>\n<ul>\n<li>\n<p>C는 P의 복사본이지만, 메모리 영역을 공유하지 않는 독립적인 address space을 부여받는다.</p>\n</li>\n<li>\n<p>P와 C가 소통하기 위해 IPC(프로세스 간 소통) 메커니즘이 필요하다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>부모 프로세스 P가 쓰레드 T1, T2를 <strong>execute</strong></p>\n<ul>\n<li>T1과 T2는 address space를 공유한다.</li>\n<li>공유 변수 또는 전역 변수를 통하여 T1과 T2가 소통할 수 있다. (쓰레드간 소통은 프로세스간 소통보다 간편함)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"왜-쓰레드가-필요할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%93%B0%EB%A0%88%EB%93%9C%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C\" aria-label=\"왜 쓰레드가 필요할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 쓰레드가 필요할까?</h2>\n<ol>\n<li>\n<p>Parallelism(병렬성) : 하나의 Process로 여러 CPU core를 활용할 수 있게 된다.</p>\n<p>↔️ Concurrency(병행성) : 여러 프로세스/쓰레드가 동시에 실행되는 것 처럼 보이는 것 (CPU core 수와 상관 없음)</p>\n</li>\n<li>\n<p>단일 코어 시스템이더라도, thread를 concurrently하게 사용하면 CPU가 한 쓰레드가 IO등으로 블락되는 동안 다른 일을 수행할 수 있을 것이다.</p>\n</li>\n</ol>\n<p>또한, 멀티 프로세싱 환경에 비해서 멀티 쓰레드는 자원을 공유하기에 가볍고, context switching에 소요되는 overhead가 적다! 따라서, 쓰레드를 통하여 프로세스의 효율성이 개선될 것이다.</p>\n<h1 id=\"scheduling-threads\" style=\"position:relative;\"><a href=\"#scheduling-threads\" aria-label=\"scheduling threads permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scheduling Threads</h1>\n<p>쓰레드도 프로세스와 유사하게 배타적으로 하나의 CPU core를 점유하여 실행된다. 이에 Thread 역시 스케줄링되며, 쓰레드의 context(PC, SP 등 registers)는 TCB(Thread Control Block)에 저장된다. (Process의 PCB는 적어도 하나 이상의 TCB를 갖는다)</p>\n<h2 id=\"thread의-종류\" style=\"position:relative;\"><a href=\"#thread%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"thread의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread의 종류</h2>\n<ol>\n<li>\n<p>kernel (level) thread</p>\n<p>Thread는 kernel에 의하여 관리되고 스케줄링되는데, 이러한 쓰레드를 <code class=\"language-text\">kernel thread</code>라고 하며 linux에서 생성하는 <strong>pthread는 kernel thread이다</strong>. 한 프로세스 내의 여러 쓰레드 중 하나가 blocking되더라도 다른 쓰레드가 스케쥴되어 실행될 것이다.</p>\n</li>\n<li>\n<p>user (level) thread</p>\n<p>모든 쓰레드가 kernel level thread는 아니다. <strong>라이브러리를 통하여 생성한 Thread</strong>는 <code class=\"language-text\">user thread</code>라고 불리며, 위와 달리 커널에서 관리하지 않는다. 따라서, user thread가 block되더라도 kernel은 모르기 때문에 전체 user thread들이 block될 것이다. 스케줄링, context switch가 없지만 그렇기에 blocking되지 않는다면 성능적으로 좋지만, 병렬적으로 수행하기 어렵다.</p>\n</li>\n</ol>\n<h2 id=\"thread-생성-코드\" style=\"position:relative;\"><a href=\"#thread-%EC%83%9D%EC%84%B1-%EC%BD%94%EB%93%9C\" aria-label=\"thread 생성 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread 생성 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">mythread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t<span class=\"token class-name\">pthread_t</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">int</span> rc<span class=\"token punctuation\">;</span> \n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: begin\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\trc <span class=\"token operator\">=</span> <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>rc <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\trc <span class=\"token operator\">=</span> <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>rc <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token comment\">// join waits for the threads to finish </span>\n\trc <span class=\"token operator\">=</span> <span class=\"token function\">pthread_join</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>rc <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\trc <span class=\"token operator\">=</span> <span class=\"token function\">pthread_join</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>rc <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>위 코드는 <code class=\"language-text\">kernel level thread</code>를 생성하는 코드이다.</p>\n<p><code class=\"language-text\">pthread_create</code>함수를 통하여 쓰레드를 생성할 수 있고, mythread 함수를 실행할 2개의 쓰레드가 생성될 것이다. 함수 return 이후에는 <code class=\"language-text\">pthread_join</code>함수를 통하여 wait하게 될 것이다.</p>\n<p>하지만, 이를 실행해보면 <strong>A,B의 출력 순서가 보장되지 않음</strong>을 알 수 있다.! 왜냐하면 kernel에 의하여 B를 출력하는 thread가 먼저 스케쥴되어 실행될 수도 있기 때문이다. 이처럼 프로세스 내부에서 생성되어 예측 불가능하게 스케줄링되는 쓰레드를 예상하기는 어렵다.</p>\n<h2 id=\"thread-공유-변수---race-condition\" style=\"position:relative;\"><a href=\"#thread-%EA%B3%B5%EC%9C%A0-%EB%B3%80%EC%88%98---race-condition\" aria-label=\"thread 공유 변수   race condition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread 공유 변수 - race condition!!</h2>\n<p>앞서, Thread간 소통에는 메모리 영역을 공유하고 따라서 IPC mechanism을 사용하지 않고 공유/전역 변수를 사용할 수 있다고 했다. 가장 대표적인 예시를 보며 이를 예측해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> <span class=\"token function\">mythread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> \n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s: begin\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1e7</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  \tcounter <span class=\"token operator\">=</span> counter <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span> \n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s: done\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token class-name\">pthread_t</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">;</span> \n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: begin (counter = %d)\\n\"</span><span class=\"token punctuation\">,</span> counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> “A”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token function\">pthread_join</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token function\">pthread_join</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: done with both (counter = %d)\\n\"</span><span class=\"token punctuation\">,</span> counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서도 A,B를 출력하는 쓰레드를 만들고 각각 counter 전역 변수에 1000만씩 더한다.</p>\n<p>하지만 <strong>단일 프로세서더라도</strong> 결과는 항상 2000만이 나오지 않는다..! 항상 2000만 이하의 값이 나오게 되는 것을 볼 수 있다. 왜 그럴까? 한번 어셈블리어 단위로 살펴보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAXklEQVQI142NSwrEIADFev9LKghKVUTrXxcpFmY/2YS3ybtKKcQYOd5789utNdZajDE45JwxxnDfN9ZahBB471FKkVLieR5671z8Sa0VrfUXdc4hpfxOj080hMCckxe9gZm7SuJPIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"counter_assembly\"\n        title=\"counter_assembly\"\n        src=\"/static/8a476c1902d2236d6a8e4a6d45b0f32f/37523/counter_assembly.png\"\n        srcset=\"/static/8a476c1902d2236d6a8e4a6d45b0f32f/e9ff0/counter_assembly.png 180w,\n/static/8a476c1902d2236d6a8e4a6d45b0f32f/f21e7/counter_assembly.png 360w,\n/static/8a476c1902d2236d6a8e4a6d45b0f32f/37523/counter_assembly.png 720w,\n/static/8a476c1902d2236d6a8e4a6d45b0f32f/302a4/counter_assembly.png 1080w,\n/static/8a476c1902d2236d6a8e4a6d45b0f32f/07a9c/counter_assembly.png 1440w,\n/static/8a476c1902d2236d6a8e4a6d45b0f32f/0d390/counter_assembly.png 1472w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>왼쪽의 코드는 오른쪽의 어셈블리어로 변환된다. <code class=\"language-text\">%eax</code>는 register를 의미한다. 즉,</p>\n<ol>\n<li>\n<p>레지스터의 값을 counter의 값으로 가져온다</p>\n</li>\n<li>\n<p>레지스터의 값을 1 증가시킨다</p>\n</li>\n<li>\n<p>counter의 값을 레지스터의 값으로 가져온다</p>\n</li>\n</ol>\n<p>가 순차적으로 수행된다.</p>\n<p>위의 코드처럼 2개의 쓰레드(T1, T2)가 실행된다고 가정해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNklEQVQoz42TiW6DQAxE+f9fRCIcCXcC4Qg3rp4rI1RRtZZGm12845m149R1LZ/PR7Ztk3Ec5fl8CmfrusqyLArOyrLUPM5B27aSpqn4vi9xHMv9ftfvzvv9PhKHYZAwDCWKIiXf910LvV4vybJM8yjAGQW4S/GmaZS06zpx5BQkF0WhpHmeS9/3SnwVkKF8nmcVwko4Zovg8u12U0JQVdVBiCoUA4JvqDaHqFNCpLuuqwRcugojOhP+lufgH1UAi38R2B5F5LPHxTRN3wpRRUPM0pnQfmONbgLeGDKcPR4PbQp7uq6EV7J/rkmSaOdtpQG8HeQ0BDJzp28YBIGquLJrlgCXeSIbKZyx2igpIQme5ymsyn8CcmCDDo6x4Q0AlSnAuwD+CTY2ptaU8J05pBlYZnQg/ALmwFbXlu7F2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"critical\"\n        title=\"critical\"\n        src=\"/static/a490f285fbb44a5674b7899e46abf12a/37523/critical.png\"\n        srcset=\"/static/a490f285fbb44a5674b7899e46abf12a/e9ff0/critical.png 180w,\n/static/a490f285fbb44a5674b7899e46abf12a/f21e7/critical.png 360w,\n/static/a490f285fbb44a5674b7899e46abf12a/37523/critical.png 720w,\n/static/a490f285fbb44a5674b7899e46abf12a/302a4/critical.png 1080w,\n/static/a490f285fbb44a5674b7899e46abf12a/ae953/critical.png 1132w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>T1에서 레지스터의 값이 51이 되었고, 3번 명령어인 51을 counter로 대입하기 직전에 interrupt가 발생했다고 가정하자.</p>\n<p>T2는 다시 50을 51로 증가시킬 것이다. 그러다가 다시 T1으로 순서가 오면 3번 명령어를 수행하게 되므로 다시 51을 대입하는 것이다.</p>\n<p>즉, <u>공유 변수를 변경시킬 때의 원자성이 지켜지지 않을 수 있다</u>!</p>\n<h3 id=\"race-condition--critical-section--mutual-exclusion--atomicity\" style=\"position:relative;\"><a href=\"#race-condition--critical-section--mutual-exclusion--atomicity\" aria-label=\"race condition  critical section  mutual exclusion  atomicity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Race Condition / Critical Section / Mutual Exclusion / Atomicity</h3>\n<p>이렇게 여러 쓰레드가 공유 자원에 접근하면서 의도하지 않은 결과를 얻게 되는데, 이를 <code class=\"language-text\">race condition</code>이라고 한다.</p>\n<p>race condition이 발생할 수 있는 코드 영역을 <code class=\"language-text\">critical section</code>이라고 한다. 우리의 경우 <code class=\"language-text\">counter += 1;</code>부분이 critical section이라고 볼 수 있다.</p>\n<p>따라서, 이 문제를 해결하기 위해 우리는 critical section은 항상 중간에 인터럽트가 나지 않고, <u>다른 쓰레드로 스케줄링될 수 없도록</u> <code class=\"language-text\">mutual exclusion</code>(상호 배제) 상태를 만들어줘야 한다. 즉, critical section의 원자성(atomicity)를 만들어줘서 해당 영역에는 한번에 실행되고 중간에 스케줄링되지 않도록 해야할 것이다.</p>\n<p>이것을 어떻게 만들고, 운영체제에서는 어떤 방법이 제안될까? 다음 시간에는 이를 위한 <code class=\"language-text\">Locks</code> 기법에 대하여 공부해보자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"December 04, 2023","title":"(OS) 운영체제 복습 [11. Threads and Concurrency]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(11)-Memory Allocation/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(12)-Locks/","nextSlug":"/OS(11)-Memory Allocation/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}