{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-167/",
    "result": {"data":{"cur":{"id":"8fe1d79e-afca-5825-b14c-e9c8484a4a7f","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 숫자 배열에서 index1와 index2의 원소의 합이 target이 되도록 하는 인덱스 쌍을 찾는 문제이다. <a href=\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ol>\n<li>\n<p>Brute Force</p>\n<p>for loop를 두개 돌면서, 합이 target이 되도록 하는 i와 j를 찾는 방법을 고려해볼 수 있다.</p>\n<p>하지만 이 방법은 <code class=\"language-text\">O(n^2)</code>이 걸릴 것이다. (실제로 시간초과가 난다)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 시간초과</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># find two index that sum of elements is equivalent to target</span>\n        <span class=\"token comment\"># numbers are non-decreasing order list</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                result <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> numbers<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> result <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> result <span class=\"token operator\">></span> target<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">continue</span></code></pre></div>\n<p>배열의 크기가 <code class=\"language-text\">3*10^4</code>까지 가므로, 최악의 경우 <code class=\"language-text\">9*10^8</code> 이 걸린다… 이를 줄이기 위해 투 포인터를 도입해볼 수 있다.</p>\n</li>\n<li>\n<p>Two Pointer</p>\n<p>배열이 정렬되어 있으므로, 전수탐색하지 않아도 된다. i&#x3C;=j 라면 nums[i] &#x3C;= nums[j] 임을 이용하자!</p>\n<ul>\n<li>nums[i] + nums[j]가 target보다 크다면, 값을 줄이기 위해 j를 앞당기고,</li>\n<li>target보다 작다면 i를 뒤로 보내면 될 것이다.</li>\n</ul>\n<p>물론, target보다 큰 경우에 i를 앞으로 보내도 되지만 그렇게 되면 경우의 수가 많아지므로 <strong>가장 큰 값을 내는 조합인 양 끝값으로 시작하여 방향을 고정할 수 있을 것이다</strong>.</p>\n</li>\n</ol>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>i, j를 양끝에서부터 최악의 경우 가운데에서 만나므로 <code class=\"language-text\">O(n)</code>에 처리 가능하다.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>추가적인 메모리는 배열의 크기와 무관하므로 공간 복잡도는 <code class=\"language-text\">O(1)</code>이라고 볼 수 있다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># find two index that sum of elements is equivalent to target</span>\n        <span class=\"token comment\"># numbers are non-decreasing order list</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span>\n        left <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        right <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n            result <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> numbers<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> result <span class=\"token operator\">></span> target<span class=\"token punctuation\">:</span>\n                right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> result <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>left<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>정렬 조건을 이용하면 조합에 있어서 더 효율적인 방법을 고려할 수 있으므로 유념하자!</p>","excerpt":"Intuition 정렬된 숫자 배열에서 index1와 index2의 원소의 합이 target이 되도록 하는 인덱스 쌍을 찾는 문제이다. 링크 Approach Brute Force for loop를 두개 돌면서, 합이 target이 되도록 하는 i와 j를 찾는 방법을 고려해볼 수 있다. 하지만 이 방법은 이 걸릴 것이다. (실제로 시간초과가 난다) 배열의 크기가 까지 가므로, 최악의 경우  이 걸린다… 이를 줄이기 위해 투 포인터를 도입해볼 수 있다. Two Pointer 배열이 정렬되어 있으므로, 전수탐색하지 않아도 된다. i<=j 라면 nums[i] <= nums[j] 임을 이용하자! nums[i] + nums[j]가 target보다 크다면, 값을 줄이기 위해 j를 앞당기고, target보다 작다면 i를 뒤로 보내면 될 것이다. 물론, target보다 큰 경우에 i를 앞으로 보내도 되지만 그렇게 되면 경우의 수가 많아지므로 가장 큰 값을 내는 조합인 양 끝값으로 시작하여 방향을 …","frontmatter":{"date":"August 27, 2023","title":"(Alg) LeetCode Top Interview 150 - 167. Two Sum II - Input Array Is Sorted","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-167/"}},"next":{"id":"5b09cc10-3279-5365-ac10-2e55df99beb3","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>주어진 문자열에서 숫자와 영어만(대문자는 소문자로) 남겼을 때, 팰린드롬(Palindrome, 좌우 대칭인 문자열)인지를 판단하는 문제이다. <a href=\"https://leetcode.com/problems/valid-palindrome/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>우선, 정규표현식을 이용하여 알파벳과 숫자를 제외한 문자열을 제거한 후, lowercase로 바꿔준다.</p>\n<p>이후 앞에서부터 오는 방향과 뒤에서부터 오는 방향을 비교하며 문자열의 대칭 여부를 판단하였다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>문자열을 제거하는 시간복잡도는 <code class=\"language-text\">O(n)</code>이며, 대칭을 판단하는 것 역시 <code class=\"language-text\">O(n)</code>에 수행이 가능하다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>새로운 문자열을 만들어서 처리하므로, <code class=\"language-text\">O(n)</code>의 공간복잡도를 가질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> re\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 1. remove non-alphanumeric and to lower case</span>\n        s <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span>sub<span class=\"token punctuation\">(</span><span class=\"token string\">r'[^a-zA-Z0-9]'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 3. isPalindrome?</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            forward <span class=\"token operator\">=</span>  s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            backward <span class=\"token operator\">=</span> s<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> forward <span class=\"token operator\">!=</span> backward<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span></code></pre></div>\n<p>forward와 backward가 한번이라도 다르다면 return 해주는 것이 더 빠르게 끝낼 수 있다.</p>\n<p>추가적으로, for loop 에서 절반만 돌아 시간을 아낄 수 있을 것이다.</p>","frontmatter":{"date":"August 27, 2023","title":"(Alg) LeetCode Top Interview 150 - 125. Valid Palindrome","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-125/"}},"prev":{"id":"b207f215-d203-5091-b441-0dc404142c60","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 두개의 Singly Linked List를 하나로 merge하는 문제이다. <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">링크</a></p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>둘 중 하나가 빈 배열이라면, 나머지를 그대로 리턴한다.</p>\n<p>둘 다 원소가 있는 링크드 리스트라면, 더 작은 원소를 붙이고, 더 작은 원소가 있던 링크드 리스트는 다음 노드를 가리키도록 갱신한다. 이를 반복한다.</p>\n<p>반복문 이후에 원소가 존재하는 리스트가 남아있다면, 결과 리스트에 이어붙여서 리턴해준다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n+m) => n,m 은 각각 두 링크드 리스트의 크기</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>기존 LinkedList를 head와 current를 이용하여 가리키도록 하였으므로, 공간복잡도는 크기에 따라 달라지지 않을 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> list1<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> list1 <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> list2\n        <span class=\"token keyword\">elif</span> list2 <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> list1\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># merge into sorted array</span>\n            <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> list2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                head <span class=\"token operator\">=</span> list1\n                list1 <span class=\"token operator\">=</span> list1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                head <span class=\"token operator\">=</span> list2\n                list2 <span class=\"token operator\">=</span> list2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            current <span class=\"token operator\">=</span> head\n            <span class=\"token keyword\">while</span> list1 <span class=\"token keyword\">and</span> list2<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> list2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># list1이 다음으로 연결되는 경우</span>\n                    current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list1\n                    list1 <span class=\"token operator\">=</span> list1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                    current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list2\n                    list2 <span class=\"token operator\">=</span> list2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token comment\"># list가 남아있는 경우, current에 이어 붙여줌</span>\n            <span class=\"token keyword\">if</span> list1<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list1\n            <span class=\"token keyword\">elif</span> list2<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> list2\n            <span class=\"token keyword\">return</span> head</code></pre></div>\n<p>결과 linkedlist는 head에서부터 시작한다. 그리고 루프를 돌며 list1와 list2 중 더 작은 값을 current에 이어주면 된다.</p>","frontmatter":{"date":"August 28, 2023","title":"(Alg) LeetCode Top Interview 150 - 21. Merge Two Sorted Lists","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-21/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-167/","nextSlug":"/Alg-LC-125/","prevSlug":"/Alg-LC-21/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}