{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/FE-React-hooks-2/",
    "result": {"data":{"cur":{"id":"ffd441a4-4019-57eb-90de-dea9ed0004e3","html":"<h1 id=\"react-hooks-2-usecallback-usememo\" style=\"position:relative;\"><a href=\"#react-hooks-2-usecallback-usememo\" aria-label=\"react hooks 2 usecallback usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(React) Hooks (2) useCallback, useMemo</h1>\n<p>나는 여태까지 useState와 useEffect로만 모든 프로젝트를 진행하였다. 이제 기능구현은 되니까 성능 최적화를 해보도록 하자!</p>\n<p>useEffect는 특정 조건(<strong>변수의 값이 바뀌거나 마운트, 언마운트 되었을 때</strong>)에 일어날 행동들(side effects)을 수행하는 Hook이다.</p>\n<p>useCallback은 함수를 memoization시켜놓아 모든 렌더링 시 함수가 재실행되지 않고, 특정 조건시에만 함수를 반환하여 실행도록 한다.</p>\n<p>useMemo는 변수를 ~~</p>\n<p>배열인자에 들어있는 의존성이 바뀌었을때 실행되는 것은 같지만, useEffect는 안의 내용이 실행되고, useMemo는 안의 변수를 반환하고 useCallback은 안의 함수를 반환한다.</p>","excerpt":"(React) Hooks (2) useCallback, useMemo 나는 여태까지 useState와 useEffect로만 모든 프로젝트를 진행하였다. 이제 기능구현은 되니까 성능 최적화를 해보도록 하자! useEffect는 특정 조건(변수의 값이 바뀌거나 마운트, 언마운트 되었을 때)에 일어날 행동들(side effects)을 수행하는 Hook이다. useCallback은 함수를 memoization시켜놓아 모든 렌더링 시 함수가 재실행되지 않고, 특정 조건시에만 함수를 반환하여 실행도록 한다. useMemo는 변수를 ~~ 배열인자에 들어있는 의존성이 바뀌었을때 실행되는 것은 같지만, useEffect는 안의 내용이 실행되고, useMemo는 안의 변수를 반환하고 useCallback은 안의 함수를 반환한다.","frontmatter":{"date":"October 22, 2021","title":"(React) Hooks (2) useCallback, useMemo","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-hooks-2/"}},"next":{"id":"5ad2aee6-9e68-5a85-9917-d2af9e38d633","html":"<h1 id=\"react-hooks-1-usestate-useeffect\" style=\"position:relative;\"><a href=\"#react-hooks-1-usestate-useeffect\" aria-label=\"react hooks 1 usestate useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(React) Hooks (1) useState, useEffect</h1>\n<p>Hooks는 함수형 컴포넌트에서 다양한 작업을 할 수 있도록 도와주는 함수이다. 기존에는 class형 컴포넌트에서만 가능했던 기능을 hook을 통하여 functional component에서 사용가능하게 되었으며, 로직을 재사용할 수 있게 되었고, 코드의 이해도를 높일 수 있게 되었다.</p>\n<p>보통 hook은 <code class=\"language-text\">useState()</code>, <code class=\"language-text\">useEffect()</code>와 같이 use~로 시작하는 경우가 많고, 리액트에서 제공하는 hook\n뿐만 아니라 customized 하여 사용할 수도 있다. 그 중 가장 기본적인 훅인 <code class=\"language-text\">useState</code>와 <code class=\"language-text\">useEffect</code>에 대하여 알아보자.</p>\n<h1 id=\"usestate\" style=\"position:relative;\"><a href=\"#usestate\" aria-label=\"usestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h1>\n<p>함수형 컴포넌트에서 state(상태)를 바꿔줄 수 있도록 하는 가장 기본적인 Hook이다. <code class=\"language-text\">useState</code>의 인자로는 해당 state의 초깃값을 넣어주며, <code class=\"language-text\">[state명, state를 설정하는 setter 함수]</code>로 구성된 배열을 반환한다.</p>\n<h2 id=\"usestate-사용법\" style=\"position:relative;\"><a href=\"#usestate-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"usestate 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState 사용법</h2>\n<p>우선 useState를 import하고 사용해야 한다. 다음 예제를 보도록 하자!</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">const [value, setValue] = useState(0)</code>를 보면 value라는 이름을 갖고 초깃값이 0인 state와 value를 set해주는 setValue함수를 useState가 리턴하게 된다. 보통 이를 <strong>비구조화 할당</strong><code class=\"language-text\">destructuring assignment</code>으로 받아서 처리한다. <code class=\"language-text\">const value = useState(0).value</code>…와 같은 결과를 낸다고 볼 수 있다.</p>\n<p>setter함수는 보통 이벤트 또는 state가 변경되어야 하는 상황에서 사용된다. 위의 예제에서는 button이 눌리면(onClilck) value를 +1씩 해주거나 -1씩 해주도록 하였다. 여기서 value는 가장 최근의 값을 가져오지만, <strong>asynchronously</strong>하게(비동기적으로) 실행되므로 연속적인 순서를 지켜줘야하는 경우에는 다음의 해결방법이 있을 것이다.</p>\n<ol>\n<li>\n<p>useEffect</p>\n<p>해당 state가 바뀜으로써 <code class=\"language-text\">side-effect</code>가 생기게 한다. 이는 순서를 부여할 수 있다는 의미이다.</p>\n</li>\n<li>\n<p><u><strong>callback함수 이용</strong></u></p>\n<p>위의 setValue를 <code class=\"language-text\">setValue((value)=> value +1)</code>와 같이 인자로 콜백함수를 넣어줄 수 있다. 이는 바로 직전의 value값을 가져와 setter를 수행하는 것으로 동기적으로 실행할 수 있다. 이는 useEffect안에서 <em>의존성 문제가 발생했을때도 생각할 수 있는 해결책이 될 것</em>이다.</p>\n</li>\n<li>\n<p>await 키워드 이용</p>\n<p>비동기적인 함수이므로 async~await를 사용하면 동기적으로 이후의 작업을 수행할 수 있을 것이다.</p>\n</li>\n</ol>\n<h2 id=\"state가-바뀌면-re-render-된다\" style=\"position:relative;\"><a href=\"#state%EA%B0%80-%EB%B0%94%EB%80%8C%EB%A9%B4-re-render-%EB%90%9C%EB%8B%A4\" aria-label=\"state가 바뀌면 re render 된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>state가 바뀌면 re-render 된다</h2>\n<p>state가 바뀌면서 리렌더링이 일어나고 그 이후에 비동기적으로 setState가 반영된다. 따라서, setState() 바로 뒤에 console.log()를 찍어보면 이전 state가 나오는 것을 확인할 수 있다.</p>\n<h1 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h1>\n<p>Effect Hook을 사용하면 함수 컴포넌트에서 <code class=\"language-text\">side effect</code>를 수행할 수 있다. side effect란, state를 바꿀 때 일어나는 일련의 tasks라고 보면 된다. 예를 들어 위의 예시에서, count를 console에다가 출력해보자. count가 바뀔때마다 console.log를 수행하는 side-effect를 발생시키는 것이므로 <strong>useEffect</strong>를 사용하면 된다! useEffect 역시 import해서 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//value가 바뀔때마다 값이 콘솔에 출력될 것이다.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>useEffect(callback, [state])의 구성으로 되어있는데, [state]는 <code class=\"language-text\">의존성배열(deps)</code>로 관찰할 states의 배열을 넣어주고, callback은 state들이 바뀌거나 마운트,언마운트되면 실행될 side-effect에 대한 함수를 넣어주면 된다.</p>\n<h2 id=\"useeffect-사용법\" style=\"position:relative;\"><a href=\"#useeffect-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"useeffect 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect 사용법</h2>\n<ol>\n<li>\n<p>마운트시에만 실행</p>\n<p>마운트는 처음으로 컴포넌트가 화면에 보이게 되는 시점을 의미하며, 뒤에 빈 배열을 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'마운트될때만 실행'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>컴포넌트가 처음 나타날때만 콘솔에 출력되고 이후에는 출력되지 않을 것이다. 컴포넌트의 초기화 등에 사용될 수 있다.</p>\n</li>\n<li>\n<p>특정 값 업데이트 될때만 실행</p>\n<p>의존성 배열에다가 관찰할 값들을 넣어주면 된다. 배열 안에는 state나 props로 전달받은 값 모두 사용 가능하다. 위의 Counter.js의 예시를 참고하자.</p>\n</li>\n</ol>\n<h2 id=\"cleanup-function\" style=\"position:relative;\"><a href=\"#cleanup-function\" aria-label=\"cleanup function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cleanup function</h2>\n<p>컴포넌트가 <strong>언마운트 되기 전이나, 업데이트되기 직전에 작업을 수행</strong>하고 싶다면 콜백함수에서 뒷정리(cleanup)함수를 반환해주면 된다. <u>업데이트 되는 상황에서는 (이전 effect에 대한)clean-up → update → side-effect 순으로 실행되며, 언마운트 되는 상황에서는 clean-up함수가 실행</u>된다.</p>\n<p>카운터의 예시에서 언마운트, 마운트를 버튼으로 처리할 수 있도록 추가해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//App.js</span>\n<span class=\"token keyword\">import</span> Counter <span class=\"token keyword\">from</span> <span class=\"token string\">\"./Counter\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isVisible<span class=\"token punctuation\">,</span> setIsVisible<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setIsVisible</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isVisible<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>isVisible <span class=\"token operator\">?</span> <span class=\"token string\">\"숨기기\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"보이기\"</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>isVisible <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">&lt;</span>Counter <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mount or update\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"clean up\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p><img src=\"../../../cnkspace/dcm20/artifacts/doxsupp/images/useEffect.png\" alt=\"실행화면\"></p>\n<p>업데이트가 일어날 때에도 이전 effect에 대한 clean-up이 먼저 일어나고, 업데이트와 side-effect가 실행이 되는 것을 확인할 수 있다.</p>\n<p>useEffect hooks은 이외에도 데이터를 fetching하여 가져오는 등 다양하게 사용된다. 이에 대하여 자세하고 어렵게 적어놓은 <a href=\"https://overreacted.io/ko/a-complete-guide-to-useeffect/\">글</a>을 읽어보도록 하자! 나도 아직 잘 이해가 가지 않는다ㅠ 다음에는 useMemo, useCallback, useRef와 함께 커스텀 훅을 만드는 방법에 대하여 알아보겠다.</p>","frontmatter":{"date":"October 12, 2021","title":"(React) Hooks (1) useState, useEffect","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-hooks-1/"}},"prev":{"id":"8b6696db-6098-577e-8a21-f90d144ae266","html":"<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<h2 id=\"복사\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC\" aria-label=\"복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사</h2>\n<p><code class=\"language-text\">복사</code>: 내용은 완전히 같지만, 주소는 완전히 다른 사본을 만들어내는 것</p>\n<p><code class=\"language-text\">얕은 복사</code>: <strong>원본과 참조 공유가 있어</strong> 상황에 따라 문제가 생길 수 있는 복사, depth가 1인 복사</p>\n<p><code class=\"language-text\">깊은 복사</code>: 내용만 같고 모든 원소의 주소는 달라 <strong>원본과 완전히 독립</strong>된 복사</p>\n<h2 id=\"복사-판단방법\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC-%ED%8C%90%EB%8B%A8%EB%B0%A9%EB%B2%95\" aria-label=\"복사 판단방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사 판단방법</h2>\n<p>즉, 모든 원소의 내용은 같으면서 ===의 결과가 false가 나와야(<strong>다른 주소를 참조, 원본과 독립되어있다</strong>는 의미) 깊은 복사가 된 것이다.</p>\n<p>같은 방법을 통하여 복사를 했더라도 <strong>객체의 깊이에 따라 얕은 복사가 될 수도, 깊은 복사가 될 수도</strong> 있다!</p>\n<hr>\n<h1 id=\"계기\" style=\"position:relative;\"><a href=\"#%EA%B3%84%EA%B8%B0\" aria-label=\"계기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계기</h1>\n<p>React.js에서 state(상태)를 다루다보면 <code class=\"language-text\">불변성</code>이라는 속성이 굉장히 중요 하게 여겨진다. 리액트에서 불변성이란, 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 의미한다. 새로운 값이라는 것은 <strong>원본과는 완전히 독립된 사본</strong>에서 변형이 이루어진 데이터이며, 이를 위해 깊은 복사의 개념을 익힐 필요를 느끼게 되었다.</p>\n<h1 id=\"사전-지식\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%A0%84-%EC%A7%80%EC%8B%9D\" aria-label=\"사전 지식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사전 지식</h1>\n<h2 id=\"primitive-type과-reference-type\" style=\"position:relative;\"><a href=\"#primitive-type%EA%B3%BC-reference-type\" aria-label=\"primitive type과 reference type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primitive type과 Reference type</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">자바스크립트의 자료형</a></p>\n<p>자바스크립트에는 <code class=\"language-text\">원시타입</code>(primitive type)과 <code class=\"language-text\">참조타입</code>(reference type)이 존재한다. 원시타입은 값 자체이며 메모리에 바로 저장된다. 참조타입은 원시타입을 제외한 나머지를 저장하는 방식으로, 메모리에 실제 값들이 저장되어 있는 주소가 저장되어있다. 참조타입에서 실제 값들은 Heap 메모리에 저장되어있다.</p>\n<h2 id=\"객체의-깊이depth\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B9%8A%EC%9D%B4depth\" aria-label=\"객체의 깊이depth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체의 깊이(depth)</h2>\n<p><code class=\"language-text\">{abc: 'xyz'}</code>의 깊이는 1이다.</p>\n<p><code class=\"language-text\">{foo:{bar:{baz : 'baa'}}}</code>의 깊이는 3이다.</p>\n<h2 id=\"대입연산자를-통한-복사--aliasing\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%9E%85%EC%97%B0%EC%82%B0%EC%9E%90%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%B3%B5%EC%82%AC--aliasing\" aria-label=\"대입연산자를 통한 복사  aliasing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대입연산자를 통한 복사 ↔ Aliasing</h2>\n<p>원시타입에서 다음 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> num2 <span class=\"token operator\">=</span> num1<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnum2 <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//2</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/798584e8-7421-4ced-8479-aa6a432fae77/Untitled.png\" alt=\"\"><img src=\"https://images.velog.io/images/choieastsea/post/da95333d-b559-4df9-a728-3c29f9bb2442/Untitled%201.png\" alt=\"\"></p>\n<p><strong>원시 타입</strong>에서는 대입연산자를 통하여 할당이 된다. 위의 예시처럼 num2의 값을 바꾼다면, num2가 새로운 값을 갖도록 재할당한다고 볼 수 있다. num2의 값이 바뀌었다고 num1의 값도 바뀌지는 않는다.</p>\n<p>그렇다면 참조타입에서는 어떨까? 다음 코드의 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">**</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token operator\">**</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//[1,4,[1,2,3]]</span>\n<span class=\"token comment\">//true</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/df74b351-8d27-4261-99e1-e98e36b5eae7/Untitled%202.png\" alt=\"\">\n<img src=\"https://images.velog.io/images/choieastsea/post/a88e5715-2902-47b6-ba2e-d65ff10c7a70/Untitled%203.png\" alt=\"\">\n하지만, <strong>참조 타입에서는 참조 공유</strong>가 된다. 위에서도 b는 새로운 메모리 공간이 아닌 a와 같은 주소를 공유하게 된다. 그렇게되면 사본인 b를 수정했는데 원본인 a도 바뀌는 것이다.</p>\n<p>원시 타입에서는 대입연산자를 통한 복사(깊은 복사)라고 볼 수 있지만, <em>참조 타입에서 대입연산은 복사라고 볼 수 없다</em>. 참조타입에서의 대입연산(=)은 copy가 아닌 <code class=\"language-text\">aliasing</code>이다. alias란 <code class=\"language-text\">별명</code>이라는 뜻으로, A와 B가 같은 객체를 가리키는 것을 의미한다. 예컨데, 손흥민과 우리흥은 말(내용)은 다르지만 같은 본질(사람)을 가리킨다. 이때 ‘우리흥’은 ‘손흥민’의 alias라고 볼 수 있다.</p>\n<h1 id=\"복사란\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC%EB%9E%80\" aria-label=\"복사란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⭐복사란?</h1>\n<p>이 페이지에서 말하는 <code class=\"language-text\">복사</code>란, aliasing(참조공유)과는 완전 다른 개념이다.(‘손흥민’과 ‘우리흥’처럼 같은 객체를 가리키는 것이 아님!) <strong><em>외형은(내용은) 완전히 같지만, 본질은(주소는) 완전히 다른 사본</em>을 만들어내는 것</strong>이 여기서 말하는 복사이다.</p>\n<p>참조타입에는 <strong>복사되는 depth(깊이)에 따라</strong> 얕은 복사와 깊은 복사가 존재한다. 각 방법을 익히고 적재적소에 사용하도록 해보자!</p>\n<h2 id=\"얕은복사\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC\" aria-label=\"얕은복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은복사</h2>\n<p>하나의 depth까지만 복사한다. 따라서 참조공유의 문제가 발생할 수 있다.</p>\n<p>객체나 배열의 깊이를 생각하지 않고 1차원적으로 원소들을 복사하여 새로운 변수에 넣어주면 얕은복사이다. 이는 일차원 객체에서는 깊은복사이지만, 깊이가 2 이상인 경우에는 위에서 본 참조공유의 문제(aliasing)을 일으킨다.</p>\n<p>js에서는 이를 위해 반복문을 이용한 직접 대입, slice 함수, ES6의 spread 연산자 등을 이용할 수 있다.</p>\n<ol>\n<li>\n<p>for문</p>\n<p>일일이 객체의 value(배열이라면 원소)를 넣어준다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">shallow_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends <span class=\"token operator\">=</span> <span class=\"token function\">shallow_copy</span><span class=\"token punctuation\">(</span>friends<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"2\">\n<li>spread 연산자(전개구문, …)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends_2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>friends<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>직관적이며 기존의 함수들을 포함한 기능들을 사용할 수 있기에 최근에 많이 사용되는 것 같다.</p>\n<ol start=\"3\">\n<li>\n<p>assign 함수, slice 함수</p>\n<p>전개연산자가 있는데 굳이 해볼 필요는 없을 것 같으니 인터넷에서 찾아보도록 하자.</p>\n</li>\n</ol>\n<p>위 코드의 결과로 복사가 잘 되어있을 것이다. 깊이가 1인 객체에 대하여 위 방법은 깊은 복사가 된다고 볼 수 있다!</p>\n<p>이제 일차원 배열 말고 다음과 같이 <strong>깊이가 2이상인 객체</strong>에 대하여 위의 복사를 진행해보자. 이름, 나이, 가족 구성원 배열을 갖고 있는 객체를 복사하려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> shallow_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token operator\">===</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> shallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">//사본의 값을 바꿔보자.</span>\nshallow_copy<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'another_name'</span><span class=\"token punctuation\">;</span>\nshallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//참조 공유로 인해 원본도 수정된다.</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/d4c1c9b7-ecf0-46dd-91d4-599f15a39040/Untitled%204.png\" alt=\"\">얕은 복사 직후의 상황\n얕은 복사를 하면 1차원적으로는 복사가 이루어졌지만, 깊이가 2인 family배열은 공유하고 있는 상태가 된다. 이 경우 문제 있는 <code class=\"language-text\">origin.family===shallow_copy.family</code>를 하면 true가 나온다.\n<img src=\"https://images.velog.io/images/choieastsea/post/21b6cf6f-66bc-4566-b0cd-eef19968d35f/Untitled%205.png\" alt=\"\">이는 참조공유의 문제가 생긴다. 배열의 원소단위로 값만 가져왔지만, <em>원소가 만약 또 참조 타입인 경우</em>에 다시 참조를 공유하는 문제가 생기게 되는 것이다. 이와 같이 <strong>참조의 문제가 여전히 남아있는 복사가 얕은 복사이다</strong>.  우리는 이를 떼어내서 완벽하게 독립된 사본을 만들어줄 필요가 있다. 위에서는 간단하게 push해주는 부분을  <code class=\"language-text\">shallow_copy.family = shallow_copy.family.concat('cat');</code>으로 바꿔 새로운 객체를 할당함으로써 문제를 해결할 수 있다.</p>\n<p>하지만 이렇게 문제가 생겨 수정하는 것보다, 복사를 할때부터 이러한 참조의 문제를 일으키지 않도록 하고 싶을 때 <code class=\"language-text\">깊은복사</code>를 이용할 수 있다.</p>\n<h2 id=\"깊은-복사\" style=\"position:relative;\"><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깊은 복사</h2>\n<p>깊은 복사를 위해서는 구조적으로 제일 깊숙한 참조타입까지 복사를 진행해주면 되는데, 깊이마다 얕은복사, 재귀함수, 라이브러리, JSON 함수와 같은 방법들이 존재한다.</p>\n<p>아래와 같이 바꾸면 깊은 복사에 성공한 것이다. family를 ===한 결과 false가 나올 것이다.\n<img src=\"https://images.velog.io/images/choieastsea/post/6bca52a9-8858-4455-a729-d9e126aaa506/Untitled%206.png\" alt=\"\"></p>\n<ol>\n<li>\n<p>깊이마다 얕은 복사 진행</p>\n<p>얕은 복사를 객체의 깊이별로 진행해주면 된다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> deep_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>origin<span class=\"token punctuation\">,</span> family<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> deep_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p>하지만 위의 경우는 깊이가 깊어지면 매우 귀찮아진다. 아래의 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              num<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            name<span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          something<span class=\"token operator\">:</span> <span class=\"token string\">'something'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      last<span class=\"token operator\">:</span> <span class=\"token string\">'dance'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//얕은 복사</span>\n    <span class=\"token keyword\">const</span> shallow_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//깊이마다 얕은 복사 진행</span>\n    <span class=\"token keyword\">const</span> deep_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">,</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">,</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">,</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow<span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n        object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> shallow_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//true -> 참조 공유</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>위는 너무 귀찮으므로, 깊이가 깊어질때에는 아래의 방법을 사용하자.</p>\n<ol start=\"2\">\n<li>\n<p>재귀함수</p>\n<p>재귀적으로 객체의 깊이까지 모두 복사를 해주면 된다. 이는 어느 객체에나 사용할 수 있는 범용적인 방법이 될 것이다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">deep_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\">//if element is object</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//not object => primitive type</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> deep_object_recursion <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_recursion<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span>\n</code></pre></div>\n<p>위의 deep_copy 함수를 사용하면 깊이에 제한 없이 깊은 복사를 진행할 수 있다. 재귀적으로 원소의 type이 object이면 한단계 들어가서 복사를 진행하는 방법이다.</p>\n<ol start=\"3\">\n<li>\n<p>라이브러리</p>\n<p>깊은 복사를 해주도록 도와주는 자바스크립트 라이브러리가 있다. lodash, immutable을 찾아보도록 하자.</p>\n</li>\n<li>\n<p>JSON.stringfy, parse 함수</p>\n<p>이는 일종의 hack으로, 성능은 느리지만 간단하게 깊은 복사를 할 수 있는 방법이기도 하다. 원래 <code class=\"language-text\">JSON.stringify</code>는 JSON객체를 string으로 변환시켜주고, <code class=\"language-text\">JSON.parse</code>는 string을 JSON으로 변환시켜주는 메서드이다. 여기서 (객체 → string → 객체)의 방법으로 새로운 복사본을 만들어주면 된다. 아까의 object 예시에 이어서 해보겠다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> deep_object_json <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_json<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>이 방법이 외부 라이브러리를 사용하지 않는다면 가장 간단한 방법이겠으나, 문자열로 바꾼 객체를 다시 객체로 만드는 시간이 많이 든다는 것을 알고 있어야 한다.</p>\n<h1 id=\"마무리복사alias복습\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%EB%B3%B5%EC%82%ACalias%EB%B3%B5%EC%8A%B5\" aria-label=\"마무리복사alias복습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리(복사,alias복습)</h1>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/a3fad05e-6882-4ab8-8cb4-20be79ad1dd0/Untitled%207.png\" alt=\"\"></p>\n<p>위의 사진에서 a와 b는 같은 객체를 공유하고 있고(참조공유), 이는 <strong>alias의 관계</strong>이다. 반면 c는 a의 2번 인덱스를 공유하고 나머지는 복사가 되었다. 이 경우 c는 a에서 <strong>얕은 복사</strong>가 이루어졌다고 볼 수 있다.(이차원 배열인 a에서 1차원선에서만 복사가 이루어졌기 때문) d는 a와 완전히 데이터는 일치하지만, 그 어느 것도 주소를 공유하지 않는다. 이는 <strong>깊은 복사</strong>가 이루어졌다고 볼 수 있다!</p>\n<p>JS에서 <em>타입이나 객체의 구조에 따라서 같은 방법으로 복사를 하더라도 어떤 것은 얕은 복사일수도 있고, 깊은 복사일 수 있다</em>. 이를 판단하는 것은 값 비교와 주소비교이다. A를 원본으로 하는 사본 B가 있을때, B의 모든 원소는 A의 모든 원소와 값이 같아야하며 주소는 달라야(===의 결과 false) 깊은복사라고 한다.</p>\n<h2 id=\"리액트에서-이를-알아야-하는-이유\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"리액트에서 이를 알아야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+리액트에서 이를 알아야 하는 이유</h2>\n<p>React.js에서는 상태의 불변성을 유지시켜줘야하는 이유에 대해서 알아보자. 리액트에서 상태가 변하면 re-rendering을 해줘야하므로, 상태가 변했음을 판단할 수 있어야 한다. 하지만 하나의 상태를 변형해가며 사용한다면(불변성 x) 같은 객체이며 값만 바뀐 것이므로, <strong>상태가 바뀌었는지 확인하는데 더 많은 자원을 소비해야한다</strong>. <em>따라서 아예 다른 객체를 할당해줌으로써 상태가 바뀌었다고 인식하여 리렌더링</em>한다*.* 불변성을 유지하며 상태를 변경하는 방법으로는, 깊은 복사를 해준 후 바꿀 부분만 추가로 바꿔주면 된다! 객체의 깊이에 따라 다양한 방법을 사용할 수 있다.</p>","frontmatter":{"date":"October 24, 2021","title":"(JS) 얕은복사와 깊은복사(shallow and deep copy) & aliasing","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-JS-copy/"}},"site":{"siteMetadata":{"siteUrl":"http://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/FE-React-hooks-2/","nextSlug":"/FE-React-hooks-1/","prevSlug":"/FE-JS-copy/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}