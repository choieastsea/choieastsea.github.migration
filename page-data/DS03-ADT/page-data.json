{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/DS03-ADT/",
    "result": {"data":{"cur":{"id":"1f5b55d1-79b3-570b-83ef-83ed55f01a39","html":"<p>추상자료형에 대하여 공부해보고, stack과 queue에 대하여 알아보자.</p>\n<h1 id=\"abstract-data-typeadt-추상자료형\" style=\"position:relative;\"><a href=\"#abstract-data-typeadt-%EC%B6%94%EC%83%81%EC%9E%90%EB%A3%8C%ED%98%95\" aria-label=\"abstract data typeadt 추상자료형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Abstract Data Type(ADT, 추상자료형)</h1>\n<p>스택은<code class=\"language-text\"> 추상자료형</code>이다. 추상자료형은 자료구조를 추상화한 것으로, 구현보다는 기능에만 초점을 맞춘다. <code class=\"language-text\">OOP</code>를 배울 때 <code class=\"language-text\">추상클래스</code>에 대하여 배운 적이 있을텐데, 이는 실제 구현된 것이 아니고 기능에 대한 메서드만 명시되어 있다. 이를 implement한 클래스가 정해놓은 기능을 구현하는 방식으로 되어있다. <strong>list, set, dictionary, stack, queue는 모두 추상자료형</strong>으로 정해진 기능만을 담고 있으며 다양한 방법으로 구현될 수 있다. 예를 들어 스택은 다양하게 구현할 수 있지만, 우리는 array를 이용하여 직접 구현해볼 것이다.</p>\n<h1 id=\"stack이란\" style=\"position:relative;\"><a href=\"#stack%EC%9D%B4%EB%9E%80\" aria-label=\"stack이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack이란</h1>\n<p>Stack(스택)은 <strong>메모리의 끝에서만 operation이 이루어지는 선형 자료구조</strong>로, 차곡차곡 쌓아올린 형태를 생각하면 이해하기 편하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHcglYAAH//xAAWEAADAAAAAAAAAAAAAAAAAAABECD/2gAIAQEAAQUCZr//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAbEAACAQUAAAAAAAAAAAAAAAABEQAQICFRcf/aAAgBAQABPyEtYhOqdXf/2gAMAwEAAgADAAAAEO/w/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAdEAEAAgICAwAAAAAAAAAAAAABEVEAECFBYXGR/9oACAEBAAE/EGOEXziwcV0GJEHZeV7L3BR81//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"stack\"\n        title=\"stack\"\n        src=\"/static/7531b36b214020cd0a879c6d9da17269/80e3c/stack_1.jpg\"\n        srcset=\"/static/7531b36b214020cd0a879c6d9da17269/4ec73/stack_1.jpg 180w,\n/static/7531b36b214020cd0a879c6d9da17269/158ba/stack_1.jpg 360w,\n/static/7531b36b214020cd0a879c6d9da17269/80e3c/stack_1.jpg 720w,\n/static/7531b36b214020cd0a879c6d9da17269/d6fb3/stack_1.jpg 1073w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>(물론 메모리가 저렇게 생기지는 않았을 것이다. 단지 스택을 그릴때 저렇게 표현한다고 생각하자.)</p>\n<p>그림과 같이 끝부분만 열려있는 배열과 같고, <code class=\"language-text\">LIFO(Last In First Out)</code>방식(후입선출)이라고 알고 있으면 외우기 쉽다. 지금 내가 있는 소방조직에는 티셔츠에 First In Last Out이라고 써있는 것들이 많은데, 이것도 stack이라고 볼 수 있다!! 스택의 이러한 특성은 항상 같이 언급되는 <code class=\"language-text\">Queue</code>(큐)와 대조적인데, 큐는 앞부분만 열려있으며 <code class=\"language-text\">FIFO(First In First Out)</code>의 방식이다.</p>\n<h1 id=\"stack-구현-요구-사항\" style=\"position:relative;\"><a href=\"#stack-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"stack 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 구현 요구 사항</h1>\n<p>JS Array는 stack과 queue의 모든 기능이 이미 구현되어있으므로 여기서는 배열을 이용하여 stack을 구현해보도록 하겠다. 선형구조이므로 <strong>head없이 tail만 있는 linkedlist로도 스택의 기능을 구현할 수 있다</strong>!</p>\n<p>Stack은 데이터의 순서 관계가 항상 유지되므로 배열로 구현할 것이며, (유일하게 신경쓰는)맨 끝의 원소의 인덱스(즉 스택의 높이라고도 볼 수 있다)를 갖는 <strong>top</strong>과 데이터를 담을 공간인 list를 갖고 있는다.</p>\n<ol>\n<li>\n<p>맨 끝에 원소 삽입(push)</p>\n<p>배열의 맨 끝에 원소를 추가하고, top을 1 증가시킨다. 정적배열로 구현하였다면 정해진 크기 이상이 push가 되었을 때, <code class=\"language-text\">stack overflow</code>(우리가 아는 그거 맞다)가 발생한다. 하지만 js array는 내부적으로 배열의 크기를 조정하므로 overflow가 발생할 일은 없다. 하지만 정적배열을 지원하는 C나 Java와 같은 것으로 stack을 구현하였다면, stack overflow에 대한 처리 또한 해줘야 한다. js에서 size_max와 같이 <u>배열 크기의 한계를 둬서 overflow를 보여줄 수도 있을 것 같다</u>. 근데 그러지는 않았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">push</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">element</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>맨 끝의 원소 삭제(pop)</p>\n<p>배열의 맨 끝 원소를 삭제하고 top을 1 감소시킨다. 만약 top이 0이라면(더 이상 삭제할 원소 없음) <code class=\"language-text\">stack underflow</code>오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">pop</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//빈 stack pop한 경우</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Stack Underflow'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//원소 있을때 pop한 경우</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>모든 원소 출력</p>\n<p>현재 스택의 상태를 보기 위하여 print함수를 추가적으로 만들어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">print</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">| </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> |</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">‾‾‾‾‾</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>isEmpty</p>\n<p>top이 0이면 비어있으므로 true를 return한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">isEmpty</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>top <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>전체 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS03_Stack.js\">깃허브에</a> 올려놓았으니 참고하도록 하자.</p>\n</li>\n</ol>\n<h1 id=\"stack-성능-분석\" style=\"position:relative;\"><a href=\"#stack-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D\" aria-label=\"stack 성능 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 성능 분석</h1>\n<h2 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h2>\n<ul>\n<li>\n<p>접근</p>\n<p>맨 위의 <strong>top element만 접근이 가능</strong>하다!</p>\n</li>\n<li>\n<p>탐색</p>\n<p>여기서는 배열로 구현하였기에 인덱스로 접근이 가능하고 탐색 또한 가능하지만, stack은 원래 탐색을 하려면 모든 원소를 pop해보면서 확인해야한다. 굳이 시간복잡도를 따지자면 <code class=\"language-text\">O(n)</code>이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>삽입</p>\n<p>맨 뒤에 삽입하는 것만 가능하며, 일반적으로 스택의 크기와 상관없이 <code class=\"language-text\">O(1)</code>로 가능하다. 정적배열로 구현하였을 경우, resize가 일어날 경우에는 <code class=\"language-text\">O(n)</code>이 걸리겠지만 분할상환분석을 하면 <code class=\"language-text\">O(1)</code>이라고 말할 수 있다. 연결리스트로 구현하였을 때도 상수시간에 가능하다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p>맨 뒤를 삭제하는 것만 가능하며 역시 <code class=\"language-text\">O(1)</code>로 가능하다. 연결리스트로 구현하였을 때도 상수시간에 가능하다.</p>\n</li>\n</ul>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<ul>\n<li>장점</li>\n</ul>\n<p>데이터의 삽입과 삭제가 <code class=\"language-text\">O(1)</code>로 빠르며 다른 선형구조(연결리스트 등)에 비해 가벼운 편이다.</p>\n<ul>\n<li>단점</li>\n</ul>\n<p>탐색이 불가능하다. 맨 위의 원소만 접근 가능하다.</p>\n<h1 id=\"stack-응용\" style=\"position:relative;\"><a href=\"#stack-%EC%9D%91%EC%9A%A9\" aria-label=\"stack 응용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 응용</h1>\n<p>스택은 뒤로가기, 실행 취소와 같이 <strong>가장 최근 것만 필요한 상황에서 자주 사용</strong>된다. 또 다른 예시로는 다항식을 계산하기 위한 <code class=\"language-text\">후위표기식</code> (postfix)에도 활용이 된다. 이는 매우 유용한데, 나중에 다룰 기회가 있다면 직접 구현해보도록 하겠다.</p>\n<h1 id=\"queue란\" style=\"position:relative;\"><a href=\"#queue%EB%9E%80\" aria-label=\"queue란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue란</h1>\n<p>Queue(큐)는 <strong>메모리의 끝에서 들어오고 메모리의 시작부분에서 들어오는 선형 자료구조</strong>이다. 양쪽이 열려있는 파이프관을 생각할 수 있겠다. <code class=\"language-text\">Queue</code>는 가장 먼저 들어온 데이터가 가장 먼저 나오는 <code class=\"language-text\">FIFO</code>(First In First Out, 선입선출)방식으로 스택과 대조된다. <u>게임할 때 큐가 잡혔다고 하는데 이게 그 큐가 맞다</u>. 게임사의 알고리즘에 의하여 우선순위가 생기게 되며 대기하게 되는데, 이게 조건이 맞아 게임이 성사될때마다 우선순위 순으로 대기열에서 나가게 되는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAdsSoH//xAAWEAADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCIv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFRMf/aAAgBAQABPyGHpLRcuz//2gAMAwEAAgADAAAAEPw//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRABAQEAAwAAAAAAAAAAAAAAAREAIVHh/9oACAEBAAE/EFlnncmBIVdyb//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"queue\"\n        title=\"queue\"\n        src=\"/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/80e3c/queue_1.jpg\"\n        srcset=\"/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/4ec73/queue_1.jpg 180w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/158ba/queue_1.jpg 360w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/80e3c/queue_1.jpg 720w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/47311/queue_1.jpg 1080w,\n/static/bdbf6fb0ee1f069a6e578f0fb5c50b30/eea4a/queue_1.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>큐에서는 맨 뒤에 들어오는 것을 <code class=\"language-text\">enqueue</code>, 맨 앞이 나가는 것을 <code class=\"language-text\">dequeue</code>라고 한다. 통용되는 말이 스택과 약간 다르므로(push, pop) 참고하자.</p>\n<h1 id=\"queue의-기능\" style=\"position:relative;\"><a href=\"#queue%EC%9D%98-%EA%B8%B0%EB%8A%A5\" aria-label=\"queue의 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue의 기능</h1>\n<ol>\n<li>\n<p><code class=\"language-text\">Enqueue</code> : 맨 끝에 원소 삽입</p>\n<p>stack의 push와 비슷하다고 볼 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Dequeue</code> : 맨 앞의 원소 삭제하고 나머지 원소 앞으로 옮기기</p>\n<p>맨 앞 원소를 삭제하며 return하고, 나머지 원소들을 모두 한 칸씩 앞으로 옮겨야 한다. js에서는 <code class=\"language-text\">shift</code>함수를 이용하여 간단하게 구현할 수 있다.</p>\n</li>\n</ol>\n<p>큐는 스택과 마찬가지로 <strong>배열과 링크드리스트로 구현가능</strong>하다.</p>\n<h1 id=\"queue-시간-복잡도\" style=\"position:relative;\"><a href=\"#queue-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"queue 시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue 시간 복잡도</h1>\n<ul>\n<li>\n<p>삽입</p>\n<p>스택의 push와 같은 시간복잡도를 지닌다. 배열, 연결리스트 모두 <code class=\"language-text\">O(1)</code>로 삽입이 가능하다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p>맨 앞 원소를 삭제하고 나머지 원소를 <code class=\"language-text\">shift</code>해야하므로 배열로 구현시 <code class=\"language-text\">O(n)</code>의 시간복잡도를 갖는다. 연결리스트로 구현할 경우 단순히 head의 위치만 조정해주면 되므로 원소의 갯수와 관계없이 <code class=\"language-text\">O(1)</code>로 가능하다.</p>\n</li>\n</ul>\n<h1 id=\"queue의-응용\" style=\"position:relative;\"><a href=\"#queue%EC%9D%98-%EC%9D%91%EC%9A%A9\" aria-label=\"queue의 응용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue의 응용</h1>\n<ul>\n<li>\n<p>대기열 등과 같이 정해진 순서대로 처리해야하는 일에 사용된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Priority Queue</code>(우선순위 큐)는 트리의 구조이며, FIFO가 아니라 정해진 우선순위(예를 들면 숫자 원소의 크기)에 따라 dequeue했을 때 나오게 되는 자료구조가 있다. 이는 나중에 <code class=\"language-text\">tree</code>를 배우며 구현해보도록 하자~</p>\n</li>\n</ul>","excerpt":"추상자료형에 대하여 공부해보고, stack과 queue에 대하여 알아보자. Abstract Data Type(ADT, 추상자료형) 스택은이다. 추상자료형은 자료구조를 추상화한 것으로, 구현보다는 기능에만 초점을 맞춘다. 를 배울 때 에 대하여 배운 적이 있을텐데, 이는 실제 구현된 것이 아니고 기능에 대한 메서드만 명시되어 있다. 이를 implement한 클래스가 정해놓은 기능을 구현하는 방식으로 되어있다. list, set, dictionary, stack, queue는 모두 추상자료형으로 정해진 기능만을 담고 있으며 다양한 방법으로 구현될 수 있다. 예를 들어 스택은 다양하게 구현할 수 있지만, 우리는 array를 이용하여 직접 구현해볼 것이다. Stack이란 Stack(스택)은 메모리의 끝에서만 operation이 이루어지는 선형 자료구조로, 차곡차곡 쌓아올린 형태를 생각하면 이해하기 편하다.  (물론 메모리가 저렇게 생기지는 않았을 것이다. 단지 스택을 그릴때 저렇게 표현한…","frontmatter":{"date":"October 09, 2021","title":"(자료구조 JS)ADT 추상자료형 - Stack & Queue","categories":"Algorithms","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/DS03-ADT/"}},"next":{"id":"d2a012e0-3dba-5c82-b90f-2a0682b200c8","html":"<h1 id=\"linkedlist란\" style=\"position:relative;\"><a href=\"#linkedlist%EB%9E%80\" aria-label=\"linkedlist란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList란</h1>\n<p>LinkedList(연결리스트)는 <strong>리스트라는 추상자료형을 구현하는 선형 자료구조</strong> 중 하나로, <code class=\"language-text\">노드</code>끼리 참조를 통하여 연결되어 선형적인 형태를 이루고 있는 자료구조이다. Array는 크기가 정해져 있고 메모리에서 연속적으로 존재하였지만, 링크드 리스트는 각 노드에 데이터가 저장되어 있으며 이웃한 노드의 정보(주소)를 가리키고 있는 형태로 여러 데이터를 저장한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdpaIWP/xAAWEAEBAQAAAAAAAAAAAAAAAAAhACD/2gAIAQEAAQUCZnH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAEBAAIDAAAAAAAAAAAAAAABEQAgIVFx/9oACAEBAAE/IW1jMeAX3A7af//aAAwDAQACAAMAAAAQc8//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCI/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Qqv/EABsQAQADAAMBAAAAAAAAAAAAAAEAETEQIUFx/9oACAEBAAE/EMABos35BcaewZKr5HpTSHHs/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Array와 LinkedList 비교\"\n        title=\"Array와 LinkedList 비교\"\n        src=\"/static/bf210e9da639c1a95f6dc02a0c6135d3/80e3c/Comparing.jpg\"\n        srcset=\"/static/bf210e9da639c1a95f6dc02a0c6135d3/4ec73/Comparing.jpg 180w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/158ba/Comparing.jpg 360w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/80e3c/Comparing.jpg 720w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/47311/Comparing.jpg 1080w,\n/static/bf210e9da639c1a95f6dc02a0c6135d3/eea4a/Comparing.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>간단하게 위의 그림으로 Array와 LinkedList를 비교해볼 수 있다. 연결리스트에서는 데이터가 노드에 저장되며, 노드끼리의 연결관계가 존재한다. 또한 head와 tail은 각각 처음과 마지막 노드를 가리키고 있어 모든 노드에 접근할 수 있게 되는 것이다. 따라서 각 노드는 메모리상에서 연속적으로 존재할 필요가 없으며, 데이터의 자료형이 같을 필요도 없을 것이다.</p>\n<h1 id=\"linkedlist-구현-요구-사항\" style=\"position:relative;\"><a href=\"#linkedlist-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"linkedlist 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 구현 요구 사항</h1>\n<p>LinkedList에서는 배열과 다르게 데이터를 <code class=\"language-text\">Node</code>에서 갖고 있도록 한다. 노드는 데이터를 갖고 있으며, 다른 노드에 대한 레퍼런스를 갖고 있는 객체로 만들면 될 것이다. 여기서는 이전 노드와 다음 노드에 대한 주소를 갖고 있는이중연결리스트(<code class=\"language-text\">Doubly LinkedList</code>)로 구현해보도록 한다.</p>\n<h2 id=\"node-객체\" style=\"position:relative;\"><a href=\"#node-%EA%B0%9D%EC%B2%B4\" aria-label=\"node 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node 객체</h2>\n<ul>\n<li>Fields\n<ul>\n<li>data</li>\n<li>prev : 이전 노드의 정보를 갖고 있는 프로퍼티</li>\n<li>next : 다음 노드의 정보를 갖고 있는 프로퍼티</li>\n</ul>\n</li>\n<li>Functions\n<ul>\n<li>setData</li>\n<li>setPrev</li>\n<li>setNext</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"linkedlist-객체\" style=\"position:relative;\"><a href=\"#linkedlist-%EA%B0%9D%EC%B2%B4\" aria-label=\"linkedlist 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 객체</h2>\n<p>연결리스트는 여러개의 노드로 이루어져 있으며, 시작점과 끝점인 head와 tail을 갖고 있는다.</p>\n<ul>\n<li>Properties\n<ul>\n<li>head : 첫 노드를 가리킨다. 만약 노드가 하나도 없다면 head는 <code class=\"language-text\">null</code>일 것이다.</li>\n<li>tail : 가장 마지막 노드를 가리킨다. 만약 노드가 하나도 없다면 tail도 <code class=\"language-text\">null</code>일 것이다.</li>\n<li>size : 처음부터 마지막 노드까지의 갯수</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>\n<p><strong>접근</strong> get(index) → Node</p>\n<p>head가 가리키는 노드부터 next 노드에 접근하여 next노드가 없을때까지 <strong>index번</strong>만큼 접근한다. 만약 없다면 -1을 return한다.</p>\n<p>head를 iterator로 지정해주고 하나씩 다음 노드로 넘어간다. index만큼 넘어가는 loop를 반복해주면 해당 인덱스의 노드를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> iterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>추가</strong> append(Node)</p>\n<p>맨뒤에 새로운 노드를 추가할 때, 나올 수 있는 경우는 두가지 정도로 생각할 수 있다.</p>\n<ol>\n<li>\n<p>빈 연결리스트에서 추가할 때, null을 가리키고 있던 head와 tail 모두 바꿔줘야 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB242EkMP/xAAXEAEAAwAAAAAAAAAAAAAAAAABABEg/9oACAEBAAEFAriuf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAABETEgIWH/2gAIAQEAAT8haKebJFMVYf/aAAwDAQACAAMAAAAQzz//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAn/8QAHBABAQACAgMAAAAAAAAAAAAAAREAIUHwEDFh/9oACAEBAAE/ENputQ46YTQAFY8HTKi+5vIN+5B48f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"append 1st case\"\n        title=\"append 1st case\"\n        src=\"/static/2b062e38bfb37891a8a7242492791caa/80e3c/append_1.jpg\"\n        srcset=\"/static/2b062e38bfb37891a8a7242492791caa/4ec73/append_1.jpg 180w,\n/static/2b062e38bfb37891a8a7242492791caa/158ba/append_1.jpg 360w,\n/static/2b062e38bfb37891a8a7242492791caa/80e3c/append_1.jpg 720w,\n/static/2b062e38bfb37891a8a7242492791caa/47311/append_1.jpg 1080w,\n/static/2b062e38bfb37891a8a7242492791caa/eea4a/append_1.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>그것이 아니라면, tail만 바꿔주면 될 것이다. 기존의 tail이 가리키고 있던 노드는 새 노드를 next로 갖도록 해야하며, new_node는 기존의 tail 노드를 prev로 갖고 있을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABtBAP/8QAFxABAQEBAAAAAAAAAAAAAAAAACEBEf/aAAgBAQABBQKqzr//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAACAwAAAAAAAAAAAAAAAAAAUREhYf/aAAgBAQABPyGyJwMP/9oADAMBAAIAAwAAABB7z//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QmI//xAAXEAEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAEBAAE/EOx2Bua8cgNCrd//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"append 2nd case\"\n        title=\"append 2nd case\"\n        src=\"/static/46caee95d9e0dc0fba2e779487d5cf8a/80e3c/append_2.jpg\"\n        srcset=\"/static/46caee95d9e0dc0fba2e779487d5cf8a/4ec73/append_2.jpg 180w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/158ba/append_2.jpg 360w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/80e3c/append_2.jpg 720w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/47311/append_2.jpg 1080w,\n/static/46caee95d9e0dc0fba2e779487d5cf8a/eea4a/append_2.jpg 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>코드는 다음과 같을 것이다. 또한 size를 1씩 증가시켜줘야한다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n    new_node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삽입</strong> insert(index, new_node)</p>\n<p>index번째 노드 뒤에 new_node를 삽입하는 경우도 역시 2가지로 나눠볼 수 있다.</p>\n<ol>\n<li>\n<p>index===size-1인 경우에는 append와 같을 것이다.</p>\n</li>\n<li>\n<p>그 외의 경우, 아래의 그림을 참고하여 prev와 next를 조정해주면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtXSIqP//EABYQAQEBAAAAAAAAAAAAAAAAACEAIP/aAAgBAQABBQJnP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAEEAwAAAAAAAAAAAAAAAAABESAxQWGh/9oACAEBAAE/IbV0V2hHzD//2gAMAwEAAgADAAAAELD/AP/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EIf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGRABAAMBAQAAAAAAAAAAAAAAAREhMQAg/9oACAEBAAE/EHYBwJsC6d6tiTNR4//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"insert\"\n        title=\"insert\"\n        src=\"/static/ce604385d982a0ed5ce0e09e8f731642/80e3c/insert.jpg\"\n        srcset=\"/static/ce604385d982a0ed5ce0e09e8f731642/4ec73/insert.jpg 180w,\n/static/ce604385d982a0ed5ce0e09e8f731642/158ba/insert.jpg 360w,\n/static/ce604385d982a0ed5ce0e09e8f731642/80e3c/insert.jpg 720w,\n/static/ce604385d982a0ed5ce0e09e8f731642/47311/insert.jpg 1080w,\n/static/ce604385d982a0ed5ce0e09e8f731642/cdb2b/insert.jpg 1281w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ol>\n<p>주의할 점은 next와 prev를 초기화하는 순서를 혼동하여 노드간의 연결이 끊기지 않도록 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index<span class=\"token punctuation\">,</span> new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//index에 해당하는 node를 찾아서 삽입한다.</span>\n  <span class=\"token keyword\">let</span> nodeToFind <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeToFind <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeToFind <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//맨끝삽입</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>new_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//가운데삽입</span>\n      new_node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> nodeToFind<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      nodeToFind<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n      new_node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> nodeToFind<span class=\"token punctuation\">;</span>\n      nodeToFind<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'index에 해당하는 노드가 없습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>제일 앞에 삽입</strong> unshift(new_node)</p>\n<p>위의 경우들로는 맨 앞에 노드를 추가해줄 수 없다. 따라서,  맨 앞에 노드를 추가해주는 unshift 함수를 정의해주도록 하자. 역시 빈 연결리스트일때와 나머지 경우로 나눠볼 수 있으며, head를 조정해주면 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">new_node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>new_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n    new_node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> new_node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>삭제</strong> remove(index)</p>\n<p>삭제는 정수형 인덱스를 넘겨 i번째 노드의 <strong>전후 노드를 이어줌으로써</strong> 구현한다. 삭제는 인덱스가 유효한 경우에 맨 앞, 맨 뒤, 나머지의 3가지 경우가 있을 수 있다.</p>\n<ol>\n<li>맨앞 삭제: 기존의 head가 가리키는 노드의 다음노드를 head가 가리키도록 한다. 또한 head가 가리키게 된 노드의 prev는 null로 해준다.</li>\n<li>맨뒤 삭제: 기존의 tail이 가리키는 노드의 이전노드를 tail이 가리키도록 한다. 또한 tail이 가리키게 된 노드의 next는 null로 해준다.</li>\n<li>나머지: i번째 노드에 접근하여 삽입의 역순과 같이 해주면 된다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> index <span class=\"token operator\">>=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Invalid Index'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//head 삭제시</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//tail 삭제시</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  iterator<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n  iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>**탐색 **search(data) → index/-1</p>\n<p>위의 find와 마찬가지로 iterator를 지정해주고, data를 비교하며 탐색한다. 만약 tail까지 탐색했는데 원하는 data가 없는 경우, -1을 return하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span>data <span class=\"token operator\">===</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      iterator <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      count <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>isEmpty</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>출력</p>\n<p>배열과 다르게 직접 구현하여 내장된 출력함수가 없으므로, 출력에 대한 함수를 만들어줘야한다. 각 노드가 담고 있는 데이터를 담도록 하였다. (<code class=\"language-text\">process.stdout.write</code>함수를 사용한 이유는 개행없이 연결리스트를 출력하기 위해서이다)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">printFromHead</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pointer <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'head'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> ↔ </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pointer<span class=\"token punctuation\">.</span>data<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pointer<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      pointer <span class=\"token operator\">=</span> pointer<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> ↔ tail</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<p>링크드리스트의 구현은 헷갈리는 부분이 있을 수 있지만, 한번 그려보면 이해하고 바로 구현하기 어렵지 않다. 과거 tmp를 두고 a와 b를 swap했던 기억을 떠올리며 <strong>prev와 next가 교차되면서 헷갈리지 않도록 주의</strong>하자!</p>\n<p>전체 코드와 예제는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS02_DoublyLinkedList.js\">깃허브</a>에 올려놨으니 참고하면 된다.</p>\n<h1 id=\"linkedlist-성능-분석\" style=\"position:relative;\"><a href=\"#linkedlist-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D\" aria-label=\"linkedlist 성능 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList 성능 분석</h1>\n<h2 id=\"시간복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도</h2>\n<ul>\n<li>\n<p>접근</p>\n<p><code class=\"language-text\">get(index)</code> 를 보면 index 번째 노드에 접근하기 위해 head 노드부터 차례로 next node로 iterator가 이동하는 것을 볼 수 있다. 이는 <code class=\"language-text\">O(n)</code>의 시간이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>탐색</p>\n<p>탐색 역시 head node부터 선형탐색을 진행하므로 <code class=\"language-text\">O(n)</code>의 시간이 걸린다.</p>\n</li>\n<li>\n<p>삽입</p>\n<p><code class=\"language-text\">insert(index, new_node)</code>함수를 보면 접근 이후에 실제 삽입을 한다. 삽입 자체는 연결리스트의 크기와 상관없이 상수시간에 해결 가능하지만, 접근이 O(n)만큼 걸리므로 삽입의 시간복잡도는 <code class=\"language-text\">O(n)</code>이라고 볼 수 있다. 하지만, 맨 뒤에 삽입하는 <code class=\"language-text\">append(new_node)</code>나 맨 앞에 삽입하는 <code class=\"language-text\">unshift(new_node)</code>의 경우에는 크기와 상관없이 일정한 시간에 가능하므로<code class=\"language-text\">O(1)</code>이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>삭제</p>\n<p><code class=\"language-text\">remove(index)</code>함수와 같이 접근 이후에 실제 삭제를 한다. 따라서 위와 같이 <code class=\"language-text\">O(n)</code>의 시간이 걸린다고 볼 수 있다. 하지만 맨 앞과 끝 노드를 삭제할 경우에는 일정한 시간 <code class=\"language-text\">O(1)</code>에 끝낼 수 있다고 볼 수 있다.</p>\n</li>\n</ul>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>\n<p>새로운 elements를 삽입, 삭제 시 용이하다. **전통적인 배열(js array와 다름)**에서는 원소를 추가하는 경우 resize의 과정이 추가적으로 존재하는데, 연결리스트는 이가 불필요하다. 데이터가 메모리상에 연속적으로 저장된 것이 아니라, 연속적인 데이터를 담고 있는 노드가 메모리 공간에서 서로를 참조하고 있기 때문이다.</p>\n</li>\n<li>\n<p>양 끝에 삽입하거나 삭제하는 경우에 head나 tail을 field로 갖고 있으므로 <code class=\"language-text\">O(1)</code>의 시간복잡도로 해결가능하므로 빠르게 처리할 수 있다. (정적 배열의 경우 꽉차 있으면 resize가 필요하므로 <code class=\"language-text\">O(n)</code>이 걸릴 수도 있음)</p>\n</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>접근시, 배열은 <code class=\"language-text\">O(1)</code>에 바로 접근할 수 있지만, 연결리스트는 head부터 가야하므로 시간이 많이 걸린다.</li>\n<li>같은 데이터를 저장할 때 앞뒤 노드의 참조를 갖고 있으므로 메모리를 비교적 많이 차지하게 된다. (더 큰 공간복잡도)</li>\n</ul>\n<p>데이터의 접근은 배열이 <code class=\"language-text\">O(1)</code>으로 빠르지만, 삽입 삭제는 대체적으로 연결리스트가 빠르다고 볼 수 있을 것 같다.</p>\n<h1 id=\"linkedlist의-종류와-비교\" style=\"position:relative;\"><a href=\"#linkedlist%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%B9%84%EA%B5%90\" aria-label=\"linkedlist의 종류와 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList의 종류와 비교</h1>\n<p><strong>다음 노드만 가리키는</strong> 링크드 리스트를 simple linked list(단순연결리스트)라고 하며 한 노드가 이전노드와 다음노드를 가리키는 것을 double linked list(이중연결리스트)라고 한다. 또한, 모양에 따라 <strong>가장 마지막 노드가 제일 처음 노드를 가리키는 형태</strong>를 circular linked list(원형 연결 리스트)라고 한다. 여기서는 이중연결리스트로 구현했다고 볼 수 있다. 각 연결리스트의 특징은 다음과 같다고 생각해볼 수 있다.</p>\n<ul>\n<li>단일연결리스트</li>\n</ul>\n<p>​\t위의 코드와 다르게 prev없이 next만 존재. 공간복잡도, 코드량이 적은 대신 앞 노드로 접근이 안된다.</p>\n<ul>\n<li>이중연결리스트</li>\n</ul>\n<p>​\t한 노드 기준으로 앞 뒤 노드 모두 접근이 바로 가능하다. 그대신 공간 복잡도와 코드량이 늘어난다.</p>\n<ul>\n<li>원형연결리스트</li>\n</ul>\n<p>​\t보통 next만 갖고 있으며 tail이 head를 바로 가리키므로, head를 굳이 갖고 있지 않아도 된다. 단일연결리스트의 개선안이라고 생각하면 될 것 같다.</p>\n<p>저번 포스트에도 얘기했지만, JavaScript에서는 사실상 연결리스트를 따로 사용할 일이 없다. 왜냐하면 Array에 모든 것이 최적의 시간복잡도로 구현되어 있기 때문이다. 이는 이후에 공부할 스택, 큐 등에도 해당하는 내용이다. 하지만, 배열과 다른 연결리스트의 관점을 파악하는 것이 이번 자료구조의 목적이므로 앞으로도 다양한 자료구조를 공부해볼 것이다.</p>","frontmatter":{"date":"October 04, 2021","title":"(자료구조 JS) LinkedList","categories":"Algorithms","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/DS02-LinkedList/"}},"prev":{"id":"5ad2aee6-9e68-5a85-9917-d2af9e38d633","html":"<h1 id=\"react-hooks-1-usestate-useeffect\" style=\"position:relative;\"><a href=\"#react-hooks-1-usestate-useeffect\" aria-label=\"react hooks 1 usestate useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(React) Hooks (1) useState, useEffect</h1>\n<p>Hooks는 함수형 컴포넌트에서 다양한 작업을 할 수 있도록 도와주는 함수이다. 기존에는 class형 컴포넌트에서만 가능했던 기능을 hook을 통하여 functional component에서 사용가능하게 되었으며, 로직을 재사용할 수 있게 되었고, 코드의 이해도를 높일 수 있게 되었다.</p>\n<p>보통 hook은 <code class=\"language-text\">useState()</code>, <code class=\"language-text\">useEffect()</code>와 같이 use~로 시작하는 경우가 많고, 리액트에서 제공하는 hook\n뿐만 아니라 customized 하여 사용할 수도 있다. 그 중 가장 기본적인 훅인 <code class=\"language-text\">useState</code>와 <code class=\"language-text\">useEffect</code>에 대하여 알아보자.</p>\n<h1 id=\"usestate\" style=\"position:relative;\"><a href=\"#usestate\" aria-label=\"usestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h1>\n<p>함수형 컴포넌트에서 state(상태)를 바꿔줄 수 있도록 하는 가장 기본적인 Hook이다. <code class=\"language-text\">useState</code>의 인자로는 해당 state의 초깃값을 넣어주며, <code class=\"language-text\">[state명, state를 설정하는 setter 함수]</code>로 구성된 배열을 반환한다.</p>\n<h2 id=\"usestate-사용법\" style=\"position:relative;\"><a href=\"#usestate-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"usestate 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState 사용법</h2>\n<p>우선 useState를 import하고 사용해야 한다. 다음 예제를 보도록 하자!</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">const [value, setValue] = useState(0)</code>를 보면 value라는 이름을 갖고 초깃값이 0인 state와 value를 set해주는 setValue함수를 useState가 리턴하게 된다. 보통 이를 <strong>비구조화 할당</strong><code class=\"language-text\">destructuring assignment</code>으로 받아서 처리한다. <code class=\"language-text\">const value = useState(0).value</code>…와 같은 결과를 낸다고 볼 수 있다.</p>\n<p>setter함수는 보통 이벤트 또는 state가 변경되어야 하는 상황에서 사용된다. 위의 예제에서는 button이 눌리면(onClilck) value를 +1씩 해주거나 -1씩 해주도록 하였다. 여기서 value는 가장 최근의 값을 가져오지만, <strong>asynchronously</strong>하게(비동기적으로) 실행되므로 연속적인 순서를 지켜줘야하는 경우에는 다음의 해결방법이 있을 것이다.</p>\n<ol>\n<li>\n<p>useEffect</p>\n<p>해당 state가 바뀜으로써 <code class=\"language-text\">side-effect</code>가 생기게 한다. 이는 순서를 부여할 수 있다는 의미이다.</p>\n</li>\n<li>\n<p><u><strong>callback함수 이용</strong></u></p>\n<p>위의 setValue를 <code class=\"language-text\">setValue((value)=> value +1)</code>와 같이 인자로 콜백함수를 넣어줄 수 있다. 이는 바로 직전의 value값을 가져와 setter를 수행하는 것으로 동기적으로 실행할 수 있다. 이는 useEffect안에서 <em>의존성 문제가 발생했을때도 생각할 수 있는 해결책이 될 것</em>이다.</p>\n</li>\n<li>\n<p>await 키워드 이용</p>\n<p>비동기적인 함수이므로 async~await를 사용하면 동기적으로 이후의 작업을 수행할 수 있을 것이다.</p>\n</li>\n</ol>\n<h2 id=\"state가-바뀌면-re-render-된다\" style=\"position:relative;\"><a href=\"#state%EA%B0%80-%EB%B0%94%EB%80%8C%EB%A9%B4-re-render-%EB%90%9C%EB%8B%A4\" aria-label=\"state가 바뀌면 re render 된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>state가 바뀌면 re-render 된다</h2>\n<p>state가 바뀌면서 리렌더링이 일어나고 그 이후에 비동기적으로 setState가 반영된다. 따라서, setState() 바로 뒤에 console.log()를 찍어보면 이전 state가 나오는 것을 확인할 수 있다.</p>\n<h1 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h1>\n<p>Effect Hook을 사용하면 함수 컴포넌트에서 <code class=\"language-text\">side effect</code>를 수행할 수 있다. side effect란, state를 바꿀 때 일어나는 일련의 tasks라고 보면 된다. 예를 들어 위의 예시에서, count를 console에다가 출력해보자. count가 바뀔때마다 console.log를 수행하는 side-effect를 발생시키는 것이므로 <strong>useEffect</strong>를 사용하면 된다! useEffect 역시 import해서 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//value가 바뀔때마다 값이 콘솔에 출력될 것이다.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>useEffect(callback, [state])의 구성으로 되어있는데, [state]는 <code class=\"language-text\">의존성배열(deps)</code>로 관찰할 states의 배열을 넣어주고, callback은 state들이 바뀌거나 마운트,언마운트되면 실행될 side-effect에 대한 함수를 넣어주면 된다.</p>\n<h2 id=\"useeffect-사용법\" style=\"position:relative;\"><a href=\"#useeffect-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"useeffect 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect 사용법</h2>\n<ol>\n<li>\n<p>마운트시에만 실행</p>\n<p>마운트는 처음으로 컴포넌트가 화면에 보이게 되는 시점을 의미하며, 뒤에 빈 배열을 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'마운트될때만 실행'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>컴포넌트가 처음 나타날때만 콘솔에 출력되고 이후에는 출력되지 않을 것이다. 컴포넌트의 초기화 등에 사용될 수 있다.</p>\n</li>\n<li>\n<p>특정 값 업데이트 될때만 실행</p>\n<p>의존성 배열에다가 관찰할 값들을 넣어주면 된다. 배열 안에는 state나 props로 전달받은 값 모두 사용 가능하다. 위의 Counter.js의 예시를 참고하자.</p>\n</li>\n</ol>\n<h2 id=\"cleanup-function\" style=\"position:relative;\"><a href=\"#cleanup-function\" aria-label=\"cleanup function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cleanup function</h2>\n<p>컴포넌트가 <strong>언마운트 되기 전이나, 업데이트되기 직전에 작업을 수행</strong>하고 싶다면 콜백함수에서 뒷정리(cleanup)함수를 반환해주면 된다. <u>업데이트 되는 상황에서는 (이전 effect에 대한)clean-up → update → side-effect 순으로 실행되며, 언마운트 되는 상황에서는 clean-up함수가 실행</u>된다.</p>\n<p>카운터의 예시에서 언마운트, 마운트를 버튼으로 처리할 수 있도록 추가해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//App.js</span>\n<span class=\"token keyword\">import</span> Counter <span class=\"token keyword\">from</span> <span class=\"token string\">\"./Counter\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isVisible<span class=\"token punctuation\">,</span> setIsVisible<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setIsVisible</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isVisible<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>isVisible <span class=\"token operator\">?</span> <span class=\"token string\">\"숨기기\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"보이기\"</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>isVisible <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">&lt;</span>Counter <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//Counter.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Counter</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mount or update\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"clean up\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Counter<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p><img src=\"../../../cnkspace/dcm20/artifacts/doxsupp/images/useEffect.png\" alt=\"실행화면\"></p>\n<p>업데이트가 일어날 때에도 이전 effect에 대한 clean-up이 먼저 일어나고, 업데이트와 side-effect가 실행이 되는 것을 확인할 수 있다.</p>\n<p>useEffect hooks은 이외에도 데이터를 fetching하여 가져오는 등 다양하게 사용된다. 이에 대하여 자세하고 어렵게 적어놓은 <a href=\"https://overreacted.io/ko/a-complete-guide-to-useeffect/\">글</a>을 읽어보도록 하자! 나도 아직 잘 이해가 가지 않는다ㅠ 다음에는 useMemo, useCallback, useRef와 함께 커스텀 훅을 만드는 방법에 대하여 알아보겠다.</p>","frontmatter":{"date":"October 12, 2021","title":"(React) Hooks (1) useState, useEffect","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-hooks-1/"}},"site":{"siteMetadata":{"siteUrl":"http://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/DS03-ADT/","nextSlug":"/DS02-LinkedList/","prevSlug":"/FE-React-hooks-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}