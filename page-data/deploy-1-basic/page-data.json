{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/deploy-1-basic/",
    "result": {"data":{"cur":{"id":"b16b8c18-01f9-539f-9955-57e778d6453e","html":"<h2 id=\"목표\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%ED%91%9C\" aria-label=\"목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목표</h2>\n<p>CRA를 이용한 <code class=\"language-text\">React.js</code> 프론트 개발, <code class=\"language-text\">node js</code>와 <code class=\"language-text\">MySQL</code>을 이용한 api 서버 개발 모두 할 줄 안다면, 이제 배포를 해볼 차례이다.! 배포까지 해보아야 웹 서비스가 어떤 식으로 구성되는지 알 수 있을 것 같아서 공부해보았고, 그 기록을 남기고자 한다.</p>\n<p>목표는 다음과 같다.</p>\n<ul>\n<li>클라우드 환경을 이용하여 웹서비스(풀스택) 배포하기</li>\n<li>docker 이용하여 배포 환경 구축하기</li>\n<li>(optional) 도메인 구입해서 쉽게 접속하기</li>\n</ul>\n<h2 id=\"web-service-architecture\" style=\"position:relative;\"><a href=\"#web-service-architecture\" aria-label=\"web service architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Service Architecture</h2>\n<p>출처: <a href=\"https://fractalideas.com/blog/making-react-and-django-play-well-together/\">https://fractalideas.com/blog/making-react-and-django-play-well-together/</a></p>\n<p><img src=\"/e435d0a4f61e0bf436d5f37b50c9a8b6/webapp-architectures.svg\" alt=\"asdf\"></p>\n<p>크게 4가지 방법이 있고, 각각에 대하여 이해해보자.</p>\n<ol>\n<li>\n<p>두개(front, api)의 서버를 두는 구조이다. client가 브라우저를 통하여 url(app.example.com)을 입력하면, front-server에서 이를 처리하여 html, css, js 파일을 리턴해준다. 그리고, 해당 사이트에서 클릭 등의 이벤트로 인하여 api가 호출이 될 때에는 다른 url(api.example.com)을 통하여 요청과 응답이 이루어지는 구조이다. 이는 front와 backend가 각각의 서버 프로그램으로 구분되어 있으므로, backend 서버에서는 프론트로부터 오는 cross origin request에 대한 CORS 허용이 되어 있어야 할 것이다.</p>\n<p>대부분의 SPA(리액트도 포함)가 이러한 구조를 이용한다고 한다. React js의 경우에는 front server에서 url요청에 따라 정적인 html, js, css를 (번들링된 상태로 주겠지만 아무튼)리턴할 것이다. 그리고, <code class=\"language-text\">react-router-dom</code>과 같은 라이브러리를 통하여 root를 공유하는 다른 url요청(예를 들어 app.example.com/rank)을 추가적인 프론트서버에 요청보내지 않고 처리할 수 있다.</p>\n</li>\n<li>\n<p>백엔드 서버에서 프론트엔드를 리턴하는 구조이다. 아마, node js에서 express 미들웨어로 hello world를 찍어보려고 할 때,</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span>res</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\tres<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;h1>Hello World&lt;/h1>'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>라던가, sendFile을 이용하여 정적인 html파일을 리턴하도록 한 경험이 있을 것이다. 이러한 방법이라고 보면 될 것 같다.</p>\n</li>\n<li>\n<p>브라우저의 요청에 대하여, 프론트 엔드 서버가 처음으로 받고, 해당하는 내용이 없다면 proxy등을 통하여 백엔드 서버로 넘겨줘 요청을 처리하도록 한다. CRA와 <code class=\"language-text\">npm start</code>를 통하여 개발서버를 연 이후, <code class=\"language-text\">package.json</code>에서 proxy를 api server주소로 설정하여, api 요청에 대하여 백엔드로 넘겨주는 방법을 사용할 수 있다. <a href=\"https://choieastsea.github.io/full-stack-in-js/\">나도 과거에 이러한 방법을</a> 이용한 적이 있으니 참고하면 될 것 같다.</p>\n</li>\n<li>\n<p>이 방법은 리버스 프록시를 이용하는 방법인데, 나도 해본 적은 없어 원문 링크를 참고하여 보면 될 것 같다.</p>\n</li>\n</ol>\n<h2 id=\"-cra를-이용한-리액트-웹서버-웹서버-이해하기\" style=\"position:relative;\"><a href=\"#-cra%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%9B%B9%EC%84%9C%EB%B2%84-%EC%9B%B9%EC%84%9C%EB%B2%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\" cra를 이용한 리액트 웹서버 웹서버 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ CRA를 이용한 리액트 웹서버? 웹서버 이해하기</h2>\n<p>CRA(Create React App)을 이용하여 리액트 개발 공부를 한 나는, React는 분명 front-end library인데, 왜 npm start만 하면 <code class=\"language-text\">localhost:3000</code>과 같이 접속할 수 있지?? 라는 의문을 품었었다. 이는 CRA의 개발모드에서 지원해주는 로컬 웹서버 환경으로 디버깅 등을 편하게 해주기 위해 웹서버를 제공해주는 것이였다. 하지만, 이는 용량이 크고 필요 없는 코드가 존재하여 실제 배포되서 운영되기에는 무리가 있다. 따라서, 우리는 <code class=\"language-text\">npm run build</code>를 이용한다.! 빌드하여 컴팩트해진 정적 파일들을 웹서버(CRA dev server와 거의 같은 일을 하는) 에 올려놓으면 되는 것이다.</p>\n<p>결론은, 1번방법으로 리액트를 배포하려면 웹서버를 구축해놔야한다는 것이다. 이 웹서버는 app.example.com과 같은 url 요청에 대하여 <strong>빌드된 정적 파일들을 제공</strong>하면 되는 것이다.</p>\n<p>자 그러면, 웹서버는 뭐를 사용하면 될까? 우리는 <code class=\"language-text\">nginx</code> 를 이용해보도록 하자. node.js를 이용하여 웹서버의 역할을 구현해 볼 수도 있지만, 엔진엑스가 웹서버의 의미에 더 부합한다고 볼 수 있다. 또한 세팅(configuration)만 하고, nginx server를 켜 놓으면 완성되므로 매우 쉽다~ 이거에 관하여 <a href=\"youtube.com/watch?v=Zimhvf2B7Es\">매우 정리가 잘 되어있는 유튜브</a>를 보면 도움이 될 것이다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li>\n<p>우리가 사용할 웹 서비스 아키텍쳐(이것이 뭐라고 통용되는지는 찾아볼 필요가 있음) : 프론트 엔드 서버 / api (백엔드)서버를 분리하여 사용할 예정</p>\n</li>\n<li>\n<p>프론트엔드 서버의 구조 : <code class=\"language-text\">nginx</code> + <code class=\"language-text\">builded react file</code></p>\n<p>모든 http(s) 요청에 대하여, 해당 url에 정적인 내용을 browser에게 리턴한다.</p>\n</li>\n<li>\n<p>백엔드 서버의 구조 : <code class=\"language-text\">nest js</code> (혹은 <code class=\"language-text\">django rest framework</code>) ~ <code class=\"language-text\">MySQL server</code>가 연결되어 있는 구조</p>\n<p>프론트엔드에서 불려지는 api 요청에 대하여, browser에게 응답한다. 필요하다면, db server를 사용할 수도 있다.</p>\n</li>\n</ul>","excerpt":"목표 CRA를 이용한  프론트 개발, 와 을 이용한 api 서버 개발 모두 할 줄 안다면, 이제 배포를 해볼 차례이다.! 배포까지 해보아야 웹 서비스가 어떤 식으로 구성되는지 알 수 있을 것 같아서 공부해보았고, 그 기록을 남기고자 한다. 목표는 다음과 같다. 클라우드 환경을 이용하여 웹서비스(풀스택) 배포하기 docker 이용하여 배포 환경 구축하기 (optional) 도메인 구입해서 쉽게 접속하기 Web Service Architecture 출처: https://fractalideas.com/blog/making-react-and-django-play-well-together/ asdf 크게 4가지 방법이 있고, 각각에 대하여 이해해보자. 두개(front, api)의 서버를 두는 구조이다. client가 브라우저를 통하여 url(app.example.com)을 입력하면, front-server에서 이를 처리하여 html, css, js 파일을 리턴해준다. 그리고, 해당 사이트에…","frontmatter":{"date":"December 30, 2022","title":"(배포) 웹서비스 배포하기 (1) 서비스 아키텍쳐","categories":"WEB","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/deploy-1-basic/"}},"next":{"id":"07f2f54e-ace1-532a-a1df-277dcd13e4d5","html":"<p>병렬프로그래밍 수업을 위해 <code class=\"language-text\">openmp</code>를 mac os에 설치해야하는데, 헷갈려서 정리해놓는다. clang이 아닌 gcc로 실습환경을 구성하려고 한다.(mac의 gcc도 clang 계열이지만, 여기서는 몇가지 이유로 gcc로 진행한다) <code class=\"language-text\">brew</code>로 설치하였고, 이것은 필수이다.!</p>\n<ol>\n<li>\n<p>gcc 설치 및 버전 확인</p>\n<p>나는 c++로 진행하였기에 gcc가 아닌 g++로 진행하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> gcc\nbrew info gcc</code></pre></div>\n<p>brew info 명령어로 gcc 컴파일러의 버전정보를 얻을 수 있다.</p>\n</li>\n<li>\n<p>openmp 실행 방법</p>\n<p>우선, 소스코드에 <code class=\"language-text\">#pragma omp parallel</code>이 main 함수 안에 선언되어 있어야 한다. 나는 다음과 같이 적어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\">omp parallel</span></span>\nstd<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Hello World!\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 컴파일 할 때, <code class=\"language-text\">-fopenmp</code> 옵션을 주면 되는데, 여기서 버전정보를 알 필요가 있다. 버전에 맞게 다음과 같이 컴파일해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++-12 test.cpp -fopenmp -o <span class=\"token builtin class-name\">test</span></code></pre></div>\n</li>\n<li>\n<p>최종 확인</p>\n<p>실행~</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./test \nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span></code></pre></div>\n<p>실행환경의 Thread 수만큼 Hello World가 찍혀서 나오는 것을 볼 수 있다. 이러면 openmp환경이 세팅되었다고 보면 될 것 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.555555555555557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUUlEQVQI142MuwlAIQxF3X+izGARCGiZRiEYzQ5XzALvFYf7KU5prUFE0HsHM+PttRYiAmMMqCrOOdh7Z35Raq0gohTNOVPi7il4YjPL/r4/XPqJkm5DL+vIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"m1pro.png\"\n        title=\"m1pro.png\"\n        src=\"/static/b52651c7be9601f7a99907337128a5ad/37523/m1pro.png\"\n        srcset=\"/static/b52651c7be9601f7a99907337128a5ad/e9ff0/m1pro.png 180w,\n/static/b52651c7be9601f7a99907337128a5ad/f21e7/m1pro.png 360w,\n/static/b52651c7be9601f7a99907337128a5ad/37523/m1pro.png 720w,\n/static/b52651c7be9601f7a99907337128a5ad/b12f7/m1pro.png 1020w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>나의 경우, m1 pro칩이 들어간 mac book pro를 사용중인데, 8코어 8쓰레드인 걸 지금 알았다… ㅎ</p>\n</li>\n</ol>","frontmatter":{"date":"September 05, 2022","title":"m1 mac에서 병렬프로그래밍을 위해 openmp 설치하기","categories":"블로그","author":"choieastsea","emoji":"😉"},"fields":{"slug":"/mac-setup-openmp/"}},"prev":{"id":"709cb75a-570a-5de4-8075-19486a37c740","html":"<h2 id=\"프론트엔드-서버-개발\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C\" aria-label=\"프론트엔드 서버 개발 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프론트엔드 서버 개발</h2>\n<p>저번 시간에 정한 구조를 기반으로 간단한 웹사이트를 개발하고 배포해보도록 하자.! 오늘은 그중에 프론트엔드 서버부터 만들어보자.</p>\n<p>한 문장으로 정리하면 프론트엔드 서버는 <code class=\"language-text\">nginx</code>웹 서버가 url 요청에 대하여 build된 react file의 결과물(html, css, js)를 리턴하도록만 하면 된다. 웹서버의 프록시는 사용하지 않을 할 예정이다.</p>","frontmatter":{"date":"January 01, 2023","title":"(배포) 웹서비스 배포하기 (2) 프론트 서버 개발","categories":"WEB","author":"choieastsea","emoji":"🚀"},"fields":{"slug":"/deploy-2-front-server/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/deploy-1-basic/","nextSlug":"/mac-setup-openmp/","prevSlug":"/deploy-2-front-server/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}