{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/progress-event/",
    "result": {"data":{"cur":{"id":"7a33879a-a69c-5e3b-9ee1-0859c7893692","html":"<p>progress bar는 로딩중인 화면을 보여줄 때 사용되는데, 진행도에 따른 비율(%)을 보여주는 progress bar를 구현하기 위해서는 세가지 정도의 방법을 생각해볼 수 있다.</p>\n<ul>\n<li>\n<p>web socket 통신</p>\n<p>server와 client가 양방향 소통을 하며 얼마나 남았는지를 실시간으로 클라이언트에게 제공한다</p>\n</li>\n<li>\n<p>http 통신</p>\n<p>(단순 다운로드의 경우,) http의 Content-Length를 이용하여 총 크기를 알고, 데이터의 chunk가 도착할때 마다 %를 업데이트한다.</p>\n<p>서버의 상태를 받아야한다면, long polling 방식도 고려해볼 수 있겠지만 위의 경우 서버가 지속적으로 데이터를 줘야 하는 경우라면 이는 힘들 것이다.</p>\n</li>\n<li>\n<p>SSE(Server Sent Event) 통신</p>\n<p>HTML5의 표준 통신으로, 한번의 AJAX 요청에 대하여 서버의 상태를 지속적으로 보낼 수 있는 프로토콜이다. 서버에 의존적이긴 하지만, 서버에서 로딩에 대한 이유를 설명할 때 유용할 것이다.</p>\n</li>\n</ul>\n<p>오늘은 http 기반의 방법으로 이를 구현해보자. Web API의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent\">Progress Event</a>를 알면 데이터가 얼마나 load되고 있는지 파악할 수 있으므로, 이를 이용하자!</p>\n<h2 id=\"progress-event란\" style=\"position:relative;\"><a href=\"#progress-event%EB%9E%80\" aria-label=\"progress event란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Progress Event란</h2>\n<blockquote>\n<p>The ProgressEvent Object handles events that occur when loading external resources.</p>\n</blockquote>\n<p>Progress Event 객체는 다음과 같은 속성을 갖는다.</p>\n<ul>\n<li>lengthComputable : 작업량이 계산 가능한 타입인지</li>\n<li>loaded : 현재 progress가 진행된 정도</li>\n<li>total : 총 작업의 양</li>\n</ul>\n<p>total에 대한 loaded의 비율을 이용하여 progress를 계산할 수 있다.</p>\n<h2 id=\"typescript-react에서-progress-bar-만들기\" style=\"position:relative;\"><a href=\"#typescript-react%EC%97%90%EC%84%9C-progress-bar-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"typescript react에서 progress bar 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript React에서 progress bar 만들기</h2>\n<p>file을 업로드하거나, 다운로드 하는 경우에 전체 파일의 크기 중 보내거나 받은 바이트의 비율을 이용하여 progress bar를 구현할 수 있다. axios 라이브러리에서는 이를 위하여 <code class=\"language-text\">progressEvent</code> 객체를 인자로 받는 <code class=\"language-text\">onDownloadProgress</code> 콜백함수가 제공된다. (업로드할 때에는 <code class=\"language-text\">onUploadProgress</code>를 사용하면 될 것)</p>\n<p>하지만, <code class=\"language-text\">typescript</code>에서는 <code class=\"language-text\">progressEvent.total</code>이 <u>optional</u>이므로 Math.round()에 인자로 사용될 수 없다. 따라서, 아래와 같이 <strong>not undeifined를 보장한 progressEvent.total을 값으로 사용</strong>할 수 있다.</p>\n<p>참고로, response의 headers에 있는 <code class=\"language-text\">Content-Length</code>에 해당하는 값이 progressEvent.total인 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleDownloadFile</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setIsDownloading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">setProgress</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> response<span class=\"token operator\">:</span> AxiosResponse<span class=\"token operator\">&lt;</span>Blob<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">authAxios</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">foo/bar/</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n                responseType<span class=\"token operator\">:</span> <span class=\"token string\">'blob'</span><span class=\"token punctuation\">,</span>\n                <span class=\"token function-variable function\">onDownloadProgress</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">progressEvent</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>progressEvent<span class=\"token punctuation\">.</span>total<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">const</span> percentCompleted <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>progressEvent<span class=\"token punctuation\">.</span>loaded <span class=\"token operator\">*</span> <span class=\"token number\">100</span> <span class=\"token operator\">/</span> progressEvent<span class=\"token punctuation\">.</span>total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token function\">setProgress</span><span class=\"token punctuation\">(</span>percentCompleted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 다운로드 링크 만들기</span>\n            <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token function\">createObjectURL</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Blob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">.</span>download <span class=\"token operator\">=</span> <span class=\"token string\">'data.txt'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 혹은 response headers의 Content-Disposition으로 filename 받을 수 있음</span>\n            a<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//클릭이벤트 발생시켜서 다운로드 받도록 함</span>\n\n            <span class=\"token comment\">// 사용이 끝나면 URL을 해제</span>\n            window<span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token function\">revokeObjectURL</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setIsDownloading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드는, 사용자로부터 다운로드 요청이 들어왔을 때, progressBar의 상태를 업데이트하고, 완료된다면 해당 파일로 ObjectURL을 만들어 사용자에게 파일을 다운로드하도록 하는 예시 코드이다.</p>\n<h2 id=\"서버에서-해줘야할-일\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%A0-%EC%9D%BC\" aria-label=\"서버에서 해줘야할 일 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버에서 해줘야할 일</h2>\n<p>서버에서는 file을 전송하기만 하면 된다. 이때, header에 <code class=\"language-text\">Content-Type</code>을 지정해주면 좋을 것이다. 그 예시는 아래와 같다.</p>\n<ul>\n<li>application/octet-stream</li>\n<li>multipart/form-data</li>\n<li>image/jpeg와 같은 특정 파일 포맷</li>\n</ul>\n<p>이러한 식으로 클라이언트에게 파일 포맷을 알려주어 이에 맞게 파일을 생성할 수 있도록 한다.</p>\n<p>추가적으로, headers의 <code class=\"language-text\">Content-Disposition</code>에 filename을 보내주어 클라이언트에서 파일이름을 유지하게 할 수 있다.</p>\n<p>결과는 아래와 같다! progress가 0인 동안에는 서버에서 응답이 안 온 상태이므로 별도의 문구를 보여줄 수 있다.</p>\n<p><img src=\"/9d1abd9cb0281c25b3d2bae680a20aa3/progress.gif\" alt=\"progress\"></p>\n<p>http 통신의 경우, <code class=\"language-text\">TCP/IP</code> 기반의 통신이라 여러 조각으로 나눠져서 전송되므로, 위처럼 progress bar를 구현하기에 적합하다고 볼 수 있다. 하지만 단방향의 stateless한 HTTP 특성상 그 안의 구체적인 정보를 지속적으로 제공받지는 못하므로, <strong>소켓 통신을 통하여 서로의 정보를 주고 받는 방법도 고려해볼 수 있을 것</strong>이다. 소켓은 양방향 통신이므로 대체로 HTTP보다 느릴 수 있다는 점 역시 고려해야한다.</p>","excerpt":"progress bar는 로딩중인 화면을 보여줄 때 사용되는데, 진행도에 따른 비율(%)을 보여주는 progress bar를 구현하기 위해서는 세가지 정도의 방법을 생각해볼 수 있다. web socket 통신 server와 client가 양방향 소통을 하며 얼마나 남았는지를 실시간으로 클라이언트에게 제공한다 http 통신 (단순 다운로드의 경우,) http의 Content-Length를 이용하여 총 크기를 알고, 데이터의 chunk가 도착할때 마다 %를 업데이트한다. 서버의 상태를 받아야한다면, long polling 방식도 고려해볼 수 있겠지만 위의 경우 서버가 지속적으로 데이터를 줘야 하는 경우라면 이는 힘들 것이다. SSE(Server Sent Event) 통신 HTML5의 표준 통신으로, 한번의 AJAX 요청에 대하여 서버의 상태를 지속적으로 보낼 수 있는 프로토콜이다. 서버에 의존적이긴 하지만, 서버에서 로딩에 대한 이유를 설명할 때 유용할 것이다. 오늘은 http 기반의…","frontmatter":{"date":"September 13, 2023","title":"HTTP 통신으로 Progress Bar를 구현해보자 (Progress Event)","categories":"WEB","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/progress-event/"}},"next":{"id":"a9e59f51-8a31-5d15-af62-f704e38b40a4","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Trie 자료구조를 직접 구현해보는 문제이다. <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">링크</a></p>\n<p>요구되는 메서드로는 해당 단어가 존재하는지 찾는 <code class=\"language-text\">search</code>, prefix로 시작하는 단어가 존재하는지 찾는 <code class=\"language-text\">startsWith</code>가 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>트라이(Trie)는 여러 문자열을 트리구조로 저장하는 자료구조로, root(head)에서부터 한 문자씩 이어나가면 된다. 단어의 마지막 문자에는 끝났는지 여부를 기록한다.</p>\n<p>예를 들어, ‘dad’를 저장하면,<code class=\"language-text\">[head] - d - a - d (end)</code>와 같이 저장하면 된다. 이를 위해 python에서는 <code class=\"language-text\">dictionary</code> 자료형을 이용하는 것이 가장 간편하다. key에 문자를 넣고, value에는 다음 node인 dictionary를 넣으면 된다.</p>\n<p>Trie의 장점은 여러 문자열이 저장되어 있을 때, 한 문자열을 찾는 속도가 빠르며 특히 prefix가 같은 문자열을 찾는데 <code class=\"language-text\">O(n)</code>의 시간이 걸리므로 좋다. 예를 들어, prefix가 같은 문자열을 Trie로 표현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[head]\nd\na\nd(end)\tr\nd\t\t\t\tt(end)\ny(end)</code></pre></div>\n<p>위는 dad, daddy, dart의 세 단어를 저장한 Trie를 시각화한 예시이다. 여기서 da-로 시작하는 단어들을 찾기위해서는 d - a 순으로 탐색한 줄기의 모든 자식을 leaf까지 탐색하며 end일때마다 출력하면 된다. 따라서, dad, daddy, dart가 모두 나올 것이다! 이를 선형 탐색을 하려면 문자열의 갯수만큼 많아지므로 어려워 질 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>문자열을 모두 차례대로 넣으므로 O(n)의 시간이 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>문자열의 갯수가 많아질수록 당연히 트라이의 크기는 커질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>처음에는 Node class를 둬서 구현하였다. 직관적이지만, 아무래도 클래스를 선언하는 것은 dictionary보다는 무거울 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        self<span class=\"token punctuation\">.</span>isEnd <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 없다면 노드 새로 만들어줌</span>\n                current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 다음 노드로 이동</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># 마지막 노드에 isEnd 추가</span>\n        current<span class=\"token punctuation\">.</span>isEnd <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>isEnd<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> prefix<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n\n<span class=\"token comment\"># Your Trie object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = Trie()</span>\n<span class=\"token comment\"># obj.insert(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span>\n<span class=\"token comment\"># param_3 = obj.startsWith(prefix)</span></code></pre></div>\n<p>노드에는 다음 노드를 가리키는 next dict가 존재하며, 각 노드에는 본인에서 끝나는 문자열이 있는지 여부를 나타내는 <code class=\"language-text\">isEnd</code> 프로퍼티를 갖는다.</p>\n<ul>\n<li>\n<p>insert함수는 head에서부터 차례대로 문자들을 추가해준다. 만약 이미 해당 문자가 존재한다면, 다음 문자를 그 뒤에 넣어준다.</p>\n</li>\n<li>\n<p>search함수는 current 포인터를 두어 차례대로 모든 문자들을 매칭하였고, 그 이후에는 isEnd가 True인지를 확인하여 해당 단어가 trie에 존재하는지 여부를 확인할 수 있다.</p>\n</li>\n<li>\n<p>startsWith 함수 역시 current 포인터를 두어 판단하는데, prefix만큼 탐색이 끝날때까지 다음 노드가 이어져 있다면 True를 반환하면 된다. (isEnd를 확인할 필요가 없음)</p>\n</li>\n</ul>\n<p>다음은 dictionary만을 이용하여 구현한 Trie의 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"isEnd\"</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 없다면 노드 새로 만들어줌</span>\n                current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"isEnd\"</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n            <span class=\"token comment\"># 다음 노드로 이동</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># 마지막 노드에 isEnd 추가</span>\n        current<span class=\"token punctuation\">[</span><span class=\"token string\">\"isEnd\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">[</span><span class=\"token string\">\"isEnd\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> prefix<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n\n<span class=\"token comment\"># Your Trie object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = Trie()</span>\n<span class=\"token comment\"># obj.insert(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span>\n<span class=\"token comment\"># param_3 = obj.startsWith(prefix)</span></code></pre></div>\n<p>모든 노드는 {“d” : 노드, “a” : 노드, “isEnd” : False}와 같이 문자를 key로 이용하여 가리키며, value는 다음 노드가 될 것이다.</p>\n<p>아래의 방법이 좀 더 빠르고 메모리도 덜 소비하는 것을 제출하여 확인할 수 있다.</p>","frontmatter":{"date":"September 11, 2023","title":"(Alg) LeetCode Top Interview 150 - 208. Implement Trie (Prefix Tree)","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-208/"}},"prev":{"id":"222f2675-aa22-52b5-b6a3-1e530a03e240","html":"<h2 id=\"orm\" style=\"position:relative;\"><a href=\"#orm\" aria-label=\"orm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM</h2>\n<p>ORM은 Object Relational Mapping의 약자.</p>\n<p>RDB의 테이블을 Object와 연결시켜 표현하고, SQL없이 해당 프레임워크의 언어로 데이터를 조작할 수 있도록 인터페이스 및 함수를 제공해준다. 이는 객체 지향 프로그래밍을 일관적으로 구성하는데 유용하다.</p>\n<p>또한, 여러 DB에 대하여 라이브러리가 존재하므로, DB를 변경할 때 생기는 DB의 문법적인 변경사항 등을 고려하지 않을 수 있다. (이식성이 높다)</p>\n<h2 id=\"n1-문제\" style=\"position:relative;\"><a href=\"#n1-%EB%AC%B8%EC%A0%9C\" aria-label=\"n1 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>n+1 문제</h2>\n<p>ORM을 사용하는 경우, 데이터에 접근하는 경우에 SQL 쿼리를 실행하게 된다.</p>\n<p>프레임워크마다 SQL을 실행하는 시점은 조금씩 다른데, 기본적으로는 <code class=\"language-text\">Lazy Loading</code>을 하게 될 것이다.</p>\n<blockquote>\n<p>장고에서는, Pages.objects.all() 등을 실행하면 쿼리셋이 생성되는데, 이때는 DB에 접근하지 않는다.</p>\n<p>쿼리셋 안의 데이터에 접근할 때, DB에 접근하게 된다. 이를 Lazy Loading(지연 로딩)이라고 한다.</p>\n<p>Lazy Loading과 반대되는 것은 Eager Loading(즉시 로딩)이다.</p>\n</blockquote>\n<p>하지만 참조된 테이블이 존재하는 경우, 1번의 쿼리로 가능한 구문이, <strong>참조되는 n개의 행에 접근하기 위해 쿼리를 n번 더 실행하는 경우</strong>가 생기는데, 이를 n+1 problem 이라고 한다.</p>\n<p>예를 들어, 학생과 학교 테이블이 있다고 생각해보자.</p>\n<p>학생들의 학교 이름을 출력한다고 할 때, 장고에서는 다음과 같이 짜볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students <span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># not yet query executed</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token comment\"># n+1 queries</span></code></pre></div>\n<p>이는 원래 SQL로 실행한다면 <code class=\"language-text\">SELECT school.name FROM student WHERE student.school_id = school.id;</code> 로 가능하다.</p>\n<p>하지만, ORM의 lazy loading의 경우 다음과 같은 순서로 실행 될 것이다.</p>\n<p><code class=\"language-text\">SELECT school_id FROM student;</code>하여 얻은 school_id를 각각 <code class=\"language-text\">sid</code>라고 했을 때,</p>\n<p><code class=\"language-text\">SELECT school.name FROM school WHERE school.id = {sid};</code> 를 <strong>추가적으로 n번(학생의 수만큼) 수행하게 되는 것이다</strong>.</p>\n<p>DB 쿼리를 실행하여 값을 가져오는 것은 (컴퓨터 기준으로 IO를 발생시키는) 오래걸리는 일이므로, 최소화 할 필요가 있다!</p>\n<p>장고에서는 EAGER loading (즉시 로딩)을 통하여 미리 참조된 데이터를 가져와 놓을 수 있는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students<span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span>selected_related<span class=\"token punctuation\">(</span><span class=\"token string\">'school'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># selected_related</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\t<span class=\"token comment\"># 1 query</span></code></pre></div>\n<p>selected_related를 통하여 미리 학교에 대한 정보를 JOIN하여 가져오는 쿼리셋을 만들고, 이후에 값을 가져와 n+1 문제를 해결할 수 있다.</p>\n<p>추가적으로 <code class=\"language-text\">prefetch_related</code>를 이용하여 모든 relationship에 대하여 사용 가능한 방법도 있다.</p>\n<p><a href=\"https://hckcksrl.medium.com/django-n-1-problem-d986b93f5d3e\">참고</a></p>\n<h2 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시</h2>\n<p>n+1 문제를 시각화하기 위하여 query의 수행 횟수를 출력해보자.</p>\n<p>django에서는 connection.queries에 수행한 쿼리들이 배열의 형태로 저장된다. 이를 api단에서 출력하는 테스트를 만들 수 있다.</p>\n<p>우선, DB 스키마는 다음과 같다.</p>\n<p><img src=\"https://github.com/choieastsea/notion-be/blob/master/schema.png?raw=true\" alt=\"schema\"></p>\n<p>트리 형태의 page를 저장하기 위한 데이터 베이스 구조로, page_id는 각각 page_trees의 ancestor과 descendant가 될 수 있다.</p>\n<p>page_trees 테이블에서 page_id가 1인 page를 ancestor로 하는 page_id를 출력하는 예시를 보자. Lazy Loading 방식과 Eager Loading 방식으로 구현해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryTest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># LAZY LOADING</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryImproved</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># EAGER LOADING (참조된 Page table도 가져옴)</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>select_related<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>두 api의 결과는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>detail(쿼리의 결과)는 같지만, 쿼리의 실행횟수가 LazyLoading 방식은 5번(해당하는 page의 수인 n만큼) 더 일어난 것을 확인해볼 수 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>이와 같이, <strong>참조된 테이블의 값을 지연 로딩을 통하여 가져오는 경우에는 n+1 문제가 발생</strong>할 수 있다. 관찰하다가 해당 쿼리가 불필요하게 많이 실행된다면, 해당 부분에 즉시 로딩을 도입하는 방법이 좋을 것이다. 그렇다고 모든 쿼리를 즉시 로딩을 한다면 역시 불필요한 쿼리가 실행되므로 로깅 등으로 기록하고 관찰하는 것이 좋을 것이다!</p>","frontmatter":{"date":"September 14, 2023","title":"(DB) n+1 문제와 해결책 (Django)","categories":"BE","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/BE-n+1/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/progress-event/","nextSlug":"/Alg-LC-208/","prevSlug":"/BE-n+1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}