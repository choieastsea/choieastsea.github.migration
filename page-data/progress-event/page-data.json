{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/progress-event/",
    "result": {"data":{"cur":{"id":"7a33879a-a69c-5e3b-9ee1-0859c7893692","html":"<p>progress bar는 로딩중인 화면을 보여줄 때 사용되는데, 진행도에 따른 비율(%)을 보여주는 progress bar를 구현하기 위해서는 두가지 정도의 방법을 생각해볼 수 있다.</p>\n<ul>\n<li>\n<p>web socket 통신</p>\n<p>server와 client가 양방향 소통을 하며 얼마나 남았는지를 실시간으로 클라이언트에게 제공한다</p>\n</li>\n<li>\n<p>http 통신</p>\n<p>(단순 다운로드의 경우,) http의 Content-Length를 이용하여 총 크기를 알고, 데이터의 chunk가 도착할때 마다 %를 업데이트한다.</p>\n</li>\n</ul>\n<p>http 기반의 방법으로 이를 구현해보자. Web API의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent\">Progress Event</a>를 알면 데이터가 얼마나 load되고 있는지 파악할 수 있으므로, 이를 이용하자!</p>\n<h2 id=\"progress-event란\" style=\"position:relative;\"><a href=\"#progress-event%EB%9E%80\" aria-label=\"progress event란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Progress Event란</h2>\n<blockquote>\n<p>The ProgressEvent Object handles events that occur when loading external resources.</p>\n</blockquote>\n<p>Progress Event 객체는 다음과 같은 속성을 갖는다.</p>\n<ul>\n<li>lengthComputable : 작업량이 계산 가능한 타입인지</li>\n<li>loaded : 현재 progress가 진행된 정도</li>\n<li>total : 총 작업의 양</li>\n</ul>\n<p>total에 대한 loaded의 비율을 이용하여 progress를 계산할 수 있다.</p>\n<h2 id=\"typescript-react에서-progress-bar-만들기\" style=\"position:relative;\"><a href=\"#typescript-react%EC%97%90%EC%84%9C-progress-bar-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"typescript react에서 progress bar 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript React에서 progress bar 만들기</h2>\n<p>file을 업로드하거나, 다운로드 하는 경우에 전체 파일의 크기 중 보내거나 받은 바이트의 비율을 이용하여 progress bar를 구현할 수 있다. axios 라이브러리에서는 이를 위하여 <code class=\"language-text\">progressEvent</code> 객체를 인자로 받는 <code class=\"language-text\">onDownloadProgress</code> 콜백함수가 제공된다. (업로드할 때에는 <code class=\"language-text\">onUploadProgress</code>를 사용하면 될 것)</p>\n<p>하지만, <code class=\"language-text\">typescript</code>에서는 <code class=\"language-text\">progressEvent.total</code>이 <u>optional</u>이므로 Math.round()에 인자로 사용될 수 없다. 따라서, 아래와 같이 <strong>not undeifined를 보장한 progressEvent.total을 값으로 사용</strong>할 수 있다.</p>\n<p>참고로, response의 headers에 있는 <code class=\"language-text\">Content-Length</code>에 해당하는 값이 progressEvent.total인 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleDownloadFile</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setIsDownloading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">setProgress</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> response<span class=\"token operator\">:</span> AxiosResponse<span class=\"token operator\">&lt;</span>Blob<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">authAxios</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">foo/bar/</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n                responseType<span class=\"token operator\">:</span> <span class=\"token string\">'blob'</span><span class=\"token punctuation\">,</span>\n                <span class=\"token function-variable function\">onDownloadProgress</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">progressEvent</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>progressEvent<span class=\"token punctuation\">.</span>total<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">const</span> percentCompleted <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>progressEvent<span class=\"token punctuation\">.</span>loaded <span class=\"token operator\">*</span> <span class=\"token number\">100</span> <span class=\"token operator\">/</span> progressEvent<span class=\"token punctuation\">.</span>total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token function\">setProgress</span><span class=\"token punctuation\">(</span>percentCompleted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 다운로드 링크 만들기</span>\n            <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token function\">createObjectURL</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Blob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">.</span>download <span class=\"token operator\">=</span> <span class=\"token string\">'data.txt'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 혹은 response headers의 Content-Disposition으로 filename 받을 수 있음</span>\n            a<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//클릭이벤트 발생시켜서 다운로드 받도록 함</span>\n\n            <span class=\"token comment\">// 사용이 끝나면 URL을 해제</span>\n            window<span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token function\">revokeObjectURL</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setIsDownloading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드는, 사용자로부터 다운로드 요청이 들어왔을 때, progressBar의 상태를 업데이트하고, 완료된다면 해당 파일로 ObjectURL을 만들어 사용자에게 파일을 다운로드하도록 하는 예시 코드이다.</p>\n<h2 id=\"서버에서-해줘야할-일\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%A0-%EC%9D%BC\" aria-label=\"서버에서 해줘야할 일 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버에서 해줘야할 일</h2>\n<p>서버에서는 file을 전송하기만 하면 된다. 이때, header에 <code class=\"language-text\">Content-Type</code>을 지정해주면 좋을 것이다. 그 예시는 아래와 같다.</p>\n<ul>\n<li>application/octet-stream</li>\n<li>multipart/form-data</li>\n<li>image/jpeg와 같은 특정 파일 포맷</li>\n</ul>\n<p>이러한 식으로 클라이언트에게 파일 포맷을 알려주어 이에 맞게 파일을 생성할 수 있도록 한다.</p>\n<p>추가적으로, headers의 <code class=\"language-text\">Content-Disposition</code>에 filename을 보내주어 클라이언트에서 파일이름을 유지하게 할 수 있다.</p>\n<p>결과는 아래와 같다! progress가 0인 동안에는 서버에서 응답이 안 온 상태이므로 별도의 문구를 보여줄 수 있다.</p>\n<p><img src=\"/9d1abd9cb0281c25b3d2bae680a20aa3/progress.gif\" alt=\"progress\"></p>\n<p>http 통신의 경우, <code class=\"language-text\">TCP/IP</code> 기반의 통신이라 여러 조각으로 나눠져서 전송되므로, 위처럼 progress bar를 구현하기에 적합하다고 볼 수 있다. 하지만 단방향의 stateless한 HTTP 특성상 그 안의 구체적인 정보를 지속적으로 제공받지는 못하므로, <strong>소켓 통신을 통하여 서로의 정보를 주고 받는 방법도 고려해볼 수 있을 것</strong>이다. 소켓은 양방향 통신이므로 대체로 HTTP보다 느릴 수 있다는 점 역시 고려해야한다.</p>","excerpt":"progress bar는 로딩중인 화면을 보여줄 때 사용되는데, 진행도에 따른 비율(%)을 보여주는 progress bar를 구현하기 위해서는 두가지 정도의 방법을 생각해볼 수 있다. web socket 통신 server와 client가 양방향 소통을 하며 얼마나 남았는지를 실시간으로 클라이언트에게 제공한다 http 통신 (단순 다운로드의 경우,) http의 Content-Length를 이용하여 총 크기를 알고, 데이터의 chunk가 도착할때 마다 %를 업데이트한다. http 기반의 방법으로 이를 구현해보자. Web API의 Progress Event를 알면 데이터가 얼마나 load되고 있는지 파악할 수 있으므로, 이를 이용하자! Progress Event란 The ProgressEvent Object handles events that occur when loading external resources. Progress Event 객체는 다음과 같은 속성을 갖는다. lengthC…","frontmatter":{"date":"September 13, 2023","title":"HTTP 통신으로 Progress Bar를 구현해보자 (Progress Event)","categories":"WEB","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/progress-event/"}},"next":{"id":"8ab6fe9a-0b1a-5ff8-b900-b8bbe721f0d9","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>저번에 구현한 <code class=\"language-text\">Trie</code> 자료구조를 이용하여 search함수를 구현하는 문제이다. <a href=\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\">링크</a></p>\n<p>search함수는 208번 문제와 다르게 ’.’가 포함될 수 있는데, 이는 모든 문자가 가능한 경우를 의미한다. 예를 들어, ‘dad’, ‘pad’, ‘mad’가 들어있는 트라이에서 <code class=\"language-text\">search('.ad')</code>는 3 단어를 모두 리턴할 것이다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>트라이에 대한 구현은 <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">208번</a>에서 했으니, 이번에는 search함수에서 ’.’를 처리하는 부분에 중점 두어 해결해보자.</p>\n<p>여러 방법이 존재하겠지만, ’.’의 경우에는 결국 해당 노드에서 가능한 모든 다음 노드로 각각 search를 수행해야 한다. 나는 <code class=\"language-text\">deque</code> 자료구조를 이용하여 search 함수를 구현하였다. trie를 탐색하면서, 입력 문자열을 하나씩 matching하다가 ’.’를 만나면, 특정 노드가 아닌 모든 노드로 뻗어나가야 한다. 나는 이를 BFS의 구조와 유사하다고 판단하여 탐색할 노드들을 queue에 넣고, depth별로(문자별로) 모든 큐의 노드들을 탐색하는 방법으로 구현하였다. 마지막까지 탐색했다면 <code class=\"language-text\">isEnd</code> 여부를 검사하고, 하나라도 가능한 경우가 있다면 True를 리턴한다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<p>search함수의 시간복잡도는 아래와 같을 것이다.</p>\n<ul>\n<li>\n<p>Time complexity: O(size of trie)</p>\n<p>최악의 경우, ’…’와 같이 모든 트라이의 공간을 탐색할 수 있으므로 트라이의 크기만큼 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>deque를 각 단계마다 비우긴 하지만, deque의 크기는 각 단계별 너비, 즉 문자열의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WordDictionary</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'isEnd'</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">addWord</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'isEnd'</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">}</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span>\n        current<span class=\"token punctuation\">[</span><span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        \n    <span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>self<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> ch <span class=\"token keyword\">in</span> word<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q, ch)</span>\n            <span class=\"token keyword\">if</span> ch <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    current <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span>v <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 가능한 다음 노드들을 모두 탐색함</span>\n                        <span class=\"token keyword\">if</span> k <span class=\"token operator\">!=</span> <span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">:</span>\n                            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>     \n                <span class=\"token comment\"># 일반 문자라면, 해당 문자가 있는지 확인하고 넣어줌. 없는 것들은 무시</span>\n                <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    current <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">if</span> ch <span class=\"token keyword\">in</span> current<span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> el <span class=\"token keyword\">in</span> q<span class=\"token punctuation\">:</span> <span class=\"token comment\"># 마지막 단계의 노드들이 deque에 존재할 것</span>\n            <span class=\"token keyword\">if</span> el<span class=\"token punctuation\">[</span><span class=\"token string\">'isEnd'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n              \t<span class=\"token comment\"># 해당 단어가 존재함!</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n<span class=\"token comment\"># Your WordDictionary object will be instantiated and called as such:</span>\n<span class=\"token comment\"># obj = WordDictionary()</span>\n<span class=\"token comment\"># obj.addWord(word)</span>\n<span class=\"token comment\"># param_2 = obj.search(word)</span></code></pre></div>\n<p>처음에는 q에 head를 넣은 상태로 탐색을 시작한다.</p>\n<p>문자열을 한 문자씩 탐색하면서 해당 Node가 존재하는지를 판단하는데, ’.’를 만난다면, q를 비워주면서 해당 노드에서 가능한 모든 다음 노드들을 queue에 넣는다. 이전 노드는 앞에 있고, 넣을 노드는 뒤에 있어야하므로 <code class=\"language-text\">stack</code>보다는 <code class=\"language-text\">queue</code>가 적합하다고 볼 수 있다.</p>\n<p>다른 일반 문자라면, queue의 모든 노드에서 해당 문자의 노드를 갖는지 확인하고, 가능한 노드들만 다음 단계로 넘긴다.</p>\n<p>모든 word의 문자들을 탐색한 이후에는 여태까지 살아남은(가능한) 문자열들이 존재할 것이다. 여기에서 끝나야 하나의 문자열로 인정되므로, isEnd를 확인하며 하나라도 존재하면 True를 리턴하도록 한다.</p>","frontmatter":{"date":"September 11, 2023","title":"(Alg) LeetCode Top Interview 150 - 211. Design Add and Search Words Data Structure","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-211/"}},"prev":{"id":"79adc579-2fb2-564c-8a24-62a4c576ade5","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>단어에서 한 글자만 바뀐 단어로 바꿀 수 있을 때, 목표 단어까지 도달하는데 최소 얼마나 걸리는지를 구하는 문제이다. <a href=\"https://leetcode.com/problems/word-ladder/\">링크</a></p>\n<p>바뀐 단어 역시 주어진 wordList 안에 있어야하므로, search space를 탐색해야한다고 유추할 수 있다. 참고로, 입력되는 단어의 길이는 모두 같다고 가정한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>search space에서 root node에서 정답 노드까지의 최단거리를 구해야하므로 <code class=\"language-text\">BFS</code>를 떠올려볼 수 있다.</p>\n<p>한 글자만 다른 단어로 해공간을 확장하는 것이 약간 어렵지만, 나의 경우 단순한 문자열 비교를 통하여 구현하였다. (그래서 그런지 너무 느리다)</p>\n<p>단어마다 visited를 두어, 이미 방문했다면 <code class=\"language-text\">deque</code>에 넣지 않도록 하였고, 거리를 구하기 위하여 큐에 넣을 때, <code class=\"language-text\">(단어, depth)</code>를 넣어주도록 하였다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(w*n^2)</p>\n<p>단어의 길이가 w이고, 갯수가 n개일 때, w개의 글자들을 각각 비교하는 연산(w*n)이 단어마다 존재하므로 <code class=\"language-text\">O(w*n^2)</code>만큼의 시간이 걸린다고 볼 수 있다. 단어의 갯수가 최대 5만개이므로, 간신히 통과한다고 볼 수 있다…ㅎㅎ</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>queue의 크기는 단어의 갯수에 비례할 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">ladderLength</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> beginWord<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> endWord<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> wordList<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        한글자씩 다른 단어들로 search space를 확장하면서 BFS를 수행\n        확장시, 최초 마주치는 단어는 이후에 선택되지 않도록 해야함\n        최단 거리에 위치한 endWord 발견시 len(depth)를 리턴\n        \"\"\"</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>beginWord<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># word, depth</span>\n        visited<span class=\"token punctuation\">[</span>beginWord<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            curWord<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 주변으로 확장</span>\n            <span class=\"token keyword\">for</span> word <span class=\"token keyword\">in</span> wordList<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> word <span class=\"token keyword\">in</span> visited<span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># 한 글자만 다른 단어로 공간 확장</span>\n                    diffCnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> curWord<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                            diffCnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                            <span class=\"token keyword\">if</span> diffCnt <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                                <span class=\"token keyword\">break</span>\n                    <span class=\"token keyword\">if</span> diffCnt <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        <span class=\"token comment\"># 답 발견하면 종료</span>\n                        <span class=\"token keyword\">if</span> word <span class=\"token operator\">==</span> endWord<span class=\"token punctuation\">:</span>\n                            <span class=\"token keyword\">return</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        visited<span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span></code></pre></div>\n<p>단어간의 edit distance를 구하는 더 좋은 방법이 있다면 빨라질 것이다. (이 방법은 메모리에서만 96%를 기록하였다) 찾아보니, 단어에서 한 글자씩 *로 대체하여 공간을 탐색하는 방법이 있던데 바로 생각해내기엔 어려운 것 같다.</p>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 127. Word Ladder","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-127/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/progress-event/","nextSlug":"/Alg-LC-211/","prevSlug":"/Alg-LC-127/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}