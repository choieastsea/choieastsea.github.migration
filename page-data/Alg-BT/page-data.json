{"componentChunkName":"component---src-templates-blog-template-js","path":"/Alg-BT/","result":{"data":{"cur":{"id":"6d534a9a-37c1-510b-8a91-54183d86d5ae","html":"<p>몇개의 문제와 함께 백트래킹 문제를 공부해보자.</p>\n<h2 id=\"backtracking-idea\" style=\"position:relative;\"><a href=\"#backtracking-idea\" aria-label=\"backtracking idea permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BackTracking idea</h2>\n<p>보통 경우의 수를 만들어가는 문제에서 쓰이는 알고리즘으로, <code class=\"language-text\">search space</code>를 확장하면서 <strong>특정 조건(종료조건)을 만족할 때까지 가능한 모든 경우를 탐색할 때 적용</strong>할 수 있다.</p>\n<p>모든 상태 공간을 탐색하는 것이므로 여러가지 공간 탐색 알고리즘(BFS, DFS, A* search) 등을 이용할 수 있지만, 보통의 경우 재귀적인 DFS로 간단하게 해결 가능하다. BFS의 경우 tree’s width가 넓어지면 queue의 크기가 커져 메모리 초과가 날 수 있으므로 종료조건만 명확하다면 <strong>DFS가 대체로 좋을 것이다</strong>.</p>\n<p>내가 생각하는 백트래킹 문제의 핵심은 아래와 같다.</p>\n<ol>\n<li>상태 공간 그리기</li>\n<li>종료 조건 확인</li>\n<li><strong>복귀</strong></li>\n</ol>\n<h2 id=\"dfsrecursion\" style=\"position:relative;\"><a href=\"#dfsrecursion\" aria-label=\"dfsrecursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DFS(recursion)</h2>\n<p>온라인 저지 문제들과 함께 기본적인 BT문제를 풀어보자.</p>\n<h3 id=\"leetcode-46-permutaions\" style=\"position:relative;\"><a href=\"#leetcode-46-permutaions\" aria-label=\"leetcode 46 permutaions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LeetCode 46. Permutaions</h3>\n<p>distinct integer로 구성된 배열이 주어졌을 때, 모든 순열을 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&#x26;envId=top-interview-150\">링크</a></p>\n<p>4P4의 상태공간을 일부만 그려보았다. 색칠된 경우는 종료 조건이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACbUlEQVQoz5VSTWhTQRCepCnaWrWgVCiIPxdF0HgRhR48VU8evIhQCApeFA+KZ0F78WIFQRGP3h6UUiSiR62lSluhJxFM2kIMBEJi8t7Ozs6+t3kr82iC1z4YdmZn9nvffDMAALC+vg5xHIPWWiznvc9772F5eRlmZ2fBe58zxkjNa2utd85NMbPcFyRXKpWyGudcHvqASZIAEeWISJKZraysFIIgGFpdXR2WeHt7+2AURRfr9fq+6enpXL9OPjmdcwDlchmCIABmlj8IixNa68dhGJ6Too2NjQys2+1OKKUehWF4QeIgCPKIOKOUulepVPYg4h1jzK0BG+fcsLCL43hG2orj+D4iSm6PtJem6SVm9tbat1EUyf2QtfYHM9ecc5PW2p/MvDUATNN04C8sLIz2fTGRQ85qtXq4fyd6y1ksFvNCJAzDsW63OyK6ZQ+Y+TwiXo+i6CQi3uh0OseVUleZecoYM4WIDxuNxohS6orW+q73Xjq6RkQlYStDE+ZgjBlqtVoCvEhENkmSl1prae2JMWaLiH4x8zsiSp1zRSKaJyLtvRetvxFR03s/LmyJKA/9qdZqtYlms3lmp53JdrtdMMYcNcYcabVaBSKakBwijmqtD4lERDSGiOO9Xm8gD2hNZY36s+xUp9MRsHmN+qMMY0cKmbB0ku2aEBBL0zTzRcu+/nNzcwCa8Tka9cp7v/fyzbOgjXqmjXojgFLElvPySNZKYgH+z5eFH+xjpmFl0R37/cGctpZBVTxU32fxKUsy2QQ+3Tawq2/rq/qz+SVs17/H+58+eAGbS1Flcyn821hLDzTWepLP7QbwHyZTfXQKaGsuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"permutation\"\n        title=\"permutation\"\n        src=\"/static/a6a813483c4097de99a7cbc286073db3/37523/permutation.png\"\n        srcset=\"/static/a6a813483c4097de99a7cbc286073db3/e9ff0/permutation.png 180w,\n/static/a6a813483c4097de99a7cbc286073db3/f21e7/permutation.png 360w,\n/static/a6a813483c4097de99a7cbc286073db3/37523/permutation.png 720w,\n/static/a6a813483c4097de99a7cbc286073db3/302a4/permutation.png 1080w,\n/static/a6a813483c4097de99a7cbc286073db3/07a9c/permutation.png 1440w,\n/static/a6a813483c4097de99a7cbc286073db3/49a0e/permutation.png 5288w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>basic case (배열의 크기가 nums의 크기가 될 때) : 해당 배열을 정답배열에 추가한다</li>\n<li>recursion case (not basic) : 현재 공간에서 방문하지 않은 숫자를 방문처리하고 search space를 확장한다(다음 BT함수를 실행). 이후에는 방금 방문한 숫자를 안방문 처리한다!</li>\n</ul>\n<p>방문했던 숫자를 방문 이후에 False처리하는 이유는 sibling node에서 해당 숫자를 방문하기 위함이다. 재귀적으로 BT를 수행하면 다음 경우를 찾기 위해서는 sibling과 다른 부분은 <strong>복원 시켜줘야한다</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        permList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">bt</span><span class=\"token punctuation\">(</span>perm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>perm<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n              \t<span class=\"token comment\"># basic case</span>\n                permList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>perm<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n              \t<span class=\"token comment\"># recursion case</span>\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    bt<span class=\"token punctuation\">(</span>perm<span class=\"token operator\">+</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n        bt<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> permList</code></pre></div>\n<p>가장 기본적인 BackTracking 문제로, <strong>확장하며 방문한 숫자는 다음 경우의 수를 탐색할 때(확장한 공간에서의 탐색이 종료되었을 때) 방문여부를 복원 시켜줘야한다는 것이 핵심</strong>이다.</p>\n<h3 id=\"leetcode-77-combinations\" style=\"position:relative;\"><a href=\"#leetcode-77-combinations\" aria-label=\"leetcode 77 combinations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LeetCode 77. combinations</h3>\n<p>n, k가 주어졌을 때, 1~n까지의 수 중에서 k개를 뽑는 모든 경우의 수를 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/combinations/?envType=study-plan-v2&#x26;envId=top-interview-150\">링크</a></p>\n<p>조합이므로 <strong>순서가 달라도 같은 구성이면 같은 경우의 수로 판단함</strong>을 유의하자.</p>\n<p>4C2의 상태공간을 그려보면 아래와 같다. 우리는 아래 색칠한 경우들을 모아서 리턴하면 된다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGElEQVQozy2QP2hTURjFT5MnOjjpUpxE3LJ1E6V0cJEigmOhi7uLHcyiToKKHTrUvRAQrQ6hBZOQNpjcl2SwIAQcGpPmvaQmTZNXzOv9+177yY0dDpzvd8/94HwIwxBHR0cYDocgopnl5WXk83lks1mkUim4rotGowFjTF1rTXEcP1ZK2WyCiLC0tIRcLjf9yzmfQb/fR7PZRLFYtBCZTCaZy+WcbDab3N7ednZ2dhwACMNwgXP+LAiCWTvv7u46Nr+xsZFgjF2yfjKZAL7vIwiC6bLj4+NbpVLpSjqdnrFLt7a2nM3NzeTq6mqi3W7fsBmrQqHgZDIZZzAY3K5UKpctGwwGN8fj8VUbSFpgjEkrpcgY8z6KomkFWyuOY0RRtHLxti6ltLPVC8u01i/jOJ678C2c/D5ziCJoqeelVJ+lUItEMU72z51RW05rKanvCSE+SiEfEU3vB630guDiixTyvtb6upTyg1LqOfr1M9AvAg3/15mqRzA/CV7tFOMKgf5c8AlhVCU0iyGCjoQ4JPAeQZgQQghorQHflU88Jl71auaBXxVr3Zq667tq0XPFu141muswvu4x8ZZOyfFdudJh/FPX1bPdmprvMP6tW1MP/bLB375ylFRJeEy2DipcHtYjdlA+pV7VrPmu+mr9YT1+4zHR8pjYH+3RNZ/JfKfCz3tVc6db1U8PytzmXw9/EEZ7lGh9D/EPBbLIkHNhxEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"combination\"\n        title=\"combination\"\n        src=\"/static/737edd12cf030c0a7bae73f66bb5831c/37523/combination.png\"\n        srcset=\"/static/737edd12cf030c0a7bae73f66bb5831c/e9ff0/combination.png 180w,\n/static/737edd12cf030c0a7bae73f66bb5831c/f21e7/combination.png 360w,\n/static/737edd12cf030c0a7bae73f66bb5831c/37523/combination.png 720w,\n/static/737edd12cf030c0a7bae73f66bb5831c/302a4/combination.png 1080w,\n/static/737edd12cf030c0a7bae73f66bb5831c/07a9c/combination.png 1440w,\n/static/737edd12cf030c0a7bae73f66bb5831c/2fb9e/combination.png 4648w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>재귀적으로 깊이우선 탐색을 구현하면 된다.</p>\n<ul>\n<li>Basic Case (배열의 크기가 k가 됨) : 해당 배열을 정답 배열(combList)에 추가한다</li>\n<li>Recursion Case (not basic) : 현재 배열의 가장 큰 수보다 더 큰 수를 추가하여 탐색한다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">combine</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        combList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">bt</span><span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">,</span> curMax<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> k<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># basic case</span>\n                combList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># recursion case</span>\n                <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>curMax<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># 가장 최근에 넣은 값이 가장 큰 값이 되도록 BT 확장</span>\n                    bt<span class=\"token punctuation\">(</span>comb<span class=\"token operator\">+</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n        bt<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> combList</code></pre></div>\n<p>조합이므로 겹치지 않게 하기 위하여 현재 수보다 큰 수를 넣어주는 로직을 추가하였다. 만약 comb:[1], curMax: 1 인 상태라면, <code class=\"language-text\">bt(comb=[1,2],curMax=2)</code>,<code class=\"language-text\">bt(comb=[1,3],curMax=3)</code> , <code class=\"language-text\">bt(comb=[1,4],curMax=4)</code>를 실행할 것이다.</p>\n<p>여기서는 조합을 숫자들의 대소관계를 이용하였으므로, visited를 사용하지 않고 하나의 curMax만을 이용하여 구현할 수 있었다.</p>\n<p>좀 더 응용한 문제를 살펴보자!</p>\n<h3 id=\"종료조건이-깊이가-아닌-경우-leetcode-39-combination-sum\" style=\"position:relative;\"><a href=\"#%EC%A2%85%EB%A3%8C%EC%A1%B0%EA%B1%B4%EC%9D%B4-%EA%B9%8A%EC%9D%B4%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B2%BD%EC%9A%B0-leetcode-39-combination-sum\" aria-label=\"종료조건이 깊이가 아닌 경우 leetcode 39 combination sum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>종료조건이 깊이가 아닌 경우, LeetCode 39. Combination Sum</h3>\n<p><a href=\"https://leetcode.com/problems/combination-sum/description/?envType=study-plan-v2&#x26;envId=top-interview-150\">이 문제</a>처럼 종료조건이 깊이가 아닐 수도 있다. 하지만 원하는 경우(basic case)가 나올때까지 DFS탐색을 하는 것은 같다!</p>\n<p>해당 문제에서는 distinct positive integer로 구성된 배열에서 <u>숫자를 중복 사용하여 배열의 합이 target이 되도록 하는 조합</u>을 찾는 문제이다. 따라서 종료조건과 확장 방법이 조금 달라질 것이다. (너무 형식에 의존하지 않도록 하자)</p>\n<ol>\n<li>basic case(현재까지의 합이 target과 일치하는 경우) : 정답 배열에 추가</li>\n<li>recursion case(합이 target보다 작은 경우) : <strong>curMax이상의 값만 넣어</strong>서 다음 해공간을 탐색한다</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">combinationSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> candidates<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        combList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">bt</span><span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">,</span> currentSum<span class=\"token punctuation\">,</span> curMax<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> currentSum <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># basic case</span>\n                combList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span>\n            <span class=\"token keyword\">elif</span> currentSum <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># recursion case : number can be used multiple times</span>\n                <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> candidates<span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># 작은순서대로 comb 배열에 들어가도록 함 (추가시, 현재 최대 이상의 값이 들어가도록)</span>\n                    <span class=\"token keyword\">if</span> num <span class=\"token operator\">>=</span> curMax<span class=\"token punctuation\">:</span>\n                        bt<span class=\"token punctuation\">(</span>comb<span class=\"token operator\">+</span><span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> currentSum <span class=\"token operator\">+</span> num<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span>\n        bt<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> combList</code></pre></div>\n<p>curMax는 이전 문제와 비슷하게, 현재 search space의 줄기(from tree)에서의 comb 배열에 사용된 최댓값이다. <strong>조합은 모든 숫자의 배열이 상관 없으므로, 내림차순 혹은 오름차순으로 배열을 만들면 오로지 하나의 조합만을 만들어 낼 수 있는 trick을 이용</strong>하는 것이다.</p>\n<h3 id=\"search-space의-타입이-다른-경우-leetcode-79-word-search\" style=\"position:relative;\"><a href=\"#search-space%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EA%B2%BD%EC%9A%B0-leetcode-79-word-search\" aria-label=\"search space의 타입이 다른 경우 leetcode 79 word search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>search space의 타입이 다른 경우, LeetCode 79. Word Search</h3>\n<p><a href=\"https://leetcode.com/problems/word-search/\">이 문제</a>처럼 해 공간이 숫자 배열이 아닐 수도 있다. 인터넷에 Counter를 이용한 더 빠른 풀이가 있지만, 오늘 배운 내용과 유사하게 풀어보자.</p>\n<p>주변 글자로 탐색해가며 word와 일치하는 문자열을 만들 수 있는지 여부를 반환하면 된다.</p>\n<ol>\n<li>basic case (탐색 완료한 경우) : 결과를 업데이트하고 종료</li>\n<li>recursion case (not basic) : 방문하지 않은 주변 4방향의 칸을 확인하고, 문자열이 만들어진다면 그 공간으로 확장. 이후에는 방금 방문처리한 곳을  <strong>복원 해준다</strong>.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">exist</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">expand</span><span class=\"token punctuation\">(</span>curRow<span class=\"token punctuation\">,</span> curCol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token triple-quoted-string string\">\"\"\"\n            현재 칸에서 방문하지 않은 인접한 4방향의 다음 칸으로 확장\n            \"\"\"</span>\n            nextList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n            directions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">for</span> dr<span class=\"token punctuation\">,</span> dc <span class=\"token keyword\">in</span> directions<span class=\"token punctuation\">:</span>\n                nextRow<span class=\"token punctuation\">,</span> nextCol <span class=\"token operator\">=</span> curRow <span class=\"token operator\">+</span> dr<span class=\"token punctuation\">,</span> curCol <span class=\"token operator\">+</span> dc\n                <span class=\"token keyword\">if</span> nextRow <span class=\"token operator\">&lt;=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token keyword\">and</span> nextRow <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> nextCol <span class=\"token operator\">&lt;=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token keyword\">and</span> nextCol <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                        nextList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>nextRow<span class=\"token punctuation\">,</span> nextCol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> nextList\n                \n        <span class=\"token keyword\">def</span> <span class=\"token function\">bt</span><span class=\"token punctuation\">(</span>curRow<span class=\"token punctuation\">,</span> curCol<span class=\"token punctuation\">,</span> wordLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">nonlocal</span> result\n            <span class=\"token keyword\">if</span> wordLength <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># basic case</span>\n                result <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                <span class=\"token keyword\">return</span>\n            <span class=\"token comment\"># recursion case</span>\n            <span class=\"token keyword\">for</span> nextRow<span class=\"token punctuation\">,</span> nextCol <span class=\"token keyword\">in</span> expand<span class=\"token punctuation\">(</span>curRow<span class=\"token punctuation\">,</span> curCol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span>wordLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    bt<span class=\"token punctuation\">(</span>nextRow<span class=\"token punctuation\">,</span> nextCol<span class=\"token punctuation\">,</span> wordLength <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                    visited<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n        result <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># 첫 글자 일치하면 BT시작</span>\n                    visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n                    visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    bt<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>j<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">if</span> result<span class=\"token punctuation\">:</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></code></pre></div>\n<p>expand함수를 만들어서, 방문하지 않았고 board의 범위를 넘어서지 않는 곳으로 다음 좌표들의 배열을 리턴하도록 하였다.</p>\n<p>결과를 기록하기 위하여 클래스 내부 함수에서 외부 함수의 변수에 접근하기 위하여 <code class=\"language-text\">nonlocal</code> 키워드를 사용하였으니 참고하자. BackTracking의 경우, 가능한 마지막 depth에서 종료되므로 리턴값을 가져오기가 까다로워 위처럼 사용하였다.</p>\n<h2 id=\"pythonic-way---itertools\" style=\"position:relative;\"><a href=\"#pythonic-way---itertools\" aria-label=\"pythonic way   itertools permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pythonic way - itertools</h2>\n<p>파이썬에는 경우의 수를 만들어주는 아주 감사한 라이브러리(<code class=\"language-text\">itertools</code>)가 내장되어있다.</p>\n<p>위의 문제들을 itertools로 가볍게 풀어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> itertools\n<span class=\"token comment\"># 46</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> itertools<span class=\"token punctuation\">.</span>permutations<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 77</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">combine</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> itertools<span class=\"token punctuation\">.</span>combinations<span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>k<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 39 -> 이 코드는 시간초과됨</span>\n<span class=\"token keyword\">import</span> itertools\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">combinationSum</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> candidates<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        k <span class=\"token operator\">=</span> target <span class=\"token operator\">//</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 최대 중복 허용 갯수</span>\n        combList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> l <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>k<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> comb <span class=\"token keyword\">in</span> itertools<span class=\"token punctuation\">.</span>combinations_with_replacement<span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> <span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">:</span>\n                    combList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>comb<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> combList</code></pre></div>\n<p>위처럼 <code class=\"language-text\">combinations</code>, <code class=\"language-text\">permutations</code>, <code class=\"language-text\">combinations_with_replacement</code> (중복 조합), <code class=\"language-text\">product</code>(중복 순열을 포함한 데카르트 곱) 을 이용하여 단순한 경우의 수는 바로 2차원 배열을 얻을 수 있는 방법이 있으니 참고하면 좋을 것이다!</p>\n<p><a href=\"https://docs.python.org/ko/3/library/itertools.html\">공식 문서 링크</a></p>","excerpt":"몇개의 문제와 함께 백트래킹 문제를 공부해보자. BackTracking idea 보통 경우의 수를 만들어가는 문제에서 쓰이는 알고리즘으로, 를 확장하면서 특정 조건(종료조건)을 만족할 때까지 가능한 모든 경우를 탐색할 때 적용할 수 있다. 모든 상태 공간을 탐색하는 것이므로 여러가지 공간 탐색 알고리즘(BFS, DFS, A* search) 등을 이용할 수 있지만, 보통의 경우 재귀적인 DFS로 간단하게 해결 가능하다. BFS의 경우 tree’s width가 넓어지면 queue의 크기가 커져 메모리 초과가 날 수 있으므로 종료조건만 명확하다면 DFS가 대체로 좋을 것이다. 내가 생각하는 백트래킹 문제의 핵심은 아래와 같다. 상태 공간 그리기 종료 조건 확인 복귀 DFS(recursion) 온라인 저지 문제들과 함께 기본적인 BT문제를 풀어보자. LeetCode 46. Permutaions distinct integer로 구성된 배열이 주어졌을 때, 모든 순열을 리턴하는 문제이다. 링…","frontmatter":{"date":"September 28, 2023","title":"(Alg) BackTracking algorithms","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-BT/"}},"next":{"id":"23768c60-0ff7-5ce5-8d74-1504f5f393b5","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>matrix가 주어졌을 때, 나선형으로 flatten한 일차원 배열을 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/spiral-matrix/\">링크</a></p>\n<p>2차원 배열이 입력으로 주어지지만, <code class=\"language-text\">n*1</code> 또는 <code class=\"language-text\">1*n</code> 크기의 배열이 주어질수도 있으므로 인덱스를 잘 관리해야한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>4개의 방향과 level을 갖고, 배열을 탐색하도록 한다.</p>\n<p>배열의 값을 하나씩 넣어주고, 해당 방향을 다 탐색하였다면 다음 방향으로 넘어가도록 구현하였다.</p>\n<p>만약 마지막 방향(아래에서 위로 올라오는 방향)의 끝이라면, 다음 레벨로 넘어가면서 다음 방향으로 가도록 한다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n*m)</p>\n<p>matrix의 크기만큼 탐색하므로 배열을 만든다.</p>\n</li>\n<li>\n<p>Space complexity: O(n*m)</p>\n<p>flatten한 배열의 크기는 matrix의 크기에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">spiralOrder</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        m<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        spirals <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        row_idx<span class=\"token punctuation\">,</span> col_idx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span>\n        level <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        direction <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        move <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n        cur_cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>spirals<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> m<span class=\"token operator\">*</span>n<span class=\"token punctuation\">:</span>\n            spirals<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>row_idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>col_idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            cur_cnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>direction <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">or</span> direction <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> cur_cnt <span class=\"token operator\">==</span> n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>level<span class=\"token punctuation\">:</span> <span class=\"token comment\"># 좌우 방향 종료 조건</span>\n                direction <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                cur_cnt <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> direction <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token keyword\">and</span> cur_cnt <span class=\"token operator\">==</span> m<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>level<span class=\"token punctuation\">:</span> <span class=\"token comment\"># 아래 방향 이동시 종료 조건</span>\n                direction <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                cur_cnt <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> direction <span class=\"token operator\">==</span> <span class=\"token number\">3</span> <span class=\"token keyword\">and</span> cur_cnt <span class=\"token operator\">==</span> m<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>level<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 위 방향 종료 조건 </span>\n                direction <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                cur_cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                level <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            row_idx<span class=\"token punctuation\">,</span> col_idx <span class=\"token operator\">=</span> row_idx <span class=\"token operator\">+</span> move<span class=\"token punctuation\">[</span>direction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> col_idx <span class=\"token operator\">+</span> move<span class=\"token punctuation\">[</span>direction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">return</span> spirals</code></pre></div>\n<p>cur_cnt에서는 해당 level의 해당 방향에서 몇번이나 원소를 셌는지를 의미한다. 만약, cur_cnt가 다 찼다면 다음 레벨로 넘겨주면 되는데, 마지막 방향의 경우에는 하나를 덜 세야 다음 방향(왼쪽에서 오른쪽)이 처음부터 셀 수 있다.</p>","frontmatter":{"date":"September 25, 2023","title":"(Alg) LeetCode Top Interview 150 - 54. Spiral Matrix","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-54/"}},"prev":{"id":"95803260-6ccb-5ee5-ae7d-48838ab64da9","html":"<p>프로젝트에서 jwt를 이용한 인증 절차를 도입한 경험을 정리해보며 글을 작성한다. 기본적인 authentication, authorization의 흐름(클라이언트, 서버)은 이해하고 보는 것이 편할 것이다.</p>\n<h1 id=\"jwt\" style=\"position:relative;\"><a href=\"#jwt\" aria-label=\"jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT</h1>\n<p><code class=\"language-text\">JWT</code>(JSON Web Token)은 JSON기반의 토큰으로, 토큰을 서버의 특정 key로 암호화하여 사이트에서 사용자를 인증하는데 사용될 수 있다. JWT는 보통 <code class=\"language-text\">base64</code>로 인코딩 되어 있으므로 디코딩하면 안의 값을 확인할 수 있다.</p>\n<p><a href=\"https://www.base64decode.org/\">아래와 같은 사이트</a>에서도 확인할 수 있고, 사용하는 언어의 내장함수를 이용하여 보통 JWT값의 해석이 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/ElEQVQoz62SvWvDMBDF9f+vHbulU7YO3boEOiSFkiW7vw1WJduyjT+wjV95AgW3pIaUGn6+s8S9ez5JRFGEJEkQhqEljmN0XYe/PiLLMiuYpqkVY3Tia3zfRxAENmekEebOEGvruobQWkMp9Q2u3QvryrKE4Ksoin+hqqr7BfM8vwldGmMg+OF+c735cwwO5+QWTdNQUNuEA+UiuwzDgGmaMI6jjWSe52vcPGUlNZI4xadU9sSIlNK65ImzERu0bYu+77EsyyZi//qI3csDng9PMKaCmykF6ZwihHeTwizadPhxOeJ0fsP58g7P8yy8cy7SJV0zrkfz2wy/AHDq9bcBY60YAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"jwt_decode\"\n        title=\"jwt_decode\"\n        src=\"/static/1926088e8ad69ff38fd11bfd61637c29/37523/jwt_decode.png\"\n        srcset=\"/static/1926088e8ad69ff38fd11bfd61637c29/e9ff0/jwt_decode.png 180w,\n/static/1926088e8ad69ff38fd11bfd61637c29/f21e7/jwt_decode.png 360w,\n/static/1926088e8ad69ff38fd11bfd61637c29/37523/jwt_decode.png 720w,\n/static/1926088e8ad69ff38fd11bfd61637c29/302a4/jwt_decode.png 1080w,\n/static/1926088e8ad69ff38fd11bfd61637c29/07a9c/jwt_decode.png 1440w,\n/static/1926088e8ad69ff38fd11bfd61637c29/31d79/jwt_decode.png 1954w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 내용이 다 나오지만 비교적 안전하게 사용할 수 있는 방법이 있으니 공부해보도록 하자.</p>\n<h2 id=\"구성\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%84%B1\" aria-label=\"구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구성</h2>\n<p>JWT는 .(dot)을 기준으로 header, payload, signature로 구성되어 있다.</p>\n<ol>\n<li>\n<p>header</p>\n<ul>\n<li>\n<p>alg</p>\n<p>해당 토큰을 암호화할 알고리즘에 대한 내용을 담고 있다. 보통 <code class=\"language-text\">HS256</code>, <code class=\"language-text\">RS256</code>과 같은 해싱 함수를 이용한다. 해당 알고리즘을 이용하여 뒤의 signature를 만들 수 있다.</p>\n</li>\n<li>\n<p>typ</p>\n<p>어떤 토큰인지 의미한다. 우리의 경우 JWT일 것이다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>payload</p>\n<p>JWT가 담고 있는 내용에 대한 부분이다. 이 부분은 디코드하면 쉽게 확인 가능하니 사용자가 알면 안되는 값은 넣으면 안된다.</p>\n</li>\n<li>\n<p>signature</p>\n<p>header의 algorithm을 이용하여 header + payload + <strong>secret key</strong> 를 암호화한 문자열이다. secret key는 말 그대로 비밀키로 서버에 잘 보관해놓고 위의 데이터를 암호화할 때 사용한다.</p>\n</li>\n</ol>\n<p><a href=\"https://jwt.io\">jwt.io</a> 사이트에서 이 과정을 직접 확인해볼 수 있다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABnUlEQVQoz22Sy47TMBSG8zhs2CHBCvEWvApvghBCCPY8AjsEI1ghNggJTadtMtObpo3jY8f28YeStEyb9lifHF/yn/MfuajubplVJT4FIkqGE7pQVcqy5HpyjXOOEAIxxv4s53xCkYyQFlvy2sCyhqWBlYFFDWtBw3DR1DWmNjhre9GUUp9oTNEuE/I7spkFbsvAYt6yqlqW85bFPOAl0w2iQu1gJxziuLLDurAhc++hajPbDC3gj+iakFWJIZBi7H/SrGdW+/2uwodOHRqXRwyZm6az6smaL1r9b3lQ52LGvBfsKiJBFogb0JaL0Vs+9n/8PZ69OMQ0pJD2d/Wy5bHgGf2ZstoZbtZbamtpRLAiyAjv/d7yqHUnNoaHyNIIvzbC33vbs64bduaBrTFY5ygGhVPOqlQle2FnBec9wTnwFtojunXwFC4pJipNHGZJ571JmvlUed5MhLc3Ax9njg8zx7up4/3U8XoifF61FJuQmTrlziulU1ZtPnlBXQTNvPwpPP7a8PRq4MUPy/PvDU++NTy7anj0xfDqj+MfSPShRpjh5gEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"jwt_io\"\n        title=\"jwt_io\"\n        src=\"/static/975e15cb6b261d98dcffd095b1b84ca8/37523/jwt_io.png\"\n        srcset=\"/static/975e15cb6b261d98dcffd095b1b84ca8/e9ff0/jwt_io.png 180w,\n/static/975e15cb6b261d98dcffd095b1b84ca8/f21e7/jwt_io.png 360w,\n/static/975e15cb6b261d98dcffd095b1b84ca8/37523/jwt_io.png 720w,\n/static/975e15cb6b261d98dcffd095b1b84ca8/302a4/jwt_io.png 1080w,\n/static/975e15cb6b261d98dcffd095b1b84ca8/07a9c/jwt_io.png 1440w,\n/static/975e15cb6b261d98dcffd095b1b84ca8/fc477/jwt_io.png 2426w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>VERIFY SIGNATURE를 보면, HS256 해싱 함수를 이용하여 header, payload 그리고 secret key를 인자로 넣고 암호화 하여 signature section을 생성함을 알 수 있다. 이 3개의 값이 다시 BASE64로 인코딩되어 나온 문자열이 JWT토큰이고, 이처럼 login 성공시 해당 토큰을 만들어서 발급하면 된다.</p>\n<p>그리고 <strong>디코딩해도 알 수 없는 값이 signature</strong>부분인데 이를 이용하여 <code class=\"language-text\">authorization</code>을 수행할 수 있다. 암호화 알고리즘은 단방향 해싱이므로, 복호화가 불가능하므로, 요청이 들어온 token을 secret key를 이용하여 다시 암호화하여 원래 signature값과 일치하는지만 확인하면 된다. (추가적으로 유효기간 등을 확인하여 인가를 수행)</p>\n<p>만약 복호화해서 header와 payload를 알아낸다 해도, secret key를 모르니 payload를 변경하더라도 signature에서 알아차릴 수 있게 된다!</p>\n<h2 id=\"단점과-보완---access--refresh-token\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90%EA%B3%BC-%EB%B3%B4%EC%99%84---access--refresh-token\" aria-label=\"단점과 보완   access  refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점과 보완 - access &#x26; refresh token</h2>\n<p>JWT는 authorization에 있어서 DB에 접근하는 session 방식보다 서버의 비용이 줄지만, 사용자의 활동을 추적하기 어렵고 사용자가 토큰을 탈취당한 경우에 제어할 수 있는 방법이 없다. 이에 몇가지 방법이 고안되었고, 대표적인 방법은 다음과 같다.</p>\n<ol>\n<li>\n<p>authorization을 위한 토큰의 유효기간을 매우 짧게 한다.</p>\n<p>토큰의 유효기간을 짧게 한다면 해당 토큰이 탈취되도 오랫동안 사용하지 못할 것이다. 그치만 토큰을 재발급하기 위해서는 로그인을 해야하는데, 짧은 시간마다 로그인을 하는 것은 사용자에게 불편하다. 따라서, 아래의 방법도 추가적으로 필요하다.</p>\n</li>\n<li>\n<p>위의 토큰을 재발급하기 위한 긴 유효기간의 <code class=\"language-text\">refresh token</code>을 발급한다.</p>\n<p>짧은 간격마다 로그인하는 것을 방지하기 위해 토큰을 발급하기 위한 토큰인 토큰을 로그인시 발급한다. 보통 이 둘을 구분짓기 위해 앞서 말한 인가에 사용되는 토큰은 <code class=\"language-text\">access token</code>, 토큰을 재발급받기 위한 토큰은 <code class=\"language-text\">refresh token</code>이라고 부른다.</p>\n<ul>\n<li>\n<p>access token</p>\n<p>유효 기간 짧음(분 단위). 서비스의 기능을 사용하기 위한 인가(authorization)단계에서 필요함.</p>\n</li>\n<li>\n<p>refresh token</p>\n<p>유효 기간 김(일~주 단위). 로그인시 발급되며, access token을 재발급 받기 위해 필요함.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>그치만 <strong>역시 토큰이 악의적인 누군가에게 탈취당한다면 access token의 유효기간 동안 막을 방법은 없다</strong>. 그리고 <strong>refresh token이 탈취당할 경우에는 계속 access token을 발급할 수 있</strong>는 치명적인 문제가 있다. 따라서 refresh token은 사용자마다 하나씩만 갖도록 서버에서 DB 등으로 저장하고, 한번 access token을 발급하면 refresh token을 다시 발급하는 <code class=\"language-text\">RTR</code>(Refresh Token Rotation)방법이 권장되기도 한다.</p>\n<p>하지만, 결국 DB에 접근하는 것은 session과 유사하며 JWT의 장점(간단하고 빠름)이 사라진다는 문제점이 있다.</p>\n<h2 id=\"토큰을-어디에-저장해야할까\" style=\"position:relative;\"><a href=\"#%ED%86%A0%ED%81%B0%EC%9D%84-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"토큰을 어디에 저장해야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>토큰을 어디에 저장해야할까?</h2>\n<p><a href=\"https://velog.io/@ohzzi/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%84-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\">벨로그에서 좋은 글</a>을 보았는데, 요약하자면 다음과 같다.</p>\n<ul>\n<li>\n<p>authentication 성공시, 서버는 클라이언트에게 access token과 refresh token을 발급하며, 해당 사용자 table에 refresh token 값을 기록한다.</p>\n<ul>\n<li>access token은 response body에 실어 보낸다.</li>\n<li>refresh token은 response header를 통하여 <code class=\"language-text\">http-only cookie</code>로 클라이언트의 브라우저 쿠키에 바로 저장되도록 한다. (가능하면 https인 secure로 보내는 것이 권장) 이렇게 하면 refresh token 자체가 악의적인 코드에 의하여 탈취될 가능성(XSS 공격)은 매우 낮다.</li>\n<li>하지만 <code class=\"language-text\">CSRF</code> 공격을 통해 해당 토큰을 포함한 악의적인 요청이 전송될 수 있는 가능성이 있다. 따라서, 쿠키의 범위를 해당 사이트에서만 유효하도록 SameSite 옵션을 “Strict” 나 “Lax”로 걸어주고, <strong>CSRF token</strong>을 추가적으로 발급한다면 좀 더 안전해질 것이다.</li>\n<li>refresh token은 사용자 DB에 저장된다. 만약 이미 해당 사용자의 refresh token이 존재한다면 덮어씌우자(이렇게 중복 로그인을 막을 수도 있겠다)</li>\n</ul>\n</li>\n<li>\n<p>클라이언트는 access token을 variable로 관리한다.</p>\n<ul>\n<li>access token을 내부 변수로 관리한다면 외부에서 접근할 수 있는 방법이 줄어들 것이다. SPA 프레임워크는 새로고침을 하지 않는 이상 변수가 초기화되지 않을 것이다.</li>\n<li>만약 access token이 없다면, cookie의 refresh token을 이용하여 access token과 refresh token을 재발급 받는다.</li>\n<li>만약 refresh token이 없다면, 사용자에게 로그인을 요청한다.</li>\n</ul>\n</li>\n<li>\n<p>authorization 시, access token을 header에 실어서 보낸다.</p>\n<ul>\n<li>서버에서는 access token이 유효한지(내용과 유효기간 등)를 확인하면 된다.</li>\n</ul>\n</li>\n<li>\n<p>브라우저는 refresh토큰을 이용하여 access token을 재발급 받고, 서버에서는 refresh token으로 access token과 refresh token을 모두 재발급한다. (로그인 성공시와 유사)</p>\n<ul>\n<li>access token을 발급한 이후 refresh token을 재발급하고, 기존 refresh token은 폐기한다(RTR). 보통 사용자 DB에서 토큰 값을 업데이트 하면 된다. 아니면 이를 서버의 <code class=\"language-text\">global variable</code>로 저장하거나 인메모리DB를 사용하는 것도 방법이겠다.</li>\n</ul>\n</li>\n</ul>\n<p>앞서 말한 <code class=\"language-text\">RTR</code> 방식으로 refresh token을 발급하고, 이를 이용하여 access token을 발급하여 인증/인가를 구현해보자. 서버는 fast api로 하고, 클라이언트는 react js로 구현해볼 것이다!</p>","frontmatter":{"date":"October 05, 2023","title":"(WEB) JWT token 인증 도입하기 (1)","categories":"WEB","author":"choieastsea","emoji":"💨"},"fields":{"slug":"/WEB-jwt(1)/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-BT/","nextSlug":"/Alg-LC-54/","prevSlug":"/WEB-jwt(1)/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}