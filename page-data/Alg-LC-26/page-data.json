{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-26/",
    "result": {"data":{"cur":{"id":"30a585f6-14f0-5e91-8fc5-a19cfbfde638","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>정렬된 배열에서 중복을 제거하고 제거된 배열의 크기를 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\">링크</a></p>\n<p>배열의 정렬 상태가 유지되어야하고 파라미터로 들어온 배열을 변형해야한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>처음에는 python의 set 자료형을 통하여 중복을 제거하는 방법을 생각해보았다. 하지만, 이는 순서를 유지하기 위해 sort를 수행해야하므로 선형탐색 하는 방법도 구현해보았다.</p>\n<h3 id=\"sol1-set집합-자료형으로-중복-제거\" style=\"position:relative;\"><a href=\"#sol1-set%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9C%BC%EB%A1%9C-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0\" aria-label=\"sol1 set집합 자료형으로 중복 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol1. set(집합) 자료형으로 중복 제거</h3>\n<p><code class=\"language-text\">sorted(list(set(nums)))</code>를 해주면 중복을 제거하고 정렬상태를 유지시킬 수 있다. 하지만 새롭게 만들어진 배열을 nums에다가 대입해주는 과정이 추가로 필요하다.</p>\n<h3 id=\"sol2-선형탐색하면서-중복-제거\" style=\"position:relative;\"><a href=\"#sol2-%EC%84%A0%ED%98%95%ED%83%90%EC%83%89%ED%95%98%EB%A9%B4%EC%84%9C-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0\" aria-label=\"sol2 선형탐색하면서 중복 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol2. 선형탐색하면서 중복 제거</h3>\n<p>가장 간단하게 생각해볼 수 있는 방법으로, 새로운 배열을 만들고 nums 배열을 선형탐색하며 <strong>중복되지 않는다면 값을 하나씩 넣어</strong>주면 된다. 여기서 잘 생각해보면 새로운 배열 없이 nums 안에서도 처리할 수 있다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity:</p>\n<ul>\n<li>sol1 : set 연산은 <code class=\"language-text\">O(n)</code>만큼 들고, 이후 k size 리스트를 정렬하는데는 <code class=\"language-text\">O(klogk)</code>정도 들 것이다. 그리고, nums에 할당하는 과정이 필요하니(문제의 조건으로 인하여) <code class=\"language-text\">O(k)</code>만큼의 시간이 더 들 것이다.</li>\n<li>sol2 : O(n)</li>\n</ul>\n</li>\n<li>\n<p>Space complexity:</p>\n<ul>\n<li>\n<p>sol1 : O(k) (중복이 제거된 배열의 크기)</p>\n</li>\n<li>\n<p>sol2 : O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeDuplicates</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        remove duplicate in non-decreasing list\n        \"\"\"</span>\n        after_mod <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>after_mod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> after_mod<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>after_mod<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeDuplicates</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        remove duplicate in non-decreasing list\n        \"\"\"</span>\n        k <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 중복 발생</span>\n                <span class=\"token keyword\">pass</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 다르다면, nums 배열에 넣어줌</span>\n                nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n                k <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> k</code></pre></div>\n<p>처음에는 <code class=\"language-text\">new_list = []</code>를 만들고, 중복이 발생하지 않을때만 nums[i]를 넣어주었다. 하지만 nums[i]까지 탐색했을 때, new_list의 크기가 k라고 하면 <strong>k는 항상 i보다 작다는 것을 알 수 있다</strong>. 따라서 이전의 값을 다시 사용할 일이 없으니 new_list 대신 nums를 그대로 사용하면 된다.</p>","excerpt":"Intuition 정렬된 배열에서 중복을 제거하고 제거된 배열의 크기를 리턴하는 문제이다. 링크 배열의 정렬 상태가 유지되어야하고 파라미터로 들어온 배열을 변형해야한다. Approach 처음에는 python의 set 자료형을 통하여 중복을 제거하는 방법을 생각해보았다. 하지만, 이는 순서를 유지하기 위해 sort를 수행해야하므로 선형탐색 하는 방법도 구현해보았다. sol1. set(집합) 자료형으로 중복 제거 를 해주면 중복을 제거하고 정렬상태를 유지시킬 수 있다. 하지만 새롭게 만들어진 배열을 nums에다가 대입해주는 과정이 추가로 필요하다. sol2. 선형탐색하면서 중복 제거 가장 간단하게 생각해볼 수 있는 방법으로, 새로운 배열을 만들고 nums 배열을 선형탐색하며 중복되지 않는다면 값을 하나씩 넣어주면 된다. 여기서 잘 생각해보면 새로운 배열 없이 nums 안에서도 처리할 수 있다. Complexity Time complexity: sol1 : set 연산은 만큼 들고, 이…","frontmatter":{"date":"August 23, 2023","title":"(Alg) LeetCode Top Interview 150 - 26. Remove Duplicates from Sorted Array","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-26/"}},"next":{"id":"673fdb45-03b2-5faa-82e9-8bda9f41a585","html":"<p>저번에는 운영체제가 Process를 어떻게 실행하고, context switching을 하는지(<code class=\"language-text\">scheduling mechanism</code>)에 대하여 공부해보았다.</p>\n<p>오늘은 scheduling을 할 때 순서를 결정짓는 <code class=\"language-text\">Policy</code> 에 대하여 공부해보도록 하자. <code class=\"language-text\">Scheduling Policy</code>란, ready state인 여러개의 프로세스들 중어떤 프로세스를 다음에 실행할지 결정하는 ‘원칙’이다.</p>\n<p>오늘날 실제 스케줄러와 차이는 있겠지만 큰 틀에 있어서 공부하면 더 복잡한 내용도 이해하기 쉬울 것이다.</p>\n<h1 id=\"scheduling의-목표\" style=\"position:relative;\"><a href=\"#scheduling%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"scheduling의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scheduling의 목표</h1>\n<p>우선 CPU burst time에 대하여 알 필요가 있다.</p>\n<blockquote>\n<p>CPU burst = 어떤 프로세스에 대하여 CPU의 연속적인 실행 시간</p>\n<p>만약, I/O wait에서 돌아왔다면 CPU burst는 초기화 될 것임</p>\n</blockquote>\n<p>scheduling의 목표는 다음과 같다.</p>\n<ul>\n<li>Maximize utilization : CPU 사용 시간을 최대화하면(알차게 쓰면) 좋다</li>\n<li>Minimize average <code class=\"language-text\">turnaround time</code> : 평균반환시간(실행 완료시간 - 도착시간의 평균)을 최소화</li>\n<li>Minimize average <code class=\"language-text\">response time</code> : 평균응답시간(최초실행시간 - Process도착시간의 평균)을 최소화</li>\n<li>Fairness : 프로세스를 차별하지 않고 공평하게 처리해야함</li>\n<li>Minimize overhead : context switching하기 위한 오버헤드를 최소화해야함</li>\n</ul>\n<p>여기서는 동시에 여러 프로세스들이 ready queue에 들어와있으며, I/O 등의 작업을 사용하지 않는다고 가정하자.</p>\n<h1 id=\"fifofcfs\" style=\"position:relative;\"><a href=\"#fifofcfs\" aria-label=\"fifofcfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO(FCFS)</h1>\n<p>먼저 ready queue에 들어온 process를 실행시키는 것이다. 그리고 프로세스는 작업이 끝날때까지 CPU를 점유한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrklEQVQ4y61UuYoCURBsQTwi/TMx8CsMBcXMRPAPzEw9MVDwNlMEA+8LFVEDQfECb1Fr6V5m2GU3cdmG4tV79abpnq4Zut1u2O12OBwOOB6Psj6fT3C8Xi+8G+T3+2E2m5FMJpHNZuHz+TAcDkXkxJz0HZDX6wURIRKJIJFIwOl0otfr4a9BHo9HEgYCAYRCIdjtdlSrVRFPp5PgcrkIFH69Xn9wBndE6XQaDocDpVIJmUwG4XAYrVYL7XYb/X4f0+kUnU4H3W5X+GAwQLPZxGw2E95oNITz3fl8Djqfz2q56/Va5avVSgbEsdlssN1uhe/3eyyXS7WDxWKhPjMej0H456BarSYT5na5/a/gcx4Wa6lU6pvG+3w+j9FohMlkIq2z7chischQ/gKtVotYLIZoNAqXyyV2I6vVKqJGo3k7oV6vRzwel6Rut1uqJZvNJqLRaJQLOp1OVoUr+Lo3GAxSnclkElcEg0GpUBKy59gibIVcLgd+p2wR5qyxyQuFAiqVilijWCyiXC4L55XBdqnX658J7/e7OiE2qRJs2t/O+f7j8VA/TbaOEvxP+AADszANcQSf5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fifo\"\n        title=\"fifo\"\n        src=\"/static/818688cf4bd6a872f518bf7dd1f85bcc/37523/FIFO.png\"\n        srcset=\"/static/818688cf4bd6a872f518bf7dd1f85bcc/e9ff0/FIFO.png 180w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/f21e7/FIFO.png 360w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/37523/FIFO.png 720w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/302a4/FIFO.png 1080w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/07a9c/FIFO.png 1440w,\n/static/818688cf4bd6a872f518bf7dd1f85bcc/74e37/FIFO.png 1732w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 두가지 경우를 보며 turnaround time을 계산해보도록 하자. 0초에 프로세스ABC 순으로 들어온 경우이다.</p>\n<p>첫번째 경우에는 처음 들어와서 종료될때 까지의 시간이 10,20,30 이므로 (10+20+30)/3 = 20초이며, 두번째 경우에는 (100+110+120)/3 = 110 초로 차이가 크다.</p>\n<p>두번째 경우와 같이 먼저 들어온 오래 걸리는 process때문에 turnaround time이 증가하는 현상을 <code class=\"language-text\">convoy effect</code>라고 한다. 마트에서 계산대에 맨 앞에 가장 많은 물건은 담은 카트의 사람이 계산하는 것과 비슷한 현상이라고 볼 수 있다~ 스케줄러는 turnaround time을 줄이기 위해 다른 알고리즘을 생각할 필요가 있을 것이다.</p>\n<h1 id=\"sjfshortest-job-first\" style=\"position:relative;\"><a href=\"#sjfshortest-job-first\" aria-label=\"sjfshortest job first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF(Shortest Job First)</h1>\n<p>말 그대로 가장 짧은 일을 먼저 하는 것이다. 아까와 같이 ABC가 동시에 들어올 때, 가장 짧게 걸리는 B와 C를 우선적으로 실행하는 것이다. 그렇다면 turn around time은 (10+20+120)/3 = 50 초가 될 것이다. 하지만 이 역시도 몇가지의 문제가 존재한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB80lEQVQ4y6VUOWuqQRQdSzv/gHEpbbSzDmgKFUUkqEltZyEqQVwK179gKYo2IoiF2qZIECtBBUFQQQvFDTfc9YQZ+PLyNsJ7XjjMmTN37ndnvsOQ7XaL3W6H4/GI74LmfRek3W7j9fUV6XQaDocDDw8P0Ol00Gq1P0Gj0UCtVv+mU9B8lUqFVqsFUqvVkM1mEQwGIZfLQQj5b7y9vYHU63XkcjlWUKFQ3FTw/f0dpFqtolgsIplMwm63w2QywWKxQK/Xw2w2MxgMBjw+PsJqtcJoNDI8PT198ufnZ3b0ZrMJMp1OcblccDqdMBwOPy93PB5/8slkguv1yvhsNsPhcGB8vV5jPp8zTrXBYADCbeKKns9nBprAzf/G6UjdQfdyc7LZbDAajVhH9At08ZYg1FuNRoO1To/A+ZJitVqx41LO6V9H2u1yuWR5i8WCNUPohQoEAkilUkgkEohEIgaxWIy7uzsIhULGOZ1bo7pMJkOhUECpVEIoFEK/3we5v79nv5zH4/2zTfh8PvNwPp+H0+lEt9sFUSqVN3kvkUgglUrBZrOh0+mAxONx+Hw+RCIRuN1u1no4HIbL5WJmp/rLywv8fj9isRg8Hg+8Xi+i0SgCgQDK5TIqlQoymQx6vd4P29DY7/d/fAi+6r8+IpwPaVAffgBkcviHGx4DAQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sjf\"\n        title=\"sjf\"\n        src=\"/static/6160a046e28af39472e2c618efacecda/37523/sjf.png\"\n        srcset=\"/static/6160a046e28af39472e2c618efacecda/e9ff0/sjf.png 180w,\n/static/6160a046e28af39472e2c618efacecda/f21e7/sjf.png 360w,\n/static/6160a046e28af39472e2c618efacecda/37523/sjf.png 720w,\n/static/6160a046e28af39472e2c618efacecda/302a4/sjf.png 1080w,\n/static/6160a046e28af39472e2c618efacecda/07a9c/sjf.png 1440w,\n/static/6160a046e28af39472e2c618efacecda/baa75/sjf.png 1746w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p>우선, 작업의 길이를 알고 있기 쉽지 않다. 실제 상황에서는 A,B,C가 동시에 들어올 때, 가장 짧게 걸리는 프로세스를 예측 정도만 하고 알수는 없을 것이다.</p>\n</li>\n<li>\n<p>위의 두번째 그림처럼 A가 더 먼저 들어오고, 5초에 B와 C가 들어오면 결국 FIFO와 유사한 “좋지 않은 turnaround time”이 나타나게 된다.</p>\n</li>\n</ol>\n<p><u>두번째 문제</u>를 해결하기 위해 Process의 실행에 OS가 개입하여 스케줄링을 하는 <code class=\"language-text\">선점형 스케줄러</code>의 필요성이 나타난다. non-preemtive scheduler는 프로세스가 끝날 때까지 기다리므로, 랜덤하게 프로세스가 들어오는 상태에서 SJF는 제 성능을 낼 수 없다. 반면에, 프로세스의 실행 중의 timer 등으로 <strong>OS가 개입하여 프로세스의 <code class=\"language-text\">context switching</code>을 수행할 수 있는 <code class=\"language-text\">preemtive scheduler</code>는 다른 방법을 제안</strong>할 수 있다.</p>\n<h1 id=\"stcfshortest-time-to-complete-first\" style=\"position:relative;\"><a href=\"#stcfshortest-time-to-complete-first\" aria-label=\"stcfshortest time to complete first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STCF(Shortest Time to Complete First)</h1>\n<p>여기서부터는 scheduler가 주기적으로 상황을 체크하고, 이에 따라 context switching을 수행하는 선점형 스케줄러이다. 말 그대로, 완료하기까지에 남은시간이 가장 적은 순서부터 수행한다는 것이다. 따라서 <code class=\"language-text\">SJF</code>에서 임의의 시간에 ready queue에 들어온 프로세스들이 기다리게 되는 현상을 해결할 수 있을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABAUlEQVQoz6WRPaqDQBSFZwE2acQViKKbENeT2i0oSBotRGy0kxQWBsHCxtoypMsGRPxDtFHPYwYM74FNeBfOcDnzce9whuz7jrqu0XUd3u835nnGf4rQgw56vV4YxxHDMGDbNqzr+kd08TRNTGf3B0PKsoQsy0iSBHme43a7QdM0iKIIVVWhKMpHkiQx9rdHGcrqus4eRB6PBwghiOMY9/sdhmGA53nmfSNBEFhsJE1TZgRBgCiKcL1ewXHc1wMvlwv6vgd5Pp9wHAdVVaEoCmRZhjAMYZombNuG7/uwLOu0PxjP8+C6Ltq2BVmW5fNDNPCjaPBH0cDPesocHPWbpsEPSbuI6bDTYYoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"stcf\"\n        title=\"stcf\"\n        src=\"/static/fe33c7b89f59d87efce76610c576e01b/37523/stcf.png\"\n        srcset=\"/static/fe33c7b89f59d87efce76610c576e01b/e9ff0/stcf.png 180w,\n/static/fe33c7b89f59d87efce76610c576e01b/f21e7/stcf.png 360w,\n/static/fe33c7b89f59d87efce76610c576e01b/37523/stcf.png 720w,\n/static/fe33c7b89f59d87efce76610c576e01b/4c42d/stcf.png 896w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>B,C가 도착한 시간에 스케줄러는 프로세스마다 남은 시간을 확인한다. 여기서, A보다 B,C가 일찍 끝난다고 판단되면 그것들부터 먼저 실행을 하는 것이다. 위의 경우, turnaround time은 (120+10+20)/3 = 50초가 될 것이다. 즉, SJF의 이상적인 환경일때의 turnaround time을 동시에 도착하지 않는 프로세스들 사이에서도 보장해줄 수 있다.</p>\n<h2 id=\"response-time의-고려\" style=\"position:relative;\"><a href=\"#response-time%EC%9D%98-%EA%B3%A0%EB%A0%A4\" aria-label=\"response time의 고려 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Response Time의 고려</h2>\n<p>매우 좋아보이지만, 여기서 스케줄러의 성능 평가 지표중 하나인 <code class=\"language-text\">response time</code>을 들여다보자. 응답 시간은 <em>프로세스 도착시점부터 해당 프로세스의  최초 실행시점까지의 시간</em>을 의미한다. 또한 <strong>시스템과 상호작용을 원활히 하기위한 사용자의 요구와 관련</strong> 되어 있다.</p>\n<p>non-preemptive scheduler의 경우, 더 우선순위가 높은 다른 프로세스가 끝날 때까지 첫 실행시간이 지연되므로 response time이 매우 좋지 않다. 추가적으로, STCF도, 비슷한 종료시간의 프로세스들이 동시에 도착한다면 기다리는 시간이 적지 않음을 알 수 있다. 예를 들어 위의 경우에서 C를 실행하고 10초뒤에 실행되는데 이는 우리가 느끼기에 매우 느린 속도이다.</p>\n<p>따라서 응답시간이 빨라야 사용자는 빠르다고 느끼므로, <strong>응답시간에 좀 더 중점을 두고 스케줄링 정책을 고려</strong>할 필요가 있을 것이다.</p>\n<h1 id=\"rr\" style=\"position:relative;\"><a href=\"#rr\" aria-label=\"rr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RR</h1>\n<p>Round Robin이라는 방식은 응답시간을 줄이기 위해 <code class=\"language-text\">time slice</code> 개념을 도입한다. 프로세스의 실행과 관련없이 <strong>주기적으로 시간을 쪼개고, 그때마다 번갈아가면서 프로세스를 실행하는 것</strong>이다(따라서 preemptive). time slice의 간격이 작으면 응답시간이 빠르고, 너무 작다면 context switching하는 데 너무 많은 시간을 소비하게 되므로 이를 적당히 잘 고르는 것이 중요하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNUlEQVQoz42RPcuCYBSG/WVNubi0tQuBFAmtDQ7W4GhETjXZKG39CX+CYhBKg4JlRWQfer+cE4XIO3jgPM/h5nCdL+H5fILs9XqhKAr2sizxeDxYv9/v/JPWxITVaoX1eg3btmFZFhzHwWw2w2azwXw+x3a7xfl8bgwVer0eZFnGYDBAp9PBeDxGu93GZDJBq9VieBiGnPx+v39T1P1bTOj3+1AUBaPRCN1uF5qmQZIkGIYBURSxWCwQx3GjcQkq6LoO8ul0ylDqSFVVmKaJ4XCI5XIJ13URRRGCIIDv+9jv99jtdvA8j2PSkiT5dHi5XJhMezoejyyeTiccDgeOr9crj0xHStOUIXmecw6B6GhZlnEBBv636O9eyG632+8o9cNUY9ovj0xP3avJ1CF1UNXqeVXwH2ZEPJUMfaQzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rr\"\n        title=\"rr\"\n        src=\"/static/71b76292c22ac325ad6a4aecd097bf1f/37523/RR.png\"\n        srcset=\"/static/71b76292c22ac325ad6a4aecd097bf1f/e9ff0/RR.png 180w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/f21e7/RR.png 360w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/37523/RR.png 720w,\n/static/71b76292c22ac325ad6a4aecd097bf1f/076ca/RR.png 914w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하지만 <code class=\"language-text\">turnaround time</code>의 측면으로 보았을 때, 모든 프로세스가 동시에 끝나게 되므로, 최악의 평균 시간을 갖게 됨을 알 수 있다… 그렇지만, 응답시간이 뛰어나고 공평한 프로세스의 분배가 이뤄지는 것을 알 수 있다.</p>\n<p>preemptive한 스케줄러인 <code class=\"language-text\">STCF</code>와 <code class=\"language-text\">RR</code>의 장단점을 생각해보며 다음으로 넘어가면 좋을 것 같다.</p>\n<h1 id=\"입출력을-고려한-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"입출력을 고려한 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입출력을 고려한 스케줄링</h1>\n<p>아직까지 고려되지 않았지만, 실제 scheduling에서는 몇가지 조건이 추가적으로 있다.</p>\n<ol>\n<li>프로세스 실행 도중에 IO가 호출된다</li>\n<li>프로세스의 실행시간을 알 수 없다 (따라서 STCF는 거의 불가능하다)</li>\n</ol>\n<p>첫번째로, 프로세스 실행 중 입출력이 발생하는 경우에 대하여 알아보자.</p>\n<p>예전에도 배웠다시피, 입출력이 발생하면 해당 프로세스의 상태는 <strong>block</strong>이 된다. 그리고 위에서 언급한 스케줄러의 목표 첫번째(CPU를 최대한 활용)를 위하여 CPU는 해당 프로세스의 입출력 작업이 완료될때까지 다른 작업을 수행할 것이다. 또한 입출력 작업이 완료되었을 때에도, context switching을 할지 결정해야한다.</p>\n<p>예를 들어, 각각 작업시간이 50ms인 프로세스 A,B가 있다고 하자. A 프로세스는 10ms마다 10ms가 걸리는 IO 작업을 수행하며 B는 입출력을 하지 않는다고 가정하자. 그랬을 때 입출력을 고려하지 않은 STCF는 아래의 첫번째 그림같이 비효율적으로 운영될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACOklEQVQoz4VTTUtqURS9M2voP2giOGwYOGhs42Y6ERIdCE6amJUSjSJw0iRoEoL2C5JUJBFFBw20TwwxtfwKtdTU8mM91obzeO9N3oLt3t5z7zrrrL2PtlgsQDw9PaHZbKLX6+H29haz2QyFQgEfHx94e3tDsVjEeDyWtVqthkajgff3d6lbrZZ8+/PzA63b7WIwGMBgMODo6AiJRAJ6vV42WV5eRi6Xg8fjwfr6Ovr9PjRNw+npKa6vr3F1dSURjUYRi8Xw+fkJ7evrC4xgMIidnR14vV7s7+9LsN7b28Pu7q4E64ODA1FOZS8vL6hUKr9jMplAo9xyuSyKnE4n1tbWUK/XRQnXVldXhfzy8hJLS0tQ4PGm0+lfQWj8oY/39/fiTyQSkZxMJpFOp3FzcyNHenh4ENJ8Pi8116gwk8ng8fFRnlG1RjKy03BCZWI0Gkmmd0rV9/e31GyWWlMc7IeGP8APFOjHvxsoMpXVhKgsR2aHh8MhXC4XwuEwzs7O4Ha7kc1mYbFYEI/H4fP5ZAJoh9VqlWOykcR8PhdCFRrJKJtjs729DbvdLnUoFIJOp8PJyQlMJhPMZjMCgYA0hl5SiCJUIYTsKIeS2NjYgM1mEwUk63Q6WFlZwfn5OY6Pj2E0GvE/aDSeu3Hy/X4/Dg8PkUqlsLm5KbfH4XDg4uJC7Nja2sLr6ytKpZJ0lbPHzP+8SXJTyMoO8UWiWq1KI2iFevb8/CxZXbd2uy1jxsbd3d3JDeEIcX5/AZd5JWOeA/zPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"io\"\n        title=\"io\"\n        src=\"/static/58ad25fa51cd5527dd0c321fef0f1ceb/37523/io.png\"\n        srcset=\"/static/58ad25fa51cd5527dd0c321fef0f1ceb/e9ff0/io.png 180w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/f21e7/io.png 360w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/37523/io.png 720w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/302a4/io.png 1080w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/07a9c/io.png 1440w,\n/static/58ad25fa51cd5527dd0c321fef0f1ceb/a2498/io.png 1764w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>처음에 A가 실행되고, 10ms 뒤에 A가 blocked되었을 때에도 A가 남은 시간이 더 적으므로 A를 계속 선택하게 되는 것이다. 따라서, 입출력을 고려한 스케줄링 정책은 다를 필요가 있다. A를 10ms의 작업 5개로 보는 것이다. A의 작업이 10ms 시점에 끝나므로 B가 실행이 되고, A가 입출력이 끝나면 다시 더 조금 남은 A가 실행이 되는 식이다. 위의 두번째 그림이 이와 같다.</p>\n<p>이처럼 입출력이 잦은 프로세스는 짧고 자주 실행되도록 하여 CPU 사용량을 높일 수 있을 것이다. 하지만, 우리는 가장 어려운 조건이 남아있다. 실제 프로세스의 작업량을 scheduler가 알기 매우 어렵다는 것이다! 따라서 STCF와 RR의 개념을 응용하여 실행시간을 예측하기 어려운 상태에서 스케줄링을 최선(스케줄링의 목표 달성)으로 하는 방법이 고안되고 있다.</p>\n<h1 id=\"mlfqmulti-level-feedback-queue\" style=\"position:relative;\"><a href=\"#mlfqmulti-level-feedback-queue\" aria-label=\"mlfqmulti level feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MLFQ(Multi-Level Feedback Queue)</h1>\n<p>가까운 과거를 통하여 미래(실행시간)를 예측하고, <strong>우선순위가 있는 queue(linked list)를 여러개 두어 스케줄링</strong>을 하도록 하는 스케줄러이다. 이는 LINUX에서 사용하는 스케줄링과 유사하다고 한다. 몇가지 원칙은 다음과 같다.</p>\n<ul>\n<li>Priority(A) > Priority(B)이면, A가 실행된다 (B는 실행되지 않음).</li>\n<li>Priority(A) = Priority(B)이면, A와 B는 RR방식으로 실행된다.</li>\n<li>프로세스가 들어오면,가장 높은 우선순위의 큐에 놓여진다.</li>\n<li>주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다.</li>\n<li>타임 슬라이스를 소진하기 전에 (io등으로 인하여)CPU를 양도하면 우선순위를 유지한다.</li>\n</ul>\n<p>그림으로 간단하게 표현하면 아래와 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABW0lEQVQ4y52U2Y6DMAxF+f9fq1S1fYCH7gXRfVMpiNWjY8kVRZkBjSWLxDE3ju9NPPnDmqZxxvM8/1ory1KqqtKxl2WZzGYziaJI4jiW1Woly+VSFouFJtzvd9lutwpyOp3keDyqXy4XeT6fcr1e9T8cUI/EIAjkcDho0n6/l91upxtQxev10tj7/ZbNZqNjA12v17oZY+IKKD1Ghew++Mgs1HWtCebMcYwKAcUsz6ydZz33+gihR/P5/BNrezvX5r2AVAioq0Ibt2O9gBAF820risIJNggwTVOVB/IyJdxuN4259Dqoh8gFYJMTEgH4X4BJksj5fP5ao1qTSZcgr8tcl8XH4/HR4W+kDOqhGUfjNgy1j7Bhji+qx5nb8aiSNW4IbiQ5j0zCeDyWyWSid3M6nepjMRqNFJj+QQS99H1fc8IwVMadpDABlApodNtZ42vVmgZhnsfCVeEP567iDh+tzn4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mlfq\" title=\"mlfq\" src=\"/static/92602f6385c6161cbf63c717dc4d2fd0/37523/mlfq.png\" srcset=\"/static/92602f6385c6161cbf63c717dc4d2fd0/e9ff0/mlfq.png 180w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/f21e7/mlfq.png 360w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/37523/mlfq.png 720w,\n/static/92602f6385c6161cbf63c717dc4d2fd0/d52e5/mlfq.png 848w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>프로세스는 처음 스케줄러에 진입시, 높은 우선순위 큐에 순서대로 들어가게 된다. 같은 우선순위에 있는 프로세스라면 RR방식으로 실행되며 사용량이 time slice(혹은 어떠한 기준)를 넘어선다면 해당 프로세스의 우선순위를 낮추는 것이다. 하지만, IO 작업등으로 다른 프로세스가 실행되도록 하거나 time slice를 다 쓰지 못한다면 우선순위를 유지한다.</p>\n<h2 id=\"어떻게-mlfq에서-실행시간을-추측할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-mlfq%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%B6%94%EC%B8%A1%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 mlfq에서 실행시간을 추측할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 MLFQ에서 실행시간을 추측할까?</h2>\n<p>MLFQ에서는 우선 작업을 높은 순위에 배치한다. 만약 **<u>해당 작업이 금방 끝난다면 끝나는 거고, 오래 걸린다면 자연스럽게 우선순위가 떨어지게 될 것</u>**이다. 이는 STCF와 유사하다고 볼 수 있다! 또한, <strong>입출력이 많은 대화형 작업의 경우에도 우선순위를 높게 유지하도록 하여 response time을 작게 해주는 효과</strong> 또한 존재한다.</p>\n<h2 id=\"mlfq의-한계\" style=\"position:relative;\"><a href=\"#mlfq%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"mlfq의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MLFQ의 한계</h2>\n<p>여태까지의 이슈를 해결해주는 스케줄링 기법이긴 하지만 MLFQ에도 한계점이 존재한다.</p>\n<ol>\n<li>\n<p>Starvation</p>\n<p>다른 Process들이 모두 interactive하다면(입출력이 자주 있다면), IO가 적은 특정 프로세스들은 계속하여 스케줄링되지 못하는 현상이 발생할 수 있다. 따라서, 주기적으로 <code class=\"language-text\">Priority Boost</code>를 통하여 프로세스가 선택되도록 한다. 이는 CPU bound 했다가 IO bound 작업이 많아지는 프로세스에서도 유용할 것이다.</p>\n</li>\n<li>\n<p>Gaming the scheduler</p>\n<p>time slice 직전까지 점유하다가, IO를 발생시키는 것을 반복하는 악의적인 프로세스가 있을 수 있다. time slice의 99%만큼 사용한 경우에 CPU를 양도하게 되면 CPU를 거의 독점할 수도 있다. 따라서, time slice단위로만 측정하는 것이 아니라 Process가 해당 우선순위에서 얼마나 사용했는지를 누적 기록하여 time slice를 초과할 때 우선순위를 낮출 수 있다.</p>\n</li>\n</ol>\n<p>추가적으로, time slice를 얼마로 조정해야하는지 등이 이슈가 있다. 보통 우선순위가 높은 큐는 짧은 time slice를 적용하여 response time을 줄이고, 대화형(interactive) 작업을 빠르게 처리한다고 한다. 오늘날에는 MLFQ를 개선한 많은 스케줄러가 쓰이고 있다고 한다.</p>\n<p>오늘까지 CPU scheduler에 대하여 배웠다. 다음에는 multi process에서 프로세스간 통신에 대하여 공부해보자!</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"July 26, 2023","title":"(OS) 운영체제 복습 [5. Scheduling Policies]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(5) - Scheduling Policy/"}},"prev":{"id":"d604be56-daee-5aa4-a1ea-0862cb317fbb","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>배열에서 인자로 들어온 val과 같은 원소를 제거하고, 제거한 갯수를 리턴한다. <a href=\"https://leetcode.com/problems/remove-element\">링크</a></p>\n<p>해당 갯수까지의 배열의 구성이 같은지 확인한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<h2 id=\"sol1-replace-val-to-large_num\" style=\"position:relative;\"><a href=\"#sol1-replace-val-to-large_num\" aria-label=\"sol1 replace val to large_num permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol1. replace val to LARGE_NUM</h2>\n<p>선형탐색을 하며 val을 세면서 val을 LARGE_NUM으로 바꾼다.</p>\n<p>이후, sorting하여 val이 뒤로 밀려나게 한다.</p>\n<h2 id=\"sol2-선형-탐색\" style=\"position:relative;\"><a href=\"#sol2-%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89\" aria-label=\"sol2 선형 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sol2. 선형 탐색</h2>\n<p>선형탐색을 하며 val을 제외한 값들을 nums에 넣어준다. 넣어주면서 인덱스를 기록한다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity</p>\n<ul>\n<li>\n<p>sol1 : 소팅하므로 O(nlogn)</p>\n</li>\n<li>\n<p>sol2 : 선형탐색만 하므로 O(n)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">LARGE_NUM <span class=\"token operator\">=</span> <span class=\"token number\">51</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        replace all val in nums to LARGE_NUM\n        and sort nums\n        \"\"\"</span>\n        val_cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> val<span class=\"token punctuation\">:</span>\n                val_cnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> LARGE_NUM\n        nums<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>val_cnt</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        val마주치면 pass and cnt +=1\n        \"\"\"</span>\n        k <span class=\"token operator\">=</span> <span class=\"token number\">0</span> \n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> val<span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> \n                k <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> k</code></pre></div>\n<p>두번째 방법이 좀 더 classic하다고 볼 수 있다. new_list를 두고 val이 아닌 값을 추가할 수도 있겠지만, new_list의 사이즈는 항상 nums보다 작으므로 nums에서 처리가 가능하다!</p>\n<p>결과는 의외로 sol1가 더 빠르게 나왔다. val이 많지 않은 경우에는 sol2는 대입 연산이 더 많아지기 때문인가? 싶긴 하지만, 최적화된 소팅에 알맞은 데이터가 들어온 것도 속도에 도움이 될 것이라고 추측해보았다.</p>","frontmatter":{"date":"August 23, 2023","title":"(Alg) LeetCode Top Interview 150 - 27. Remove Element","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-27/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-26/","nextSlug":"/OS(5) - Scheduling Policy/","prevSlug":"/Alg-LC-27/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}