{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/FE-React-VDOM/",
    "result": {"data":{"cur":{"id":"b1a7cbae-d422-5854-a437-30b308f2df7a","html":"<p>기존 브라우저의 DOM 트리를 어떻게 처리하는지 간단하게 알아보고, react의 Virtual DOM이 어떤 방법으로 개선하려고 했는지 알아보도록 하자. (일부 정확하지 않을 수 있음)</p>\n<h3 id=\"브라우저에서-페이지를-보여주는-과정\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A5%BC-%EB%B3%B4%EC%97%AC%EC%A3%BC%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"브라우저에서 페이지를 보여주는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저에서 페이지를 보여주는 과정</h3>\n<p>기존 브라우저에서 html, css, js, 각종 정적인 파일들로 구성된 페이지를 보여주는 아주 개략적인 과정은 다음과 같다.</p>\n<p>우선, HTTP 프로토콜을 통한 리소스 요청 등(url을 입력한다던가, 특정 버튼을 누른다던가)에 의하여 서버로부터 위의 파일들을 받는다.</p>\n<p>브라우저는 렌더링엔진(ex. Gecko, webkit 등 브라우저마다 상이)의 html parser를 이용하여 HTML tag에 각각 대응이 되는 <code class=\"language-text\">DOM</code>(Document Object Model) tree를 만든다. 또한 CSS parser를 이용하여 <code class=\"language-text\">CSSOM</code>(CSS Object Model) tree를 만들고 이를 합쳐 <code class=\"language-text\">render tree</code>를 만든다. 파싱이 다 되고 나서야 render tree를 만드는 것은 아니고 되는대로(네트워크를 통해 전송받아 파싱이 되는대로, 등…) 만들어서 사용자에게 보여주는 것이라고 한다.(<a href=\"https://d2.naver.com/helloworld/59361\">출처</a>) render tree는 DOM tree와 1:1로 대응되지는 않는다.</p>\n<p>렌더 트리를 만드는 과정을 <code class=\"language-text\">attach</code>(스타일 포함한 객체로 변환)라고 한다. 이후,  <code class=\"language-text\">layout</code>(px단위로 정확한 위치 계산, <code class=\"language-text\">reflow</code>)의 과정 이후에 <code class=\"language-text\">paint</code>(그리기)를 하여 사용자가 보게 되는 것이다. 이 과정은 항상 정해진 것은 아니고, 각 엔진별로 캐싱, 최적화 등의 과정을 통하여 다르게 진행될 것이다.</p>\n<p>script 태그를 마주치는 경우에는 렌더링엔진에서 자바스크립트 엔진(ex. v8)으로 스위칭되어 자바스크립트 코드를 실행하게 된다. 해당 태그의 코드가 모두 실행된다면 다시 렌더링엔진이 컨텍스트를 가져가게 된다. 만약 자바스크립트 등에 의하여 화면의 변경이 이루어진다면, reflow, repaint의 과정을 거치게 된다.</p>\n<blockquote>\n<p>브라우저가 웹페이지를 그리는 방법</p>\n<p>[fetch] -> HTML/CSS/JS -> [parsing] -> DOM + CSSOM ->[attach]-> Render tree -> [layout/reflow] -> [(re)paint]</p>\n</blockquote>\n<h4 id=\"만약-리렌더링되는-경우에는\" style=\"position:relative;\"><a href=\"#%EB%A7%8C%EC%95%BD-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8A%94\" aria-label=\"만약 리렌더링되는 경우에는 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>만약 리렌더링되는 경우에는?</h4>\n<p>JS에서 DOM element를 건드리는 경우에는, 바꿔야 할 부분을 sub tree로 하는 DOM tree를 다시 만들고, re-paint하는데 까지의 과정이 필요하다. 모든 요소가 그려진 후 브라우저에서 일부 변경이 생길 경우엔, 해당 렌더러와 그 자식의 배치과정과 repaint 메서드가 발생한다.</p>\n<p>만약, 위의 과정에서 비교적 시간이 오래 걸리는 reflow, repaint를 줄일 수 있다면 좋겠지만 이는 어려운 일이다. 요즘 같이 복잡한 웹서비스에서는 더 많은 리렌더링 연산이 요구된다. 이에 리액트에서는 <code class=\"language-text\">Virtual DOM</code>으로 성능을 개선하고자 한다.</p>\n<h3 id=\"virtual-domin-react\" style=\"position:relative;\"><a href=\"#virtual-domin-react\" aria-label=\"virtual domin react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM(in react)</h3>\n<p>경량화, 추상화된 DOM이라고도 볼 수 있는 가상돔(Virtual DOM, VDOM)은 브라우저의 리렌더링 횟수를 줄이기 위해 <strong>최종적으로 리렌더링해야할 노드들을 기록하였다가 한번에 렌더링하도록 한다</strong>. 여러 layout과 paint 연산 대신 <u>하나의(그치만 무거운) layout과 paint 연산을 수행</u>하도록 하여 속도를 어느정도 개선한 것이다. 리렌더링이 매우 자주 일어나는 웹서비스에서는 VDOM이 더 유리할 가능성이 높다.</p>\n<p>React 공식 홈페이지에서는 VDOM을 <code class=\"language-text\">이상적인 또는 “가상”적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념</code>이라고 정의한다. DOM에서 필요한 정보들만으로 추상화되어 있고, js 객체로 구성된 VDOM은 2개의 상태(과거 시점, 업데이트 시점)를 비교하여 리렌더링을 진행한다.</p>\n<blockquote>\n<p>VDOM은 기존의 많은 리렌더링 연산을 한번의 리렌더링으로(batch 단위로) 업데이트한다.</p>\n</blockquote>\n<h4 id=\"리렌더링-in-vdom-reconciliation\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81-in-vdom-reconciliation\" aria-label=\"리렌더링 in vdom reconciliation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리렌더링 in VDOM (reconciliation)</h4>\n<p>리액트에서는 VDOM에서 어떤 노드가 변하였는지 알기 위해 비교(diffing)의 과정을 갖는다. 만약 모든 노드들의 값, 속성이 바뀌었는지 파악한다면 매우 많은 시간이 걸릴 것이지만, 리액트는 비교를 해야할 것들을 최소화하여 이 시간을 단축하였다. (<u>컴포넌트의 이름을 비교하고, list 등에 key로 비교하는</u> 등)</p>\n<p>리액트에서 리렌더링이 발생하는 과정에 대하여 좀 더 공부해보자.</p>\n<p>우선, 해당 컴포넌트의 <strong>state가 변경이 된다</strong>. useState hook의 setter로 업데이트 하였다면 해당 컴포넌트가 <code class=\"language-text\">rendering queue</code>로 들어간다. React는 <code class=\"language-text\">Object.is()</code>와 같은 비교 알고리즘으로 state가 진짜로 변경되었는지 여부를 판단할수 있게 된다. <a href=\"https://ko.reactjs.org/docs/hooks-reference.html\">출처</a></p>\n<p>VDOM의 루트노드부터 렌더링을 해야하는지 판단하는데, 이를 <code class=\"language-text\">rendering pass</code>라고 부른다. 이때는 해당 컴포넌트가 rendering queue에 있다면 렌더링해준다. 렌더링된다면, 해당 컴포넌트의 자식 컴포넌트가 리턴되는 형식이며 이는 재귀적으로 수행된다. 그러나 이전과 값이 동일한 참조이고, 렌더링을 해야하는 다른 이유가 없다면 리액트는 컴포넌트에 대한 렌더링 결과를 버리고 렌더링 패스를 벗어난다고 한다. <a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">출처</a></p>\n<p>따라서, 아래와 같이 버튼을 눌렀을 때 1을 더해주는 코드는 state가 변경이 된 것 처럼 보여도 해당 시점에 렌더링이 되지 않을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>me<span class=\"token punctuation\">,</span> setMe<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> <span class=\"token number\">25</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">...</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onPlusAge</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> after_change <span class=\"token operator\">=</span> me<span class=\"token punctuation\">;</span>\n    after_change<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">is</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">,</span> after_change<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n    <span class=\"token function\">setMe</span><span class=\"token punctuation\">(</span>after_change<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// re-render X!</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>따라서 불변성 지키며(다른 주소를 할당해야 함) state를 set해줘야 한다. <strong>헷갈리면 Object.is()로 비교해보자.</strong></p>\n<p>++ (참고) useEffect는 그리기를 완료한 <strong>후</strong> 발생한다고 한다.</p>\n<blockquote>\n<p>리액트의 리렌더링에서 알아야할 것</p>\n<ul>\n<li>state 변경은 불변적으로 수행해준다. setState가 다 해주는 것은 아니다</li>\n<li>리렌더링된다면 재귀적으로 자식 컴포넌트도 리렌더링 된다.</li>\n</ul>\n</blockquote>\n<p>리렌더링이 된다고 해서, 항상 다시 paint가 일어나는 것은 아니고 위에서 말한 reconciliation의 과정을 거쳐 실제 DOM에 적용을 하는 것으로 이해하면 될 것 같다.</p>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<p>리액트에서 VDOM은 항상 빠르다고 볼 수 없지만, Diffing과 batch update의 과정(필요한 노드들만 한번에 업데이트 하는 과정)을 통하여 DOM을 직접 제어하는 것보다는 빠를 확률이 높다고 볼 수 있다.</p>","excerpt":"기존 브라우저의 DOM 트리를 어떻게 처리하는지 간단하게 알아보고, react의 Virtual DOM이 어떤 방법으로 개선하려고 했는지 알아보도록 하자. (일부 정확하지 않을 수 있음) 브라우저에서 페이지를 보여주는 과정 기존 브라우저에서 html, css, js, 각종 정적인 파일들로 구성된 페이지를 보여주는 아주 개략적인 과정은 다음과 같다. 우선, HTTP 프로토콜을 통한 리소스 요청 등(url을 입력한다던가, 특정 버튼을 누른다던가)에 의하여 서버로부터 위의 파일들을 받는다. 브라우저는 렌더링엔진(ex. Gecko, webkit 등 브라우저마다 상이)의 html parser를 이용하여 HTML tag에 각각 대응이 되는 (Document Object Model) tree를 만든다. 또한 CSS parser를 이용하여 (CSS Object Model) tree를 만들고 이를 합쳐 를 만든다. 파싱이 다 되고 나서야 render tree를 만드는 것은 아니고 되는대로(네트워크를…","frontmatter":{"date":"March 12, 2023","title":"(React) Virtual DOM에 대하여 알아보자","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-React-VDOM/"}},"next":{"id":"7df92e5c-18d2-56fc-b495-408cfe132637","html":"<h1 id=\"js-타입\" style=\"position:relative;\"><a href=\"#js-%ED%83%80%EC%9E%85\" aria-label=\"js 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 타입</h1>\n<p>우리는 타입을 크게 신경쓰지않으며 변수를 선언하지만, 실제 js에서는 크게 7가지 타입이 있다. 타입에 따라 js엔진이 저장, 처리하는 방법이 다르고 결과에 영향을 미치기에 우리는 타입에 대하여 알 필요가 있다.</p>\n<p>js 변수에는 주소가 할당된다. 변수는 결국 사람이 보기 위해 만든 ‘식별자’이며, 변수는 어떠한 값을 갖는 주소로 대치된다. 여기서는 구체적으로 js가 stack, heap의 공간에 적재하는 방법보다는 그 값들을 어떻게 사용하는지, 즉 타입에 대한 정책을 공부해보고자 한다.</p>\n<h2 id=\"원시-타입primitive-type---immutable\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85primitive-type---immutable\" aria-label=\"원시 타입primitive type   immutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원시 타입(Primitive type) -> immutable</h2>\n<ul>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Number</li>\n<li>BigInt</li>\n<li>String</li>\n<li>Symbol</li>\n</ul>\n<p>위의 타입들은 원시 타입에 해당하며, 원시값은 불변하다.</p>\n<p>불변한 값들은 바뀌지 않고, 대입 연산자(=)를 통하여 새로운 값이 할당 된다.</p>\n<p><u>여기서 말하는 값은 변수가 가리키는 주소에 적혀있는 내용</u>! 그걸 값이라고 생각하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\na<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">===</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// false</span></code></pre></div>\n<p>a는 새로운 값(2)이 할당된다. a는 1이 위치한 주소를 가리키고 있다가 대입 연산을 통하여 [1이 2로 변경된 것이 아닌] <strong>2가 위치한 주소를 가리키도록 바뀌</strong>는 것이다.</p>\n<h3 id=\"const\" style=\"position:relative;\"><a href=\"#const\" aria-label=\"const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const</h3>\n<p>위의 코드에서 변수 선언 키워드를 let에서 const로 바꾸면 반드시 에러가 난다. const로 선언된 변수는 값의 재할당이 되지 않기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\na<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code></pre></div>\n<p>즉, 원시타입의 변수는 항상 대입연산자에서 새로운 주소로 할당이 이루어 진다는 것을 알 수 있다!</p>\n<p>추가적으로, const에 대하여 헷갈렸던 점을 정리해보자면…</p>\n<p>const로 선언한 변수에 재할당이 완전 불가능한 것은 아니다. <strong>const로 선언한 변수로는 재할당이 불가능</strong>한 것이다… 말이 어렵지만, <code class=\"language-text\">react.js</code>에서 힌트를 얻을 수 있다. <code class=\"language-text\">const [count, setCount] = useState(0);</code>와 같이 state를 const로 선언하고, setState함수로 state를 재할당하지 않는가?</p>\n<p>당연히, 리액트에서 <code class=\"language-text\">count +=1;</code>와 같은 코드는 존재하면 의도하지 않은 결과를 보이겠지만, const로 선언하면 해당 코드에서 에러가 나오게될 것이다! 따라서 state를 const로 선언하는 것은 리액트가 추구하는 방향인 것이다 ^_^</p>\n<p>원시값에도 각 타입마다 사용가능한 함수가 다르므로 차이를 알고 사용할 수 있도록 한다. 원시값의 함수는 대부분 새로운 값을 리턴하는 immutable function일 것이다.</p>\n<h2 id=\"객체object-type--참조reference-타입---mutable\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4object-type--%EC%B0%B8%EC%A1%B0reference-%ED%83%80%EC%9E%85---mutable\" aria-label=\"객체object type  참조reference 타입   mutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체(object type) / 참조(reference) 타입 -> mutable</h2>\n<p>객체, 함수, 배열 등</p>\n<p>객체타입은 변경이 가능하다. 따라서, 객체 타입에서의 대입 연산은 원시타입과 다른 결과를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> age_origin <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> age_origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person_after_year <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\nperson_after_year<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token operator\">===</span> person_after_year<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">===</span> age_origin<span class=\"token punctuation\">)</span> <span class=\"token comment\">//false</span></code></pre></div>\n<p>위의 코드를 <a href=\"https://pythontutor.com/visualize.html#mode=display\">pythontutor.com</a>의 visulize 서비스를 이용하여 이를 시각화해볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVQoz32SbW/aMBSF+f9/ZF/WD/vUVm2lTVvXjmYg6EqgLTQECMS8hJAXJ7bjZyLZKqRJO9Lx9dW1zvWxb4t/YOs1y1KCYFFTa/1eDcMQz/MQQmCtrc8fY7OHljYVSlcoYyl1RalNnctCEcUJ22iPNqZpZSHPJXF8IMtlnZ/yKN6ahzu+d0bcdVxG0zXt/gu90QyRWBa7kuVe1w1OHawCjyzZAiUggQJQtWhrE+dMlgn+OmfwFuL8mtB/ntNxpzyNV/SGPqYCU1WkhWJ3OLB8ucD98QExu0asr/H9TyjlNpaPgp7ImG8LXE9w1x1x6wz4fN/DfVvx0/VZxzmbQ8YqSplvtkTTK6a9jyy9c0JxyX5/iVJPfwUlnsiZiowgUkyCmHb/lYfHMZNFxGAWEewSjm/dwCDX9wydMybDc4LlDdY+YMxrY3m1S7j44tQ3+uYMuPrq0H4cc3Pb5dnf0h0LEqn+fIqlshatSoxRVEZTVRqlCoxpJqFVKE0iNVmhOWRlHeNUkkpNKlXN6mQ8/odj/TelLl46O0MgJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img1\"\n        title=\"img1\"\n        src=\"/static/ab3fbf029ae6ffc630a5a99864b03606/37523/img1.png\"\n        srcset=\"/static/ab3fbf029ae6ffc630a5a99864b03606/e9ff0/img1.png 180w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/f21e7/img1.png 360w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/37523/img1.png 720w,\n/static/ab3fbf029ae6ffc630a5a99864b03606/5a6dd/img1.png 802w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>객체 타입을 대입해주면, 해당 변수가 객체의 주소를 갖게 되는 것이다. 따라서, 여러 변수가 같은 객체를 공유하게 되는 상황이 올 수 있다. 이러한 상황을 ‘얕은 복사’라고 볼 수 있다. person과 person_after_year는 <code class=\"language-text\">alias</code>관계를 갖게 되는 것이다.</p>\n<h3 id=\"const-1\" style=\"position:relative;\"><a href=\"#const-1\" aria-label=\"const 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const</h3>\n<p>그럼 여기서도 const로 선언해도 될까? 당연히 가능하다!! const는 재할당을 막는 것이지만, <strong>객체의 프로퍼티를 변경하는 것은 값을 변수의 주소를 재할당하는 것이 아니</strong>기 때문이다 ~</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> age_origin <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'hong'</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> age_origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> person_after_year <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\nperson_after_year<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//에러가 발생하지 않는다!!</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token operator\">===</span> person_after_year<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">===</span> age_origin<span class=\"token punctuation\">)</span> <span class=\"token comment\">//false</span></code></pre></div>\n<h3 id=\"복사얕은-깊은\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC%EC%96%95%EC%9D%80-%EA%B9%8A%EC%9D%80\" aria-label=\"복사얕은 깊은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사(얕은, 깊은)</h3>\n<p>원시값과 다르게 참조의 형태로 값이 전달되는 것(얕은 복사)은 간혹 의도하지 않은 결과가 나올 수 있다. (실행 순서에 따라 다른 결과가 나올 수도 있다)</p>\n<p>따라서, 객체타입에서 값을 대입할 때(복사할 때)에는 깊은 복사를 진행해줄 필요가 있다. 이를 위해서는 크게 3가지 방법이 존재한다.</p>\n<ol>\n<li>정석적으로 깊은 복사(depth만큼의 for loop를 통하여 원시값들을 복사해온다) : 이 방법은 깊이가 낮을 때에는 편하지만 깊어질수록 어려워진다. 재귀함수를 써서 구현해볼 수 있을 것 같다.</li>\n<li>라이브러리(<code class=\"language-text\">immutable.js</code>등) : 이를 위한 신뢰도 높은 라이브러리가 존재하므로 잘 읽어보고 사용하면 될 것 같다.</li>\n<li>트릭 : <code class=\"language-text\">JSON.parse(JSON.stringify(object))</code> js에서 객체 타입은 JSON으로 변경이 가능하므로, 이와 같은 트릭으로 할 수도 있다. 하지만, 객체를 문자열로 바꾸고 다시 JSON으로 파싱하는 것이므로 속도가 느릴 것이며 권장되지 않는다.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB8UlEQVQ4y5WSWW/aUBCF+f9/o6patX2ooj61eUgTVU1ICIQtBgzesNkM3sAb1/erME0IbaOkRxrN6C5nzp1zK1JKnsYO2+2WMAxZr9dl/YAkSfB9nyiKHs8+5AdU+Ae2eY49HmMaBnEcP64HQYCmjbAs83ejnYiijH0NlYExZWTNMSYrNNtFt12W0RY/lmXk4lhJkm4p5N8i9tuSSq1rctPR6Yzm1Do6160RqhOg2gGKuSLOxBHhzKgxbJ8SzFvEcRfPqyOECoi9QstNmQaCtupw9rNB/d4oc0MxuGz0CeOcdZIRximOt2ZhnNO/foOlnOB5X1HV90TR2W5Qe0J7leN4OfYqw3ITLqptru4G9PQ5bX2Js1qX6gopEQVky2u0+jv6jU+Y5glCXCDEFVJme1OqrRHV5pDmwOFHTaHaVDm7anGvzeiYHm6YHM2qSGYsJ13cqYLvqySJTpaNkXI/msqdotPs6XTVMY3uiJ42oanomFOf4SRgEcRESUqc5uUFP9yQZsXzpvBKlHNMchbWLXr3FH92x2bTxvdvyfP+wZQ/P/ZzscMiTJho31Fv3mL1vrBafWMw+EAUnR9MeRXZE1Lh3TCsvaVX/4hhfEaIc4ri8mDKS089JoV8M8F17nGnfaJII00N8tw+mML/QMoXm/8Chx3ipfxGvU4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img2\"\n        title=\"img2\"\n        src=\"/static/b8b3d6798ff62b24c10f4c98c39d8924/37523/img2.png\"\n        srcset=\"/static/b8b3d6798ff62b24c10f4c98c39d8924/e9ff0/img2.png 180w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/f21e7/img2.png 360w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/37523/img2.png 720w,\n/static/b8b3d6798ff62b24c10f4c98c39d8924/d7542/img2.png 810w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>깊은 복사를 성공적으로 했다면 위와 같이 분리된 객체로 저장될 것이다. 두 변수는 이제 서로 영향을 미치지 않는다!</p>\n<p>추가적으로, <code class=\"language-text\">spread연산자</code>(<code class=\"language-text\">...</code>)는 1 depth에 대하여만 깊은 복사를 해준다. (값을 옮겨 담는다고 생각하면 편할 것 같다)</p>\n<h2 id=\"함수의-성격\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EC%9D%98-%EC%84%B1%EA%B2%A9\" aria-label=\"함수의 성격 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 성격</h2>\n<p>함수의 성격 역시 mutable, immutable로 구분할 수 있다. mutable한 함수는 값을 변화시킬 것이고, immutable한 함수는 파라미터 값을 기반으로 새로운 결과값을 리턴하는 형식으로 구현되어 있다. 배열에서 concat, push를 보면 차이를 알 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> list_a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nlist_a<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[1,2,3,4]의 새로운 배열을 리턴 (immutable)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>list_a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1,2,3]!</span>\nlist_a<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// list_a에 접근하여 4를 추가 (mutable)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>list_a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1,2,3,4]</span></code></pre></div>\n<p>물론 함수 자체는 mutable하지만, 이는 함수의 성격에 따라 나눈 것이므로 구분지을 필요가 있다.</p>\n<h2 id=\"타입의-필요성\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"타입의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입의 필요성</h2>\n<p>나도 위의 내용을 이해하고 있지 않아, 의도하지 않은 결과가 나올때가 종종 있었다. 또한, react js에서 state는 불변하게 관리되어야 하므로 꼭 타입에 대한 이해가 선수되어야 한다는 것을 깨달았다.</p>\n<p>또한, 타입에 따라 제공되는 함수가 다르므로 각 타입을 구분할 수 있어야 할 것이다!</p>\n<p>다음에는 js에서 변수를 선언하는 방식(var, let, const)과 이에 따른 메모리 구조에 대하여 간단하게 알아보자.</p>\n<p>출처 : <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures</a></p>","frontmatter":{"date":"March 05, 2023","title":"(JS) 자바스크립트 타입","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-JS-type/"}},"prev":{"id":"c25f6b47-0620-527d-9513-e5ec469005fd","html":"<h2 id=\"서비스-내용\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%82%B4%EC%9A%A9\" aria-label=\"서비스 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서비스 내용</h2>\n<p>이름은 <strong>마켓 구리</strong>! (좀 구리지만 이름을 붙혀놔야 기억을 잘하니까)</p>\n<p><strong>구독 상품과 일반 상품</strong>을 구매할 수 있는 <strong>마켓 웹서비스</strong>를 구축해보자.</p>\n<p>판매자(관리자)가 물건을 등록하고, 사용자는 물건을 구매하거나 정기 구매를 하도록 한다.</p>\n<h2 id=\"use-case\" style=\"position:relative;\"><a href=\"#use-case\" aria-label=\"use case permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>use case</h2>\n<p>아주 간단한 유즈케이스 다이어그램을 그려보았다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 167.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAABYlAAAWJQFJUiTwAAADPklEQVRIx43W527jQAwEYL//y+R3kCAJUpHee++997qHjwAPis+yT8B6vW2WHA4pNb6/v0u1fXx8RHt/f4/+5+enrK+vl97e3jIzM1P6+vrK6elp+fz8jD36PON8w49D2tXVVbm8vIx2fX1dLi4u4vDR0VE5Pj6O8cnJSTk/P/+7V69ZM258fX3FLXob83H7w8NDubu7i/7+/r48PT2Vdg/Qxs3NTVlaWooJtzOdddwcHByMfm5uLtrq6mp5fHyMvelVtYWFLNjY2AiQzc3N6FkCPMcHBwfhMtdfX1//AcxxAL68vJTDw8NydnZWtre3f7nAGpt4oSVYAjT34TJrbMbh7u5u8Ji8Jen629vbOKDhvGrlLwvX1tbK5ORk2d/fDyCPw+YHBgaCu5GRkTI0NPSXSwbUAvrZ2dmJTf7nBtzhFvjz83P0JITbt7e3esAqZ1XZACQVVqfuUuh1HAYgYeNPj5/UU/Kmsd4FQJv5awlokICiTdQkgsOenp4yNTVV+vv7y8LCQqy3tZAb5ABQIPDFChHf29sLDeKNDnFovS0gl5aXl4MnmZAu2kCjOdaqwWilxwBEPMtWVlaiZ61Flhmn6Le2tiJFM3C1FnKBBg0cyOiOj48Hb9PT0wGin5iYCBraAsqUDAarTLJS5AFr3LaPhKpRbglI1KOjo0E69ywAsAiAVHIsgB05dLPokQoePaybn58PChQM7qo8UtQFbYtDNVNIhVXAFxcXA4TlaqL/s7OzYUVHYWemZPmvph+5uESf/HVMvQQFoGzRIxpEl6hx63+Ku47LX4AmbPZm6+rqipJFOtxUukhoeHi4jI2NxZ7aapOAHrJBrIzIjbSXwTJnjcR41NFlPNFdBiflktJpVXFqXc63XpYwkQaegN4vyV3HoGT5krtcwqV01ANiucD811tPLoteNZcBI7+7uztE7b+AWG8n7AAEoIAKCKs8XMvPkdRhpmGzZFq+l7nmoGwwyWquA6iW/+bItgTEEZdFDke4VPu4Sh6KR1buuk+RX4DIVgDSksxphUCvmhM3/vzPPbXfNjZSvtRKyXBNCmqqEatIKK1r+/XVPMHN/OTIDySNRllg3uXZcq9zxn8AKRsb8EmON/gAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20230411182153714\" title=\"image-20230411182153714\" src=\"/static/15d67c030f1cf9b78f09d470b5f1847c/37523/usecase.png\" srcset=\"/static/15d67c030f1cf9b78f09d470b5f1847c/e9ff0/usecase.png 180w,\n/static/15d67c030f1cf9b78f09d470b5f1847c/f21e7/usecase.png 360w,\n/static/15d67c030f1cf9b78f09d470b5f1847c/37523/usecase.png 720w,\n/static/15d67c030f1cf9b78f09d470b5f1847c/940c5/usecase.png 772w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>비회원의 경우, 상품목록까지만 볼 수 있고, 회원이 되어야만 상품을 구매할 수 있도록 할 예정이다. 판매자는 상품을 등록하고 판매내역을 볼 수 있게 할 예정이며, 이는 관리자 페이지의 형식으로 제공할 예정이다.</p>\n<h2 id=\"서비스-구조\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"서비스 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서비스 구조</h2>\n<p>프론트엔드와 백엔드를 분리하여 개발/운영한다. 일단은 on-premise로 개발하고, 시간이 된다면 AWS와 같은 서비스에 올려 직접 배포해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABi0lEQVQ4y4XTh4rDQAwEUP//HwYSCCGdxOm97PEEMnvhyC0MXsvSaFTcvF6v8nw+A3/dj8djOZ/PHU6nU1kul2U4HJbBYFAWi0WZzWZlv9+Hb5MEn0B4v9/L5XIpzvv9LnnYV6tVmUwmZTqdltFoFIn4NhwF53FnA8Sc2ODxeEQgNdvtNhQiZMvkTdtuwmE8HsdHspUkwLuSKOj1ep0aoHC32wXE3263aEmz2WziRSAimTghFsSGKJ8S+c4vK3GHICS37o876cqD7GH2DvH1eu3KJgjEBSElSKkBdzb9q4fiIJrP50FGLZiw4UgehDmEw+FQUm1OuVaYVfiGlD8Beu+pbTEUDkkoc034uTZJqkTJlayatm1/EwpWDuRCf9tDhIZoOJ452CCsCVJdTciRmn6/H6ujT0mof0rWgm4Pv/0p2WhKlJW7pzWC1+t1h25tPkk+CQVSRA0lCL0joT6Tatevkr8R5jStB2IDrBcc+P+rMPtCUf3XSPTX6fbwm0JroWf5R7jnsGqwUf4DED/XNSEEy48AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20230411184150532\"\n        title=\"image-20230411184150532\"\n        src=\"/static/bf1a423e232d6dca96105f77f8408a18/37523/architecture.png\"\n        srcset=\"/static/bf1a423e232d6dca96105f77f8408a18/e9ff0/architecture.png 180w,\n/static/bf1a423e232d6dca96105f77f8408a18/f21e7/architecture.png 360w,\n/static/bf1a423e232d6dca96105f77f8408a18/37523/architecture.png 720w,\n/static/bf1a423e232d6dca96105f77f8408a18/302a4/architecture.png 1080w,\n/static/bf1a423e232d6dca96105f77f8408a18/07a9c/architecture.png 1440w,\n/static/bf1a423e232d6dca96105f77f8408a18/fde66/architecture.png 1574w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하나의 서버 컴퓨터라고 생각하고, nginx와 같은 웹서버를 두어 요청에 따라 front 또는 api 서버에 요청을 전달하고 이에 맞는 응답을 해주도록 구성하였다.</p>\n<p>규모가 커질수록 역할에 따라 서버컴퓨터(혹은 클라우드 서비스)를 나눠놓는 것이 합리적이지만, 이런식으로 구성하여도 나중에 분리하는 것은 크게 어려운 것은 (보안 설정 등을 제외하고는) 어렵지 않으니 응용할 수 있을 것이다.</p>\n<p>참고: 위의 그림은 <a href=\"https://app.diagrams.net\">draw io</a>를 이용하여 그림</p>","frontmatter":{"date":"April 11, 2023","title":"(Django) 장고 api 서버를 이용한 프로젝트 [1-서비스 기획 및 설계]","categories":"BE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/Django(1)-overall/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/FE-React-VDOM/","nextSlug":"/FE-JS-type/","prevSlug":"/Django(1)-overall/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}