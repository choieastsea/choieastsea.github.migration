{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-909/",
    "result": {"data":{"cur":{"id":"b42ec5e0-aae0-562f-9b65-3158bbeffa0d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. <a href=\"https://leetcode.com/problems/snakes-and-ladders/\">링크</a></p>\n<p><a href=\"https://www.acmicpc.net/problem/16928\">백준 16928</a>과 거의 같은 문제이다.</p>\n<p>뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다.</p>\n<p>하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getLocOfBoard</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    row <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n    col <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>row<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n    <span class=\"token keyword\">return</span> row<span class=\"token punctuation\">,</span>col</code></pre></div>\n<p>아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n^2)</p>\n<p>노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사위 최댓값)이하이므로 시간복잡도는 O(n^2)라고 볼 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n^2)</p>\n<p>deque의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">snakesAndLadders</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># [blockNum,time]</span>\n        visited <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q)</span>\n            blockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 목적지 도달한 경우</span>\n            <span class=\"token keyword\">if</span> blockNum <span class=\"token operator\">==</span> n<span class=\"token operator\">*</span>n<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> time\n            <span class=\"token comment\"># 1~6칸 이동</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                nextBlockNum <span class=\"token operator\">=</span> blockNum <span class=\"token operator\">+</span> i\n                nextRow <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n                nextCol <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>nextRow<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n                <span class=\"token comment\"># print(nextBlockNum, nextRow,nextCol)</span>\n                <span class=\"token keyword\">if</span> nextBlockNum <span class=\"token operator\">&lt;=</span> n<span class=\"token operator\">*</span>n <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> time<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></code></pre></div>\n<p>처음에 q에서 popleft를 하여 목적지인지를 판단하고 아니라면 계속하여 BFS를 수행하면 된다. q가 비어있는 상황은 모든 노드를 탐색하여 더 이상 연결된 탐색할 노드가 없는 경우이다. 답이 없는 경우에는 -1을 리턴하라고 했으므로, while 문이 빠져나오면 리턴해주면 된다.</p>","excerpt":"Intuition 뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. 링크 백준 16928과 거의 같은 문제이다. 뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다. Approach 방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다. 하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다. 아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다. Complexity Time complexity: O(n^2) 노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사…","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 909. Snakes and Ladders","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-909/"}},"next":{"id":"978ac032-18aa-54da-b2a7-1ec04a7419f7","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>graph가 주어졌을 때, <strong>깊은 복사</strong>를 수행한 그래프의 사본을 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/clone-graph/\">링크</a></p>\n<p>python에서는 원시 타입이 아닌 경우 참조형 객체에서 대입연산을 수행하는 경우 얕은 복사가 일어난다. 이는 원본 값이 바뀌면 사본 역시 바뀌게 되는 경우가 생기게 된다. 깊은 복사의 경우, 독립된 객체이므로 원본과 사본이 독립적이다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>깊은 복사를 수행하는 방법은 크게 두가지가 있다.</p>\n<ol>\n<li>\n<p>copy.deepcopy 함수를 이용</p>\n</li>\n<li>\n<p>원본 값의 마지막 depth까지 그래프를 탐색하며 새로운 값을 만들기</p>\n<p>그래프를 탐색하면서, 원본 노드의 값을 이용하여 새로운 노드를 만들고, 그래프의 연결관계를 초기화해주면 된다. 여기서 그래프를 탐색하는 방법에는 여러가지가 있는데 나의 경우 리스트로 간단하게 처리할 수 있는 DFS 탐색을 수행하였다.</p>\n<p>그래프를 탐색하다보면 <strong>같은 값의 노드를 여러번 생성하게 될 수도 있는데</strong>, 이를 방지하기 위해 사본 그래프의 모든 노드를 저장하는 dictionary로 노드의 중복 생성을 방지하였다.</p>\n</li>\n</ol>\n<p>1번은 간단하지만, 출제자의 의도를 생각하면 2번째 방법으로 하는 것이 좋을 것이다.(실제 해보니 성능도 좋다!)</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(V*E)</p>\n<p>그래프를 탐색하기 위해 노드 갯수와 엣지 갯수 만큼의 시간이 걸릴 것이다. 각 노드마다 연결된 간선을 탐색하며 다음 노드로 넘어가기 때문이다.</p>\n</li>\n<li>\n<p>Space complexity: O(V)</p>\n<p>stack의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"</span>\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 그래프를 깊은 복사하여 리턴</span>\n        <span class=\"token comment\"># node에서부터 neighbors DFS 탐색하며 만들자</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\n        root <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 원본</span>\n        copyDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>node<span class=\"token punctuation\">.</span>val <span class=\"token punctuation\">:</span> root<span class=\"token punctuation\">}</span> <span class=\"token comment\"># 사본</span>\n        <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>\n            cur_org <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># print(cur_org.val, 'popped', cur_org == copyDict[cur_org.val])</span>\n            <span class=\"token keyword\">for</span> neighbor <span class=\"token keyword\">in</span> cur_org<span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># print(neighbor.val)</span>\n                <span class=\"token comment\"># stack에 순회할 노드 추가</span>\n                <span class=\"token keyword\">if</span> neighbor<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> copyDict<span class=\"token punctuation\">:</span>\n                    stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">)</span>\n                    <span class=\"token comment\"># 없다면 새로운 노드 만들어줌</span>\n                    copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\"># 현재 노드와 neighbor 연결</span>\n                copyDict<span class=\"token punctuation\">[</span>cur_org<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                \n        <span class=\"token keyword\">return</span> root</code></pre></div>\n<p>copyDict라는 사본 노드들을 {‘숫자’ : ‘노드’} 형태의 dictionary로 저장한다.</p>\n<p>원본 노드들을 DFS로 탐색하면서, copyDict에 없다면 만들어주고, 있으면 해당 노드를 현재 노드와 연결(neighbors)해주면 된다.</p>\n<p>추가로, deepcopy 함수를 이용한 pythonic한 방법도 첨부한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> copy <span class=\"token keyword\">import</span> deepcopy\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> deepcopy<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span></code></pre></div>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 133. Clone Graph","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-133/"}},"prev":{"id":"197d0970-745b-5468-a9c2-1ef755c1599d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>0,1,2 로 구성된 정수형 배열을 오름차순으로 정렬하는 문제이다. <a href=\"https://leetcode.com/problems/sort-colors/\">링크</a></p>\n<p>문제에서는 라이브러리를 사용하지 않고, O(1)의 공간 복잡도로 문제를 해결하는 것을 제안하고 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ul>\n<li>\n<p>sol1</p>\n<p>0,1,2의 숫자를 세고 이후에 nums 배열에 값을 대입하는 방법을 생각해보았다.</p>\n</li>\n<li>\n<p>sol2</p>\n<p>sol1로 제출하고 속도가 느려 다른 풀이를 봤는데, <code class=\"language-text\">Dutch Flag Algorithm(DFA)</code>에 대한 언급이 많아 해당 알고리즘을 찾아보았다. <a href=\"https://medium.com/quick-code/dutch-flag-algorithm-3669af2b14fd\">출처</a></p>\n<p>DFA는 left, right, pointer(네이밍은 조금씩 다를 수 있으나, 의미는 유사하다) 3개의 포인터를 갖고 배열을 탐색한다.</p>\n<ul>\n<li>left : 가장 앞에 있어야 하는 값(여기서는 0)이 들어올 위치를 가리키는 포인터</li>\n<li>right : 가장 뒤에 있어야 하는 값(여기서는 2)가 들어올 위치를 가리키는 포인터</li>\n<li>pointer : 현재 위치를 가리키는 포인터</li>\n</ul>\n<p>0 ~ left, right ~ n-1의 구간은 각각 0,2로 확정되는 구간으로 만들고, left~right 사이를 순회하는 pointer를 두어 범위를 줄여나가는 것이 이 알고리즘의 핵심이다.</p>\n<p>배열의 pointer 위치를 보면서…</p>\n<ul>\n<li>2인 경우: right와 pointer를 swap 한다(보낼 수 있는 가장 뒤로 2를 보낸다). 이후 바뀐 pointer의 값을 다시 봐야할 것이므로 pointer는 옮기지 않는다. right는 앞으로 한칸 당겨 다음 2의 위치를 가리키도록 한다.</li>\n<li>1인 경우: pointer를 다음 칸으로 옮긴다.</li>\n<li>0인 경우: left와 pointer를 swap 한다(보낼 수 있는 가장 앞으로 0을 보낸다). left를 뒤로 당겨 다음 0의 위치를 가리키도록 한다. 여기서는 strt의 값이 <strong>무조건 0 아님 1이므로</strong> pointer를 다음칸으로 옮겨도 된다. <u>1의 위치는 0과 2를 양끝으로 보내기만 하면 알아서 가운데에 자리잡기 때문</u>이다.</li>\n</ul>\n<p>이를 <strong>pointer가 end보다 크지 않을 동안</strong> (pointer와 end가 겹치면 0<del>1</del>2 순으로 정렬이 완료되어 더 이상 보지 않아도 됨)탐색하면 된다.</p>\n</li>\n</ul>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity</p>\n<ul>\n<li>\n<p>sol1 : O(n), 하지만 sol2에 비하여 느리다 (심지어 python list sort 함수보다 느렸다) 배열을 두번 순회하므로 2*n의 시간이 걸리기 때문일 것이다.</p>\n</li>\n<li>\n<p>sol2 : O(n)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>두 방법 모두 공간 복잡도는 배열의 크기와 상관없이 일정할 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>첫번째 방법의 코드이다. 배열을 두번 순회하며 원소들의 갯수를 세어 값을 정렬한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        배열을 순회하며 0,1,2의 갯수를 센 이후,\n        배열을 다시 순회하며 값을 넣어줌\n        \"\"\"</span>\n        cnt0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        cnt2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> num <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                cnt0 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">pass</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                cnt2 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        cnt1 <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>cnt0<span class=\"token operator\">-</span>cnt2\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> cnt0 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                cnt0 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> cnt1 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n                cnt1 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n                cnt2 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>값은 단 3개로 정해져있으므로, <code class=\"language-text\">elif num == 2</code>가 아닌 <code class=\"language-text\">else</code>로 하니까 속도가 좀 더 빨라지긴 했다.</p>\n<p>두번째 코드는 <code class=\"language-text\">Dutch National Flag Algorithm</code>을 적용한 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Dutch National Flag Algorithm\n        pointer 위치에 있는 값을 확인하며,,,\n        2를 만나면 현재까지의 맨 뒤(right)로 스왑하여 보낸다 &amp; --left\n        1을 만나면 ++pointer\n        0을 만나면 현재까지의 맨 앞과 스왑하여 보낸다 &amp; ++strt &amp; ++pointer\n        \"\"\"</span>\n        left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> pointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">while</span> pointer <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># swap pointer ~ right</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move right to forward</span>\n                right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 0</span>\n                <span class=\"token comment\"># swap pointer ~ left</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token comment\"># move left to backward</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>맨 뒤로 보내는 경우에는 right에 어떤 값이 있는지 모르므로, swap 이후에 pointer를 업데이트 하지 않아야 한다. 반대로 맨 앞으로 보내야 하는 경우에는 left에 무조건 0또는 1만 존재하므로 swap하고 pointer를 뒤로 업데이트 한다!</p>","frontmatter":{"date":"September 18, 2023","title":"(Alg) LeetCode Top Interview 150 - 75. sort colors (Dutch National Flag Algorithm)","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-75/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-909/","nextSlug":"/Alg-LC-133/","prevSlug":"/Alg-LC-75/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}