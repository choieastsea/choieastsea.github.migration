{"componentChunkName":"component---src-templates-blog-template-js","path":"/Alg-LC-909/","result":{"data":{"cur":{"id":"b42ec5e0-aae0-562f-9b65-3158bbeffa0d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. <a href=\"https://leetcode.com/problems/snakes-and-ladders/\">링크</a></p>\n<p><a href=\"https://www.acmicpc.net/problem/16928\">백준 16928</a>과 거의 같은 문제이다.</p>\n<p>뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다.</p>\n<p>하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getLocOfBoard</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    row <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n    col <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>row<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n    <span class=\"token keyword\">return</span> row<span class=\"token punctuation\">,</span>col</code></pre></div>\n<p>아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n^2)</p>\n<p>노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사위 최댓값)이하이므로 시간복잡도는 O(n^2)라고 볼 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n^2)</p>\n<p>deque의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">snakesAndLadders</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># [blockNum,time]</span>\n        visited <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q)</span>\n            blockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 목적지 도달한 경우</span>\n            <span class=\"token keyword\">if</span> blockNum <span class=\"token operator\">==</span> n<span class=\"token operator\">*</span>n<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> time\n            <span class=\"token comment\"># 1~6칸 이동</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                nextBlockNum <span class=\"token operator\">=</span> blockNum <span class=\"token operator\">+</span> i\n                nextRow <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n                nextCol <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>nextRow<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n                <span class=\"token comment\"># print(nextBlockNum, nextRow,nextCol)</span>\n                <span class=\"token keyword\">if</span> nextBlockNum <span class=\"token operator\">&lt;=</span> n<span class=\"token operator\">*</span>n <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> time<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></code></pre></div>\n<p>처음에 q에서 popleft를 하여 목적지인지를 판단하고 아니라면 계속하여 BFS를 수행하면 된다. q가 비어있는 상황은 모든 노드를 탐색하여 더 이상 연결된 탐색할 노드가 없는 경우이다. 답이 없는 경우에는 -1을 리턴하라고 했으므로, while 문이 빠져나오면 리턴해주면 된다.</p>","excerpt":"Intuition 뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. 링크 백준 16928과 거의 같은 문제이다. 뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다. Approach 방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다. 하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다. 아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다. Complexity Time complexity: O(n^2) 노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사…","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 909. Snakes and Ladders","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-909/"}},"next":{"id":"978ac032-18aa-54da-b2a7-1ec04a7419f7","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>graph가 주어졌을 때, <strong>깊은 복사</strong>를 수행한 그래프의 사본을 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/clone-graph/\">링크</a></p>\n<p>python에서는 원시 타입이 아닌 경우 참조형 객체에서 대입연산을 수행하는 경우 얕은 복사가 일어난다. 이는 원본 값이 바뀌면 사본 역시 바뀌게 되는 경우가 생기게 된다. 깊은 복사의 경우, 독립된 객체이므로 원본과 사본이 독립적이다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>깊은 복사를 수행하는 방법은 크게 두가지가 있다.</p>\n<ol>\n<li>\n<p>copy.deepcopy 함수를 이용</p>\n</li>\n<li>\n<p>원본 값의 마지막 depth까지 그래프를 탐색하며 새로운 값을 만들기</p>\n<p>그래프를 탐색하면서, 원본 노드의 값을 이용하여 새로운 노드를 만들고, 그래프의 연결관계를 초기화해주면 된다. 여기서 그래프를 탐색하는 방법에는 여러가지가 있는데 나의 경우 리스트로 간단하게 처리할 수 있는 DFS 탐색을 수행하였다.</p>\n<p>그래프를 탐색하다보면 <strong>같은 값의 노드를 여러번 생성하게 될 수도 있는데</strong>, 이를 방지하기 위해 사본 그래프의 모든 노드를 저장하는 dictionary로 노드의 중복 생성을 방지하였다.</p>\n</li>\n</ol>\n<p>1번은 간단하지만, 출제자의 의도를 생각하면 2번째 방법으로 하는 것이 좋을 것이다.(실제 해보니 성능도 좋다!)</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(V*E)</p>\n<p>그래프를 탐색하기 위해 노드 갯수와 엣지 갯수 만큼의 시간이 걸릴 것이다. 각 노드마다 연결된 간선을 탐색하며 다음 노드로 넘어가기 때문이다.</p>\n</li>\n<li>\n<p>Space complexity: O(V)</p>\n<p>stack의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"</span>\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 그래프를 깊은 복사하여 리턴</span>\n        <span class=\"token comment\"># node에서부터 neighbors DFS 탐색하며 만들자</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\n        root <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 원본</span>\n        copyDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>node<span class=\"token punctuation\">.</span>val <span class=\"token punctuation\">:</span> root<span class=\"token punctuation\">}</span> <span class=\"token comment\"># 사본</span>\n        <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>\n            cur_org <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># print(cur_org.val, 'popped', cur_org == copyDict[cur_org.val])</span>\n            <span class=\"token keyword\">for</span> neighbor <span class=\"token keyword\">in</span> cur_org<span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># print(neighbor.val)</span>\n                <span class=\"token comment\"># stack에 순회할 노드 추가</span>\n                <span class=\"token keyword\">if</span> neighbor<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> copyDict<span class=\"token punctuation\">:</span>\n                    stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">)</span>\n                    <span class=\"token comment\"># 없다면 새로운 노드 만들어줌</span>\n                    copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\"># 현재 노드와 neighbor 연결</span>\n                copyDict<span class=\"token punctuation\">[</span>cur_org<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                \n        <span class=\"token keyword\">return</span> root</code></pre></div>\n<p>copyDict라는 사본 노드들을 {‘숫자’ : ‘노드’} 형태의 dictionary로 저장한다.</p>\n<p>원본 노드들을 DFS로 탐색하면서, copyDict에 없다면 만들어주고, 있으면 해당 노드를 현재 노드와 연결(neighbors)해주면 된다.</p>\n<p>추가로, deepcopy 함수를 이용한 pythonic한 방법도 첨부한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> copy <span class=\"token keyword\">import</span> deepcopy\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> deepcopy<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span></code></pre></div>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 133. Clone Graph","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-133/"}},"prev":{"id":"222f2675-aa22-52b5-b6a3-1e530a03e240","html":"<h2 id=\"orm\" style=\"position:relative;\"><a href=\"#orm\" aria-label=\"orm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM</h2>\n<p>ORM은 Object Relational Mapping의 약자.</p>\n<p>RDB의 테이블을 Object와 연결시켜 표현하고, SQL없이 해당 프레임워크의 언어로 데이터를 조작할 수 있도록 인터페이스 및 함수를 제공해준다. 이는 객체 지향 프로그래밍을 일관적으로 구성하는데 유용하다.</p>\n<p>또한, 여러 DB에 대하여 라이브러리가 존재하므로, DB를 변경할 때 생기는 DB의 문법적인 변경사항 등을 고려하지 않을 수 있다. (이식성이 높다)</p>\n<h2 id=\"n1-문제\" style=\"position:relative;\"><a href=\"#n1-%EB%AC%B8%EC%A0%9C\" aria-label=\"n1 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>n+1 문제</h2>\n<p>ORM을 사용하는 경우, 데이터에 접근하는 경우에 SQL 쿼리를 실행하게 된다.</p>\n<p>프레임워크마다 SQL을 실행하는 시점은 조금씩 다른데, 기본적으로는 <code class=\"language-text\">Lazy Loading</code>을 하게 될 것이다.</p>\n<blockquote>\n<p>장고에서는, Pages.objects.all() 등을 실행하면 쿼리셋이 생성되는데, 이때는 DB에 접근하지 않는다.</p>\n<p>쿼리셋 안의 데이터에 접근할 때, DB에 접근하게 된다. 이를 Lazy Loading(지연 로딩)이라고 한다.</p>\n<p>Lazy Loading과 반대되는 것은 Eager Loading(즉시 로딩)이다.</p>\n</blockquote>\n<p>하지만 참조된 테이블이 존재하는 경우, 1번의 쿼리로 가능한 구문이, <strong>참조되는 n개의 행에 접근하기 위해 쿼리를 n번 더 실행하는 경우</strong>가 생기는데, 이를 n+1 problem 이라고 한다.</p>\n<p>예를 들어, 학생과 학교 테이블이 있다고 생각해보자.</p>\n<p>학생들의 학교 이름을 출력한다고 할 때, 장고에서는 다음과 같이 짜볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students <span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># not yet query executed</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token comment\"># n+1 queries</span></code></pre></div>\n<p>이는 원래 SQL로 실행한다면 <code class=\"language-text\">SELECT school.name FROM student WHERE student.school_id = school.id;</code> 로 가능하다.</p>\n<p>하지만, ORM의 lazy loading의 경우 다음과 같은 순서로 실행 될 것이다.</p>\n<p><code class=\"language-text\">SELECT school_id FROM student;</code>하여 얻은 school_id를 각각 <code class=\"language-text\">sid</code>라고 했을 때,</p>\n<p><code class=\"language-text\">SELECT school.name FROM school WHERE school.id = {sid};</code> 를 <strong>추가적으로 n번(학생의 수만큼) 수행하게 되는 것이다</strong>.</p>\n<p>DB 쿼리를 실행하여 값을 가져오는 것은 (컴퓨터 기준으로 IO를 발생시키는) 오래걸리는 일이므로, 최소화 할 필요가 있다!</p>\n<p>장고에서는 EAGER loading (즉시 로딩)을 통하여 미리 참조된 데이터를 가져와 놓을 수 있는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students<span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span>selected_related<span class=\"token punctuation\">(</span><span class=\"token string\">'school'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># selected_related</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\t<span class=\"token comment\"># 1 query</span></code></pre></div>\n<p>selected_related를 통하여 미리 학교에 대한 정보를 JOIN하여 가져오는 쿼리셋을 만들고, 이후에 값을 가져와 n+1 문제를 해결할 수 있다.</p>\n<p>추가적으로 <code class=\"language-text\">prefetch_related</code>를 이용하여 모든 relationship에 대하여 사용 가능한 방법도 있다.</p>\n<p><a href=\"https://hckcksrl.medium.com/django-n-1-problem-d986b93f5d3e\">참고</a></p>\n<h2 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시</h2>\n<p>n+1 문제를 시각화하기 위하여 query의 수행 횟수를 출력해보자.</p>\n<p>django에서는 connection.queries에 수행한 쿼리들이 배열의 형태로 저장된다. 이를 api단에서 출력하는 테스트를 만들 수 있다.</p>\n<p>우선, DB 스키마는 다음과 같다.</p>\n<p><img src=\"https://github.com/choieastsea/notion-be/blob/master/schema.png?raw=true\" alt=\"schema\"></p>\n<p>트리 형태의 page를 저장하기 위한 데이터 베이스 구조로, page_id는 각각 page_trees의 ancestor과 descendant가 될 수 있다.</p>\n<p>page_trees 테이블에서 page_id가 1인 page를 ancestor로 하는 page_id를 출력하는 예시를 보자. Lazy Loading 방식과 Eager Loading 방식으로 구현해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryTest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># LAZY LOADING</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryImproved</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># EAGER LOADING (참조된 Page table도 가져옴)</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>select_related<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>두 api의 결과는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>detail(쿼리의 결과)는 같지만, 쿼리의 실행횟수가 LazyLoading 방식은 5번(해당하는 page의 수인 n만큼) 더 일어난 것을 확인해볼 수 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>이와 같이, <strong>참조된 테이블의 값을 지연 로딩을 통하여 가져오는 경우에는 n+1 문제가 발생</strong>할 수 있다. 관찰하다가 해당 쿼리가 불필요하게 많이 실행된다면, 해당 부분에 즉시 로딩을 도입하는 방법이 좋을 것이다. 그렇다고 모든 쿼리를 즉시 로딩을 한다면 역시 불필요한 쿼리가 실행되므로 로깅 등으로 기록하고 관찰하는 것이 좋을 것이다!</p>","frontmatter":{"date":"September 14, 2023","title":"(DB) n+1 문제와 해결책 (Django)","categories":"BE","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/BE-n+1/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-909/","nextSlug":"/Alg-LC-133/","prevSlug":"/BE-n+1/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}