{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/OS(6)-IPC/",
    "result": {"data":{"cur":{"id":"4816b4db-01ed-5807-a7d1-a04d66600126","html":"<p>저번까지 운영체제의 Scheduling에 대하여 알아보았다. 오늘은 프로세스간 통신에 대하여 알아보도록 하자.</p>\n<h1 id=\"inter-process-communicationipc\" style=\"position:relative;\"><a href=\"#inter-process-communicationipc\" aria-label=\"inter process communicationipc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inter Process Communication(IPC)</h1>\n<p>일반적으로 프로세스들은 독립적인 메모리 공간(memory space)를 갖고 있으므로, 메모리를 공유하지 않는다. 하지만, 프로세스간 communication이 필요한 경우가 많으며 서로 데이터를 공유할 상황도 생기므로, 이를 구현하기 위해 <code class=\"language-text\">IPC mechanism</code>에 대하여 알 필요가 있다.</p>\n<h1 id=\"shared-memory\" style=\"position:relative;\"><a href=\"#shared-memory\" aria-label=\"shared memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Shared Memory</h1>\n<p>그 중 첫번째로 <code class=\"language-text\">shared memory</code>에 대하여 알아보자.</p>\n<p><code class=\"language-text\">shmget()</code> 시스템 콜을 통하여 프로세스들은 같은 영역의 공유 메모리 자원에 접근할 수 있다.</p>\n<blockquote>\n<p>int shmget(key_t key, int size, int shmflg)</p>\n<p>여러 프로세스에서 같은 key를 통하여 같은 shared memory영역에 접근할 수 있게 된다</p>\n</blockquote>\n<p>해당 시스템 콜을 통하여 다수의 프로세스는 공유된 메모리 자원에 접근하여 read/write 연산을 수행할 수 있다.</p>\n<p>하지만, 주의해야할 점도 존재한다. shared memory는 단지 빈 메모리 영역이므로, 동시에 프로세스들이 같은 공간에 write하는 경우(overwrite)에 대한 처리가 필요하다.</p>\n<h1 id=\"signals\" style=\"position:relative;\"><a href=\"#signals\" aria-label=\"signals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Signals</h1>\n<p>다음으로는 OS에서 제공하는 signal을 이용하는 방법이 있을 것이다. 가장 널리 알려진 signal로는 프로세스를 종료하기 위해 ctrl+c를 눌러 <code class=\"language-text\">kill -9 signal</code>을 발생시키는 것 등이 있을 것이다. 또한 user-defined signal도 만들 수 있는 방법이 있는데, 어쨌든 이러한 signal을 통하여 <strong>한 프로세스에서 다른 프로세스로 어떠한 값(신호)을 전달</strong> 할 수 있는 것이다.</p>\n<p>모든 프로세스는 signal을 전달받으면 <code class=\"language-text\">signal handler</code>가 호출되는데, 데이터를 전달 받은 프로세스에서 해당 시그널을 전달 받았을 때 처리해야할 일들을 정의할 수 있을 것이다. 물론 fix되어 overwrite할 수 없는 signal handler도 존재(SIGKILL, SIGSTOP)하므로 참고하자.</p>\n<h1 id=\"sockets\" style=\"position:relative;\"><a href=\"#sockets\" aria-label=\"sockets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sockets</h1>\n<p>프로세스간 통신은 항상 같은 컴퓨터에서만 이루어지지는 않을 것이다. 우리가 자주 사용하는 <code class=\"language-text\">TCP/UDP</code> 통신은 외부 기기의 프로세스와의 통신을 가능하게 해준다. 또한, 같은 기기 내의 프로세스간에도 <code class=\"language-text\">Unix Sockets</code>을 통하여 소켓 통신을 할 수 있다.</p>\n<p>소켓 통신을 수행하기 위한 간단한 메커니즘은 다음과 같다.</p>\n<ul>\n<li>각 프로세스는 시스템콜을 통하여 소켓을 열고 통신할 프로세스와 연결한다.</li>\n<li>하나의 소켓을 통하여 프로세스들은 메시지를 read/write한다.</li>\n<li>네트워크 프로토콜에 따라 구체적인 통신 방법은 달라진다.</li>\n<li>OS는 데이터를 socket buffer를 통하여 전송하며, 프로세스는 해당 버퍼에서부터 데이터를 읽어올 것이다.</li>\n</ul>\n<h1 id=\"pipes\" style=\"position:relative;\"><a href=\"#pipes\" aria-label=\"pipes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pipes</h1>\n<p>pipe는 보통 프로세스간 반이중 통신, 즉 <code class=\"language-text\">half duplex</code>방식으로 데이터를 주고 받을 때 사용된다. (모든 프로세스가 송수신이 가능하지만, 한 파이프에서는 오직 송신 또는 수신만 가능하다. 무전기와 유사)</p>\n<p>pipe를 만드는 system call을 호출 시, 데이터를 공유하기 위한 file descriptor가 리턴되는데, 이를 통하여 데이터를 주고 받을 수 있고 보통 READ를 위한 file descriptor와 WRITE를 위한 file descriptor를 사용하여 반이중 통신에 사용된다.</p>\n<p>파이프는 크게 두가지로 사용될 수 있다.</p>\n<ul>\n<li>\n<p>부모와 자식 프로세스간 통신</p>\n<p>부모 프로세스는 fd를 만들고, fork하여 자식 프로세스와 이를 공유하여 통신하도록 한다.</p>\n</li>\n<li>\n<p>named pipes</p>\n<p>다른 프로세스에서 파이프를 공유하기 위해 named pipe를 사용할 수 있다.</p>\n</li>\n</ul>\n<p>pipe를 통한 통신 역시, socket과 유사하게 OS가 buffer를 통하여 데이터를 전송한다.</p>\n<h1 id=\"message-queues\" style=\"position:relative;\"><a href=\"#message-queues\" aria-label=\"message queues permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Message Queues</h1>\n<p>message queue는 mailbox를 이용한 indirect communication방식이라고 생각하면 편할 것 같다.</p>\n<p>Process는 특정 위치의 mailbox를 열고, 메시지를 전송받거나 전송할 수 있다. 이 방법 역시 OS가 메시지를 buffer하여 전송한다고 한다.</p>\n<h2 id=\"blocking-vs-non-blocking-communication\" style=\"position:relative;\"><a href=\"#blocking-vs-non-blocking-communication\" aria-label=\"blocking vs non blocking communication permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Blocking vs Non-Blocking Communication</h2>\n<p>IPC 메커니즘들은 해당 데이터 전송과정에서 blocking 여부를 결정할 수 있는 기능이 있다고 한다.</p>\n<p>예를 들어 메시지 큐가 가득차서 더 이상 데이터를 보낼 수 없을 때, writing process는 blocking되어 기다리거나, error와 함께 리턴하는 것을 고를 수 있다. reading process 역시 메시지가 없는 경우 기다리거나, non blocking으로 바로 리턴하거나를 선택할 수 있다고 한다.</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLDW872573QAb4bj0URobvQTD41IV6gRkx\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","excerpt":"저번까지 운영체제의 Scheduling에 대하여 알아보았다. 오늘은 프로세스간 통신에 대하여 알아보도록 하자. Inter Process Communication(IPC) 일반적으로 프로세스들은 독립적인 메모리 공간(memory space)를 갖고 있으므로, 메모리를 공유하지 않는다. 하지만, 프로세스간 communication이 필요한 경우가 많으며 서로 데이터를 공유할 상황도 생기므로, 이를 구현하기 위해 에 대하여 알 필요가 있다. Shared Memory 그 중 첫번째로 에 대하여 알아보자.  시스템 콜을 통하여 프로세스들은 같은 영역의 공유 메모리 자원에 접근할 수 있다. int shmget(key_t key, int size, int shmflg) 여러 프로세스에서 같은 key를 통하여 같은 shared memory영역에 접근할 수 있게 된다 해당 시스템 콜을 통하여 다수의 프로세스는 공유된 메모리 자원에 접근하여 read/write 연산을 수행할 수 있다. 하지만, 주의…","frontmatter":{"date":"October 28, 2023","title":"(OS) 운영체제 복습 [6. Inter Process Communication(IPC)]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(6)-IPC/"}},"next":{"id":"1c4f24f1-992b-5749-bee9-e2d91a87e79d","html":"<p>저번까지 Part1에 해당하는 Process와 CPU 가상화에 대하여 중점적으로 배웠다. OS는 process에게 독립성을 보장해주기 위하여 하나의 자원을 오롯이 제공하는 것처럼 느끼게 해주는데, 이번에는 그 중 메모리 자원에 대한 OS의 정책을 공부해보는 시간을 갖도록 하자.</p>\n<h1 id=\"why-virtual-memory\" style=\"position:relative;\"><a href=\"#why-virtual-memory\" aria-label=\"why virtual memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why Virtual Memory?</h1>\n<p>당연히 현대의 컴퓨터는 하나의 메모리에 한 프로세스만을 제공하지 않는다. 전체 메모리 공간을 여러 프로세스들이 적절히 나눠서 사용하고 있는데, 한정된 메모리 공간을 적절하게 분배해야하며, <strong>프로세스의 메모리 공간은 항상 연속적이지 않을 것이다</strong>. (왜냐면, 연속공간에 모든 프로세스들을 할당한다고 했을 때, 내부 단편화가 발생하여 메모리 공간을 효율적으로 사용하지 못할 수 있으므로)</p>\n<p>하지만 운영체제의 메모리 가상화 덕분에, <strong>개발자들은 파편화된 메모리 공간들을 관리하지 않고, 메모리를 연속되고 고정된 공간으로 간주</strong>할 수 있다!</p>\n<h1 id=\"abstraction--virtual-address-space\" style=\"position:relative;\"><a href=\"#abstraction--virtual-address-space\" aria-label=\"abstraction  virtual address space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Abstraction : (Virtual) Address Space</h1>\n<p>운영체제는 모든 프로세스에게 **<u>0에서 MAX에 해당하는 연속적인 주소를 제공하는 것처럼 가상화</u>**한다. (실제는 연속적인 물리 주소를 할당하는 것은 아니라는 말과 같다) 모든 프로세스들은 아래의 그림과 같은 address space를 제공받고, 프로그래머는 보통 그 위에서 생각한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACD0lEQVQ4y4WU56orMQyE9/2fKn9CAum9J6T33qsun2CWPZxyDcK7tjSekWQHy+XS2u22nU4nu1wudj6f7Xa7ud3vd7fr9WrH49HXGPpm3u12ttls7PF4+F7ABiAEYe/32waDgY3HY+t2u/7NPgHySaVSTqJer1utVrN8Pm+j0cg+n48FOPf7fTscDm6whLVssVg4E+1tt1urVqs2HA6d3Wq1cr/5fO6HBq/Xy+Vysmgzns+nB2jAHEAG/sgEZDKZ2Gw2C/2C/X7vp8EAJzFdr9dfmMMEpshCJiyZS6WSZbNZB3ZATiUY6eRhOp26cUgsFgtZkEvkdzodBymXy9Zqtfwf30Kh4DhBVCIsYAMTgJLJpB+ECtgTUKlUHFCFoXCNRsMymYz/B0hg0B4wUBtEjTUSz0z+UKBisEahmCESAlIQAWJiCjsB8v2/8Q2QIIJ7vZ5LIK+Aa08VJ+4n+xWQZDebzbADooC/gf0I+Jdk9aVi/pQcLQpJlqkoujF853I5bxn6FAWoIUW04Je2EQtYUclEIhGCqCgQILe0D+2CpdNp93fJemFwhgW9pmsVj8cdjDWuF2nAj0eBmwIwDIvFojc61zjAmUVuA2wA1wFIYo1DAWadb14Xbg4zTJHPNXRAioHhyAOhQQNzCKlQ0fQ46CFBKkwBYs8lo52kEkxhxBAH3kpmjAP0wGqwTky0yv8AgHpWlpvXaUsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtual_memory\"\n        title=\"virtual_memory\"\n        src=\"/static/5c2f1d30526470f7aa08ebf5f2cc62eb/37523/virtual_memory.png\"\n        srcset=\"/static/5c2f1d30526470f7aa08ebf5f2cc62eb/e9ff0/virtual_memory.png 180w,\n/static/5c2f1d30526470f7aa08ebf5f2cc62eb/f21e7/virtual_memory.png 360w,\n/static/5c2f1d30526470f7aa08ebf5f2cc62eb/37523/virtual_memory.png 720w,\n/static/5c2f1d30526470f7aa08ebf5f2cc62eb/c8e86/virtual_memory.png 758w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 사진은 프로세스에게 할당되는  <code class=\"language-text\">virtual address space</code>를 추상화한 그림이다. <code class=\"language-text\">code</code> 영역에는 static한 데이터와 instruction이 존재하며 컴파일 단계에서 고정된다. <code class=\"language-text\">heap</code>영역과 <code class=\"language-text\">stack</code>영역은 각각 런타임 환경에서 추가되는 동적 변수와 지역 변수, 함수 등이 들어갈 것이다.</p>\n<h3 id=\"memory-allocation-system-calls\" style=\"position:relative;\"><a href=\"#memory-allocation-system-calls\" aria-label=\"memory allocation system calls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory allocation system calls</h3>\n<ul>\n<li><code class=\"language-text\">malloc</code> : heap 영역의 free space에 공간 할당 (힙은 스택과 다르게 순서대로 쌓이는 구조가 아님). 성공시 공간에 대한 포인터를 리턴하고, 반대의 역할을 수행하는 <code class=\"language-text\">free</code>가 있다. 하지만 <u>malloc은 시스템콜은 아니고, c library에서 제공하는 아래의 시스템 콜 기반의 함수</u>이다.</li>\n<li><code class=\"language-text\">brk/sbrk</code> : heap 영역을 늘리기 위해 c library에서 호출</li>\n<li><code class=\"language-text\">mmap</code> : page size의 메모리를 할당하기 위한 시스템 콜 -> OS에서 익명의 빈 페이지를 할당 받을 수 있음</li>\n</ul>\n<p>0KB부터 존재하는 주소 체계는 OS에 의하여 추상화된 메모리 구조이고, 실제 메모리의 물리적인 구조는 조각들로 나뉘어 곳곳에 위치한다. 이러한 것을 메모리 가상화(<code class=\"language-text\">memory virtualization</code>)라고 한다.</p>\n<p>실제로는 가상 주소(virtual address, VA)는 실제 물리 주소(physical address, PA)로 변환되는데, 이는 Memory Managemnet Unit(MMU)에서 주관한다. 따라서, <strong>CPU에서 특정 VA(ex. 100)에 접근하려고 하면 이는 MMU에 의하여 PA(ex. 1001)로 변환되어 실제 메모리 공간을 가리키게 된다</strong>.</p>\n<h1 id=\"paging\" style=\"position:relative;\"><a href=\"#paging\" aria-label=\"paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Paging</h1>\n<p>실제 메모리 공간은 연속적인 공간에 존재하지 않는다고 했다. 보통 <code class=\"language-text\">Page Frame</code>이라는 단위로 존재하고, 할당된 가상 주소를 <code class=\"language-text\">page</code> 나누어 Page와 Page Frame이 매칭되는 형식을 보인다. 모든 물리 주소 공간이 연속적이라면, 내부 단편화가 심해질 수 있고, 모두 산발적으로 존재한다면 주소를 매핑하는 과정에서 많은 overhead가 발생하므로, 적절한 단위인 Page로 나누어서 이를 관리하는 것이다.</p>\n<p>Page(VA)와 PageFrame(PA)는 서로 매핑되는데, 이러한 정보는 <code class=\"language-text\">MMU</code>의 <code class=\"language-text\">Page Table</code>에 존재한다. 이는 다음에 자세히 다루도록 하자.</p>\n<h1 id=\"memory-virtualization의-목표\" style=\"position:relative;\"><a href=\"#memory-virtualization%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"memory virtualization의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory Virtualization의 목표</h1>\n<p>메모리 가상화의 목표를 상기시키고, 이를 구현하는 구체적인 방법에 대하여 알아보자.</p>\n<ul>\n<li>\n<p><strong>Transparency</strong></p>\n<p>user program은 실제 메모리 공간의 복잡한 것들(곳곳에 흩어져 있는 실제 메모리 공간에 대한 정보와 그 매핑 정보들)을 알 필요가 없다.</p>\n<p>우리가 C 프로그래밍을 하면서 메모리 주소를 찍어본 경험이 있을텐데, 이는 모두 가상주소(VA)이다!!</p>\n</li>\n<li>\n<p><strong>Efficiency</strong></p>\n<p>실제 메모리 공간에 접근하기 위해 발생하는 overhead는 최소화 되어야 할 것이다.</p>\n</li>\n<li>\n<p><strong>Isolation and Protection</strong></p>\n<p>각 process는 독립적인 address space를 보장받아야 하며, 이 공간을 벗어나서는 안된다. (우리가 자주 접하는 <code class=\"language-text\">segmentation fault</code>가 이와 관련있음)</p>\n</li>\n</ul>\n<h2 id=\"-운영체제의-address-space\" style=\"position:relative;\"><a href=\"#-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-address-space\" aria-label=\" 운영체제의 address space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 운영체제의 address space??</h2>\n<p>프로세스들은 고유의 가상화된 address space를 제공받는다. 하지만, system call, interrupt 등으로 인하여 OS의 코드가 실행되어야하는 경우는 어떻게 실행할 수 있을까? OS 역시 프로세스지만, 모든 프로세스의 실행 중에 개입이 가능하다. 이는 프로세스의 address space에 OS 코드와 매핑이 되는 공간이 있기 때문이라고 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 95.55555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAADTUlEQVQ4y41U/W/aSBD1/y9F+Quq3k8JSS9OmuTUXlsTATkCaQLGBEIwtgGbtQ3+gAQTcof9TjN8nE5qpa602vV65s17M7Mr2baNKIqxWCxgD22I0Qij0YhXWwiMTRNIEmQAkGXIMt79dEhJkmC1WjHIH5eXODw8xvHx7zjOHeHD+QVqp6fILIuNszTldTqdYjKZ7GYQBIiiCPP5HJLj2CCWNAuFAr58+Qrlm4JvtJauoX38iLRUwpbXbDaDaVkQQkDTmuj3+3h8fIQ/HiMMQ0ivr6+gSQbEcjweQ1UbME0Lk2mMQa2GvxWF5aZZxs5kt1wuEUUhbMdmZi8vL2vAIJjAME30BwO4rgtd16Fp2trRcdAXAst8nnTCdl34nsfyiARJJbt5kjAoAy4WCeeEmJH8arWKYrGEv8pldLtdeEGAf9ptvNXr6BgGyzYMA71ej9dKpcKyydb3fUhxHGI4HLLk5+dn3ut6lx0oyDiKkPo+RicnmM5mDGgPh+xMPnd3d8yU9lQgKY5j/knTcRzc39/j9vaWmT49PSEIQ4STCZyTE6oIF2e4SQ/l8ubmZqPOWQNSPjzfZ2amacKyLDQaDZYwGAz4rNXp4PX7d6DfZ4Zk63ked8bDw8OODAOGYQDX9diZDChqs9nk4lCSi4UC6s0mEMdIK5UdIBWHg2saRkL8J5nKzSw31VNVlQtCsimAKwTeVitgPkdGLGczDIWA57oMQikiyUSEAX1/zY4od3WdI2pNDQ2tAb3b5QAPxJBGvY7McfhKEgECocAEtANMNj002t5hjlpjcIpMuSTgnmliqetAu40BpYaAbZvbhsApDWQvua5AzzC4ualJO50O57DdbnOV6YzGfLmEXq0ivrpCv9XCgJreslBXVVZH+eQ+fHtbctfT4XZWq7fodJ44MlWZrhmPNIX49Am+qm4eiRi9noE0TfkVohaUPN/bNbHYVMvzXO4zscnV1oGfLtvGlSwjl8vhVJZxdnYGWZZxcHCAVqsFCb84GJA2QkCRZeSLReQOD7G/v4/z83MoisL9K20j/9Jcv1/48907XH7+jN/ev8fe3h6Ojo5wcXGBWq32f8Atkx/QY7Dtv1apBCWfx/X1NcrlMkr0rSjcfv8CNCRuDqvvZ58AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"address space\"\n        title=\"address space\"\n        src=\"/static/e0509d4937ae3e16bbb89fd080bcc257/37523/os_address_space.png\"\n        srcset=\"/static/e0509d4937ae3e16bbb89fd080bcc257/e9ff0/os_address_space.png 180w,\n/static/e0509d4937ae3e16bbb89fd080bcc257/f21e7/os_address_space.png 360w,\n/static/e0509d4937ae3e16bbb89fd080bcc257/37523/os_address_space.png 720w,\n/static/e0509d4937ae3e16bbb89fd080bcc257/f4281/os_address_space.png 1016w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>OS 코드도 역시 메모리의 특정 Page들에 존재한다. 다른 프로세스들 역시 고유의 address space를 갖는데, <strong>유일한 OS의 address space에 접근하기 위해 각 프로세스마다 OS의 주소를 매핑하는 공간을 갖고 있다</strong>고 보면 될 것 같다. 이를 통해 프로세스 실행 중에 OS가 개입할 수 있고, 시스템 콜을 호출할 수 있게 되는 것이다.</p>\n<p>다음에는 본격적으로 address space를 관리하는 방법에 대하여 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"October 28, 2023","title":"(OS) 운영체제 복습 [7. Introduction to Virtual Memory]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(7)-Introduction to Virtual Memory/"}},"prev":{"id":"dbf838fa-a84b-5baa-8fd9-b484a510bf52","html":"<p>MMU에서 Virtual Address에서 Physical Address로 변환되는 메커니즘을 간단한 함수의 실행과 함께 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span>\n\tx <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 함수가 실행되는 프로세스를 생각하면 OS는 아래와 같은 address space를 제공할 것이다. (프로세스마다 기본적으로 16KB만큼을 할당해준다고 가정하자)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 296.6666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAA7CAYAAAB7c6ruAAAACXBIWXMAABYlAAAWJQFJUiTwAAADwUlEQVRYw9WY107rQBCG8/4vA5FAcAGIqoQuWoDQe++9ztE3R7+12diJUy7OWWlke8u/U3dnXNjf37fd3V0rlUrG+/v7u93e3trj46Pd3Nw4XV9f2/39vRNjd3d39vT0lPRBzPv8/LTC2dmZnZ+f28rKis3Pz9v09LRtb2/b2tqabWxseN/i4qLNzc3ZwsKCXV1dJfOen5/t9/fXaGzw+vpqBQvaxcWFTU5O2t7ens3OzjooQHC+vr7ufQDSvr+/w6X28vLyF/Dj48MgxICzqakp29zctKWlJX/OzMw48NHRkU1MTLgkcL6zs2Nvb2/1gOgHHfb19TnI6emp64l+RLq8vLSTkxNfQB9jx8fHhqrQWR0gOvj5+XEuaRgjFIcx2tfXl/eLK/r5lg7ZvE6HNEQPARFbhuJ9aGjIDg4OXBVwqcZGDoiITMBt6MQFAGVHLIcRWIjBEB+iD8/gyRzEZZw1BfRzeHjoXAjw4eEh2RG/bESA8US/vKeKLL210hKRsRQEOg0OZT0ULtIiGSUeS4yytbXlvlUsFl0fUAgYWnp1ddXnpgEmbiMd4F8sbMQh85py2HUdYmVchwMA59bpAefsGpJUEvcBhDu521SrVQ+9sbExH4BDNmECvgXhc7gSrjUyMuLRJN+UP3KgAF4nss4/AMQtm8A9UoyPj7uO0bnGtIFzKMVKb0xkR02G2IRYHhwctJ6eHn9nU8aYz+ZIVQMoa7E4BoTQqdyGhTq5IQCxgwNK1CzA8OiXEUKwlgBjLgGKwaTDhoC6lOKFWdSQQ53WeQA1p8Yo7QKG4w0B84gcjzUFTHObLLA6P0wTOQswra8pYBaHWRwLMLdjNwJrO1I68sOsSFGUpEVLy5HCOzEMJzwB4L2tSOHJWcdJQxbGkwwCAIHmjhQlnpzo5XLZU7rR0VHPE0lNGGvbD1kESdxY5LYjpWuO3SxSWnLs/z9Scjt2XsN07U4Jr4CO75RQgo7vlFgdHV8B8Sn070RKHMMdRQqLOMZ0bOmQrQPMk32pFu7v77fe3t7UdK6GwxCQCQDExxQJJ3Uyma4STiWlnOJJwhkXiYDFKTGTWUwtPTAwkABovCYlZlfybIrC5eVl54zaWPkzxGI24OSmruFdfwLCMQdULNKpiyiu1lsqK5qVt6F+w5ZZ+FQqFZefi4cSl1wa9qmHsZwaRmEepQWGiDer+UUAUTNzTcqqKJoJalgWg6Fb9acCdqs0SwBVMsCR/IoiUf8UeIr4Tuur+W/DnxBqj+HhYf8vwwT9/chLUhF6/gOys5fZzublKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VA\"\n        title=\"VA\"\n        src=\"/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png\"\n        srcset=\"/static/23122becc17c9e94b52ff2a3983884a3/e9ff0/VA.png 180w,\n/static/23122becc17c9e94b52ff2a3983884a3/f21e7/VA.png 360w,\n/static/23122becc17c9e94b52ff2a3983884a3/8574c/VA.png 436w\"\n        sizes=\"(max-width: 436px) 100vw, 436px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>x 변수는 stack영역에 저장되고, 컴파일된 명령어는 code 영역에 존재할 것이다. 이 과정에서 Address Translation이 어떤 식으로 이루어질지 생각해보자.</p>\n<h1 id=\"dynamic-relocation\" style=\"position:relative;\"><a href=\"#dynamic-relocation\" aria-label=\"dynamic relocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Relocation</h1>\n<p>이러한 주소의 배치는 프로세스 실행 이후에 address space가 변경될 수 있으니, dynamic relocation(동적 재배치)라고 불린다.</p>\n<h2 id=\"base-and-bound-하드웨어-기반\" style=\"position:relative;\"><a href=\"#base-and-bound-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B8%B0%EB%B0%98\" aria-label=\"base and bound 하드웨어 기반 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>base and bound (하드웨어 기반)</h2>\n<p>가장 단순한 방법으로는 위의 <strong>프로세스의 메모리 공간을 그대로 연속적인 하나의 물리적 공간에 매핑시키는 방법</strong>이 있을 것이다. 16KB가 연속적으로 남는 공간을 찾아서 그곳에 프로세스의 공간을 할당하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 143.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAADM0lEQVRIx42V505qURCFef9n8B8J0WDAoCRKIKBiw9ARFRsWilJERbHh3HxzM+QcDhpOsrMLe69Zs6bge3t7k1arJf1+X+z7/v6Wr6+vucbPz4++sdnXbDYlHo9LoVDQg+FwKNvb23JwcCD7+/u/Dn7n3vn5ub4bj8f/AY2VWXh6epKdnR2pVqtSLBalVCpNRrlcdq2z2awcHx+7AQGyYYC7u7tSqVTk5ORETk9P9REzIKw5r9VqksvldD0XYCQSEb/fL8vLyxIIBCQYDEooFJLFxUVZWlrSPfcA9gCyIRBOQDRC21QqJZubmxKLxVSzRCIhyWRStra2JJPJKPOZGtoHIKJjmcs22JsEtieQHpefn5/1kEA8Pj7K6+urssD6PFEmeC5AALB4eHgog8FAAblIJPP5vLJgtrUNMgCjnijPcpncYibZYY0h1ra3cX9/L1dXV+7Eng4KEmC12+0KSX99fa3j9vZWGo3GZH54eND15eWlG3A6sU1T2PCA6BJtJEmn07KysqIu8/vd3d0EEFJgTPLQNDDAXq8n7XZb3YINs+2pfc6cgPbN1BBAXDaATqejgzOnAafLaIo0Pn4kcdfW1hRgNBppROv1ulxcXOgDNCXqRJY95wQDw5aHvCWdfACwQWjWtDMeoRHGiDBVsbCwoGXIXZgaW1jxjrsQ8bhM+4IdQOiIKxhYX19XBpxZClmkPz4+VFfy2RMUEhuweT8YAwjTs7Mzb7eBoZUW7YlqsGqhfik1ZnSkicD+8/NTc5a7M10mHWD68vKibEl6XOfh+/u7DrTGfbSHITO5qgz5bwCANbMBkkLMlOLe3p5GFAOck6+s0RBw0oos0LSJRqMSDodVWCIGdR4fHR3pTP+jsa6urmonJ40slZjRH2B1GXegzLBKQSOsYxWDRBRWdkbK4C4ELLGZ0ffPSiHPAOMxwJyhpRlyVgrEYOqJ8nRzoPGiH/oQbdyHCUactexqX781ByJnzRQZ+NdDJ/INtk6Gk24z7bJpaK6ZdtZorfECiIaeBkveYQkQwk/ukcQ3NzeTRsA8PShPPIGt6y+ADEejjY0NLSM+wNDnr4Ec3LMyNYb/ACBSX4dpGsZ3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseandbound\"\n        title=\"baseandbound\"\n        src=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png\"\n        srcset=\"/static/bb7e3b3b050a9bacd049e799dbb0b764/e9ff0/baseandbound.png 180w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/f21e7/baseandbound.png 360w,\n/static/bb7e3b3b050a9bacd049e799dbb0b764/7f664/baseandbound.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 경우, 두개의 레지스터 값만 유지한다면 간단하게 VA와 PA간 변환이 가능하다. 해당 프로세스는 32KB에서 시작하고, address space의 크기는 16KB이므로, <code class=\"language-text\">base</code> 레지스터에 32KB, <code class=\"language-text\">bound</code> 레지스터에 16KB의 값을 갖고 있도록 하자. <u>각각 시작주소와 프로세스 주소 공간의 크기를 의미</u>한다.</p>\n<p>그렇다면 <code class=\"language-text\">MMU</code>(Memory Management Unit)에서  <code class=\"language-text\">PA = base + VA</code>로 변환해줄 수 있을 것이다. 만약 VA가 bound인 16KB보다 크거나 0보다 작다면 에러가 발생하도록 하면 된다.</p>\n<h3 id=\"role-of-hardware-in-translation\" style=\"position:relative;\"><a href=\"#role-of-hardware-in-translation\" aria-label=\"role of hardware in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of hardware in translation</h3>\n<p>주소 변환에서 하드웨어의 역할이 무엇인지 정리해보자.</p>\n<ul>\n<li>CPU는 <code class=\"language-text\">privileged mode</code> (<code class=\"language-text\">kernel mode</code>)를 제공해야 운영체제가 접근권한을 갖도록 할 수 있다.</li>\n<li>하드웨어는 base &#x26; bound 레지스터를 제공하며, CPU당 한쌍이 필요하다. 이를 통해 <strong>주소 변환과 범위 검사를 수행</strong>하며 <strong>오류 발생시에는 예외를 발생</strong>시킨다. 또한 <strong>레지스터 값을 변경하는 특권 명령어를 제공</strong>해야한다. 프로세스마다 각 레지스터 값들은 다르므로, 변경이 필요하며 이는 특권 모드에서 일어나야하기 때문이다.</li>\n</ul>\n<h3 id=\"role-of-os-in-translation\" style=\"position:relative;\"><a href=\"#role-of-os-in-translation\" aria-label=\"role of os in translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>role of OS in translation</h3>\n<p>그렇다면 운영체제에서 <code class=\"language-text\">dynamic relocation</code>을 지원하기 위해 해줘야 할 일은 뭐가 있을지 알아보자.</p>\n<ul>\n<li>프로세스가 실행될 수 있는 유휴 메모리 공간인 <code class=\"language-text\">free list</code>를 관리한다. 위의 예시에서는 16<del>32KB, 48</del>64KB 영역이 free list에 있을 것이다.</li>\n<li>프로세스가 시작할 때 메모리 공간을 할당해주고, 종료할 때 이를 정리해준다.</li>\n<li>context switching 발생시, <code class=\"language-text\">PCB</code>에 실행중인 CPU의 <code class=\"language-text\">base</code>와 <code class=\"language-text\">bound</code> 레지스터 값을 저장해주거나 이전 레지스터 값을 복원해줘야 한다.</li>\n<li>하드웨어 예외 발생시, error handler를 통하여 조치를 취해야 한다. 보통 OS는 해당 프로세스를 종료함으로써 자원을 보호한다.</li>\n</ul>\n<h2 id=\"segmentation\" style=\"position:relative;\"><a href=\"#segmentation\" aria-label=\"segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segmentation</h2>\n<p>base and bound 방법은 비교적 간단하지만 내부 단편화(<code class=\"language-text\">internal fragment</code>)가 발생할 수 있다는 단점이 있다. 위의 그림들을 보면 프로세스에게 할당이 되었지만 사용중이지 않은 heap ~ stack 사이의 빈 영역이 존재하는데, base and bound 방법은 이러한 내부 단편화가 일어날 수 밖에 없는 구조이다. 고정 크기를 각각의 프로세스에 할당하므로 <strong>한 메모리에서 실제 사용하는 용량에 비해 실행시킬 수 있는 프로세스의 수는 적을 것</strong>이다.</p>\n<p>예를 들어, 32bit 주소 공간을 갖는 체계에서 하나의 프로세스는 무려 2^32byte = 4GB의 공간이 필요하게 된다… 하지만 실질적으로 프로세스에서 필요한 메모리의 크기는 MB단위일 것인데, 불필요한 부분들이 너무 많아 지게 된다.</p>\n<p>따라서 address space를 보통 <strong>heap, stack, code segment로 나누고, 이렇게 생긴 여러개의 (base, bound)를 MMU에 각각 두어 일반화</strong>한 방식인 <code class=\"language-text\">segmentation</code>이 제안된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVQ4y52U2W/aQBCH/Z9XfWikSonI2b72oXlppVZV1CoVRwI0AQJJzH0Ggy/A2AYCGDDHr5oFEwdVSuhIox0f++3M7MxwuiZAEhKQa/eQa3dMpdodVIlHNsNDFCXY9gTtdhuGYTAlW9d19Pv99TPZnU4HXD75C9HAe8SD+7i59DCNBz2IBvbQUEog6Xa7yOVyyOfzKJfLqFQqKBQKGI1G0DQN6XQalmWxQ7hyzoew14PrwAmuA8eIXJzgyn+M6MUxTENaAwkiiiKD0OrYqqqiVqthMpmg1WqBK2V9CP7eQ9h75NJDRAJHMHVxCex0GFCWZQwGAwYgHY/HDFiv15+AhfQ5Yhe7SIQOEQ8eME2EDhC73EdTrWCxWHpYLBYZhEKjVRCENZBs27ZZ+JwqlyEKt5DrPBQxyVSiC6rzeKgUWd5M02SrJElrYLVaZV65gc1mE5xtT1lY8xkwHtsYj2w4MpksbQqTAI1GA4+Pjyx/BKGbJSAdRN7SwVyjrUM2TIiajlxVQFlSIOsmpLaOXn+wPGw+Z+twOEQqlUKpVGJAnueRzWZZ7qbTKWazGbirwgM+R5L4Gs/gkzeM03AcXxJZnEZ4NMwuAy0okSshuPPsth3hur0e+pYFtaVBlBWmbbODgWWhpWksL46H7s2btqPct5sUdn6G8NEfxaE3gt3zP/jgj7J3iVwRiiSyUDY3bqrznfueyODNWQgeXww7P/x4d3aJXV8Mb8+CEDRjGZpr00vCVZQmbmsK7usKQnwGkWwR93UVd4IEo9t7Ft5roNzYsp4SPp0Czqb5HFPbfhbqqzwcroDu3xerMGmK0KVs5aG1AlIdUeWTOrdKBUzT5V+3/CKQirbX67G+pTYiCB2ydciWK4duoVKhb+7i3crDzZ//20NqcIJSc9NKQ5NsyiX1ayaT2S6H9BPNumQyycY6NTuNdBrnlEvK6TYh/wVtti9w5MDjCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"segmentation\"\n        title=\"segmentation\"\n        src=\"/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png\"\n        srcset=\"/static/99d8bbe29d2c10911c0c29ed5429333e/e9ff0/segmentation.png 180w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/f21e7/segmentation.png 360w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/37523/segmentation.png 720w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/302a4/segmentation.png 1080w,\n/static/99d8bbe29d2c10911c0c29ed5429333e/525d3/segmentation.png 1090w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리 공간을 코드, 힙, 스택의 3개의 segment로 분할하고, 각각 base, bound, 순방향 증가 여부(<u>스택의 경우, 역방향으로 증가하므로</u>)를 기록하여 segmentation을 간단하게 구현할 수 있다. 순방향 증가 여부의 경우, translation 과정에서 stack영역은 반대 방향이므로 다르게 계산해줄 필요가 있으므로 알 필요가 있다.</p>\n<h2 id=\"문제점\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제점</h2>\n<p>하지만 이 방법은 내부 단편화는 줄일 수 있어도, 각 segment 사이의 작은 빈 공간이 많이 존재하게 되는 외부 단편화 (<code class=\"language-text\">external fragment</code>)가 발생할 수 있다는 단점이 존재한다. 이를 해결하기 위해 물리 메모리를 한 곳으로 몰아서 압축하는 방법이 제안되기도 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFklEQVQ4y22UV4uyMRCF/f+/QfBKEKzghcJe2MCCdS14Ifburr3XWZ5ZRvaDLxCSTE7OnDnJ+zqez6dcLhdhtDaZTGQwGMjxeHzH2L9er//g5vO59Ho92W6375gDEATr9VpqtZp8fn5KOp2WXC4nxWJRyuWytNtteTweb1yj0ZBKpSKZTEZxpVJJz9Xr9V9CQKvVSmKxmESjUfH5fOJ0OiUUCkkkElFilIEBm0wmFRcIBMTlconX65WPjw9JJBK/hAaMx+MK8vv94na7lRhS1EC4XC61vFQqJcFgUPfBeTweCYfDGnfgH15Mp1OVns/ntRcKBVWWzWal2WxqyYvFQnFYgxUkolQ6a0bH7XaTzWajKhnpo9FIfcIzFLEHoeFer5f8ryHOcTqdZDabydfXlxwOB71ZlEAKGbHdbqc3TCXsQU7jLAkQRePs20P8YQ6YBNwsAMA2gvv+/n4TWjWcswTqIWQAUYmKbrcr1WpV+v2+xuj3+/2N+/sW/zYlJLuVzCHArDudjgJQw3g+nzVOyVhAxxI68/1+r8lUIdJ5NraBEhLYQfbt8uzNMrKG0OIkc2A6PrCwDdY8FZ6IxVA4Ho9Vpb0G7BkOh3oWYiVEoV0KqghyCFIIWVOKXQo4U0eCVqulI5Uood0yHQ9pEPNzsJ8BHkII0V9CVGGRla2EBPhjsIDAvm1IIaICymUOzmwwESSwOZfyA811WsxGLfJSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compact\"\n        title=\"compact\"\n        src=\"/static/3491ec2ae9efa9381131014955213c91/37523/compact.png\"\n        srcset=\"/static/3491ec2ae9efa9381131014955213c91/e9ff0/compact.png 180w,\n/static/3491ec2ae9efa9381131014955213c91/f21e7/compact.png 360w,\n/static/3491ec2ae9efa9381131014955213c91/37523/compact.png 720w,\n/static/3491ec2ae9efa9381131014955213c91/84ee5/compact.png 1076w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 파편화된 외부 미사용 공간들을 압축하는 방법은 overhead가 큰 연산이므로 비용이 많이 든다. 이에 운영체제는 (미사용) 공간을 관리하는 알고리즘을 이용할 수 있는데, <code class=\"language-text\">best-fit</code>, <code class=\"language-text\">worst-fit</code>, <code class=\"language-text\">first-fit</code>, <code class=\"language-text\">buddy algorithm</code>등이 존재하며 압축을 최소화하면서 상황에 맞게 최선의 방법을 선택할 수 있을 것이다.</p>\n<p>또한 segmentation은 유연하지 못하다는 단점이 있다. 힙, 스택, 코드의 3 영역으로 나눈다고 해도 각각은 모두 연속적으로 존재해야하므로 유연성이 떨어진다. 이에 <code class=\"language-text\">Fine-grained</code> 와 <code class=\"language-text\">Coarse-grained</code> segmentation이 제안되는데, 조각이 많아진다면 유연성은 증가하지만 레지스터값들이 그만큼 늘어나므로 관리가 어려워질 수 있다.</p>\n<p>다음에는 이에 해결책이 될 수 있는 <code class=\"language-text\">Paging</code> 기법에 대하여 알아보도록 하자.</p>\n<p><a href=\"https://www.youtube.com/watch?v=8ad4DzlZwgI&#x26;list=PLDW872573QAb4bj0URobvQTD41IV6gRkx&#x26;index=3\">참고 강의</a></p>\n<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">참고 책</a></p>","frontmatter":{"date":"October 29, 2023","title":"(OS) 운영체제 복습 [8. Mechanism of Address Translation]","categories":"OS","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/OS(8)-Mechanism of Address Translation/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/OS(6)-IPC/","nextSlug":"/OS(7)-Introduction to Virtual Memory/","prevSlug":"/OS(8)-Mechanism of Address Translation/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}