{"componentChunkName":"component---src-templates-blog-template-js","path":"/Alg-LC-230/","result":{"data":{"cur":{"id":"77f7754e-455a-5da3-8f07-a2054063c837","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Binary Search Tree(BST)에서 k번째로 작은 원소를 찾는 문제이다. <a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\">링크</a></p>\n<p>각각의 노드는 다른 값을 갖고, 가장 작은 원소는 1번째로 작다고 한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>BST를 직접 그려보고, 정렬된 값을 추출하는 과정을 생각해보면 몇가지 특징이 존재한다.</p>\n<p>한 노드를 루트로 하는 서브트리에서 가장 큰 값은, 가장 오른쪽에 있고 가장 작은 값은 왼쪽에 있다.</p>\n<p>왼쪽 자식의 어떠한 값도 자기자신보다는 작고, 오른쪽 자식의 어떠한 값도 자기 자신보다는 크다!</p>\n<p>따라서, <code class=\"language-text\">왼쪽 서브트리 -> 부모 -> 오른쪽 서브트리</code>의 순서로 순회하는 <code class=\"language-text\">inorder</code> traverse를 수행하면 BST는 정렬된 순서로 나오게 될 것이다!</p>\n<p>이는 재귀적으로 해결하거나, stack을 이용한 while문으로도 해결할 수 있으나 후자의 방법이 더 좋다. (단순히 출력하는 거라면 상관없지만, 갯수를 세서 중간에 리턴해야하는데, 재귀는 이것이 어렵다)</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>각 노드를 한번씩 탐색하므로 O(n)정도 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>stack에 노드를 넣고 빼므로 트리가 커질수록 스택의 크기가 커질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>첫번째 코드는 재귀를 이용하여 inorder를 구현하는 방법이다.</p>\n<p>sortedList에서 가장 작은 값부터 append하면서, 크기가 k가 되면 재귀를 종료하는 형식이다. 이는 함수의 인자로 sortedList를 갖고 다녀야 한다는 점에서 공간복잡도가 높다고 볼 수 있다. 그리고, 재귀함수는 일반적으로 반복문보다는 느리고 stack overflow가 날 가능성이 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">kthSmallest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        왼쪽 서브트리 -> 부모 -> 오른쪽 서브트리로 순회\n        \"\"\"</span>\n        sortedList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        self<span class=\"token punctuation\">.</span>traverse<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> sortedList<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>sortedList<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> sortedList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        cnt==k가 될때까지 L-N-R 순회\n        \"\"\"</span>\n        <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>traverse<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> sortedList<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># print(f'{node.val} visited!')</span>\n        sortedList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>sortedList<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> k<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> \n        <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>traverse<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> sortedList<span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>두번째 코드는 while문과 stack을 이용하여 inorder를 구현하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">kthSmallest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        왼쪽 서브트리 -> 부모 -> 오른쪽 서브트리로 순회 -> stack &amp; while 문 이용\n        왼쪽으로 가면서 stack에 넣기\n        \"\"\"</span>\n        stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        current <span class=\"token operator\">=</span> root\n        cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 왼쪽 있다면 넣고</span>\n            <span class=\"token keyword\">if</span> current <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span>\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>left\n            <span class=\"token comment\"># 왼쪽 없다면 그거 오른쪽 탐색하면서 cnt += 1</span>\n            <span class=\"token keyword\">elif</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                current <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token comment\"># print(current.val)</span>\n                cnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token keyword\">if</span> cnt <span class=\"token operator\">==</span> k<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> current<span class=\"token punctuation\">.</span>val\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>right\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span>\n</code></pre></div>\n<p>한 while문에서, current의 값을 기준으로 stack의 값을 처리하는데, 다음과 같다.</p>\n<ul>\n<li>current가 None이 아니라면, <strong>current를 stack에 넣고 왼쪽 자식을 current로 업데이트</strong> 한다. (자식 없으면 current None이 될 것)</li>\n<li>current가 None이라면(왼쪽 자식이 더 이상 없다면), <strong>stack에서 값을 하나 빼서 탐색</strong>한다. 이는 현재 가능한 가장 왼쪽 leaf일 것이다. 그리고, 해당 <strong>leaf의 부모의 오른쪽 자식들이 있다면 current로 업데이트</strong> 한다.</li>\n</ul>\n<p>트리를 \\ 방향으로 순회하기 위하여 하나의 stack을 이용할 수 있는데, current 값을 기준으로 왼쪽이나 오른쪽을 추가하고, 탐색하는 과정이 약간 어려울 수 있으나 알고 있도록 하자.</p>","excerpt":"Intuition Binary Search Tree(BST)에서 k번째로 작은 원소를 찾는 문제이다. 링크 각각의 노드는 다른 값을 갖고, 가장 작은 원소는 1번째로 작다고 한다. Approach BST를 직접 그려보고, 정렬된 값을 추출하는 과정을 생각해보면 몇가지 특징이 존재한다. 한 노드를 루트로 하는 서브트리에서 가장 큰 값은, 가장 오른쪽에 있고 가장 작은 값은 왼쪽에 있다. 왼쪽 자식의 어떠한 값도 자기자신보다는 작고, 오른쪽 자식의 어떠한 값도 자기 자신보다는 크다! 따라서, 의 순서로 순회하는  traverse를 수행하면 BST는 정렬된 순서로 나오게 될 것이다! 이는 재귀적으로 해결하거나, stack을 이용한 while문으로도 해결할 수 있으나 후자의 방법이 더 좋다. (단순히 출력하는 거라면 상관없지만, 갯수를 세서 중간에 리턴해야하는데, 재귀는 이것이 어렵다) Complexity Time complexity: O(n) 각 노드를 한번씩 탐색하므로 O(n)정도 걸…","frontmatter":{"date":"September 07, 2023","title":"(Alg) LeetCode Top Interview 150 - 230. Kth Smallest Element in a BST","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-230/"}},"next":{"id":"8614b553-d529-54be-9f6b-3531b1d8847d","html":"<ol start=\"199\">\n<li></li>\n</ol>\n<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Binary Tree에서 각 레벨 별로, 가장 오른쪽의 원소를 출력하는 문제이다. <a href=\"https://leetcode.com/problems/binary-tree-right-side-view/\">링크</a></p>\n<p>문제에서는 오른쪽에 서서 봤을 때, 제일 앞에 보이는 노드를 출력하라고 하였다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>단순하게 depth를 추가한 BFS로 문제를 해결할 수 있다. 각 depth마다 값을 저장하면서, BFS로 왼쪽부터 값을 탐색한다면 가장 오른쪽 값이 마지막에 저장될 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>각 노드를 한번씩 탐색하므로 O(n)정도 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>stack에 노드를 넣고 빼므로 트리가 커질수록 스택의 크기가 커질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>BFS는 FIFO를 이용해야하므로, python deque를 이용하였다. result 배열을 만들어서 값을 넣는데, 단순하게 값이 없다면 새로 만들어주고 아니라면 덮어씌우는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">rightSideView</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        BFS 탐색하면서 오른쪽 노드만 넣는다\n        만약 오른쪽 없고 왼쪽만 있는 경우도 고려해야할듯\n        \"\"\"</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> root <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># (node, depth)</span>\n        result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            current<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># print(current.val, depth)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">>=</span> depth<span class=\"token punctuation\">:</span>\n                result<span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>val <span class=\"token comment\"># 제일 오른쪽이 마지막에 덮어씌워질것임</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        \n        <span class=\"token keyword\">return</span> result</code></pre></div>\n<hr>\n<ol start=\"637\">\n<li></li>\n</ol>\n<h1 id=\"intuition-1\" style=\"position:relative;\"><a href=\"#intuition-1\" aria-label=\"intuition 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Binary Tree에서 각 레벨 별로 원소의 값의 평균을 구하는 문제이다. <a href=\"https://leetcode.com/problems/average-of-levels-in-binary-tree/\">링크</a></p>\n<p>위의 문제와 유사하다. 이번에는 덮어씌우지 않고, 누적해가며 갯수를 세어 평균을 구할 수 있도록 해보자.</p>\n<h1 id=\"approach-1\" style=\"position:relative;\"><a href=\"#approach-1\" aria-label=\"approach 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>depth를 추가한 BFS에서, 각 레벨 별 값들의 누적합을 기록하는 배열 sum_list와, 갯수를 기록하는 cnt_list를 두어 마지막에 레벨별 평균을 구할 수 있다.</p>\n<h1 id=\"complexity-1\" style=\"position:relative;\"><a href=\"#complexity-1\" aria-label=\"complexity 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>각 노드를 한번씩 탐색하므로 O(n)정도 걸릴 것이다.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>stack에 노드를 넣고 빼므로 트리가 커질수록 스택의 크기가 커질 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code-1\" style=\"position:relative;\"><a href=\"#code-1\" aria-label=\"code 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">averageOfLevels</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># (node, depth)</span>\n        sum_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        cnt_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            current<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># print(current.val, depth)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>sum_list<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">>=</span> depth<span class=\"token punctuation\">:</span>\n                sum_list<span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> current<span class=\"token punctuation\">.</span>val\n                cnt_list<span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                sum_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                cnt_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># print(result)</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>sum_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            sum_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sum_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>cnt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> sum_list</code></pre></div>\n<p>depth를 추가한 BFS를 이용하여 tree level에 따라 다른 것들을 해줄 수 있다.!</p>","frontmatter":{"date":"September 07, 2023","title":"(Alg) LeetCode Top Interview 150 - 199. Binary Tree Right Side View, 637. Average of Levels in Binary Tree","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-199&637/"}},"prev":{"id":"1b983a40-3c79-583e-87f1-9093beae7e0b","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>Binary Search Tree(BST)에서 두 노드의 차이가 최소가 되도록 하는 값을 찾는 문제이다. <a href=\"https://leetcode.com/problems/minimum-absolute-difference-in-bst/\">링크</a></p>\n<p>두 노드간 차이는 양수이며, 자식-부모관계가 아니여도 된다. 그리고 각각의 노드는 모두 다른 값을 갖는다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>기본적으로 Brute Force로 생각해보면, 트리를 순회하면서 한 노드를 고르고 그것과 차이가 가장 작은 노드를 찾으면 될 것이다. 하지만, 이는 시간이 오래걸리므로, <strong>재귀적으로 문제를 해결</strong>해보자.</p>\n<p>BST이므로 특징을 떠올려볼 수 있는데, <u>한 노드를 root로 하는 subtree에서 root와의 최소 차이를 갖는 값은 둘 중 하나</u>이다.</p>\n<ol>\n<li>오른쪽 자식의 맨 왼쪽 leaf(오른쪽 자식을 root로 하는 subtree에서 가장 작은 값)</li>\n<li>왼쪽 자식의 맨 오른쪽 leaf(왼쪽 자식을 root로 하는 subtree에서 가장 큰 값)</li>\n</ol>\n<p>그리고, <strong>차이가 가장 적은 두 노드를 찾을 때, 두 노드의 관계는 조상~손자의 관계일 것</strong>이다. 왜냐하면 sibling이거나, 조상-손자 관계가 아닐 경우, 항상 그 둘보다 차이가 작은 노드의 조합이 존재한다! 이를 이용하여 재귀적으로 문제를 바라볼 수 있다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(nlog(n))</p>\n<p>각 노드에서 차이의 최솟값을 구하기 위해 해당 서브트리의 높이만큼 탐색하고, 모든 노드를 탐색하므로 nlog(n)정도의 시간이 걸린다고 볼 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>트리의 크기가 증가한다해서 추가적인 메모리가 필요하진 않을 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">getMinimumDifference</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        가장 적은 두 노드간의 차이를 리턴\n        : 어떠한 서브트리에서, min(본인 - 본인 왼쪽 서브 트리중 가장 큰 값, 본인 - 본인 오른쪽 서브 트리중 가장 작은 값)\n        오른쪽(혹은 왼쪽) 자식에서의 최솟값과 본인 노드에서 얻을 수 있는 최솟값을 비교하여 본인의 최솟값으로 정함\n        \"\"\"</span>\n        node <span class=\"token operator\">=</span> root\n        leftMin <span class=\"token operator\">=</span> rightMin <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token operator\">**</span><span class=\"token number\">5</span>\n        <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 오른쪽 자식 있다면</span>\n            rightMin <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>getMinimumDifference<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>getSmallest<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 왼쪽 자식 있다면</span>\n            leftMin <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>getMinimumDifference<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">.</span>val <span class=\"token operator\">-</span> self<span class=\"token punctuation\">.</span>getLargest<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>rightMin<span class=\"token punctuation\">,</span> leftMin<span class=\"token punctuation\">)</span>\n\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">getLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span>Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        해당 노드를 루트로 하는 서브트리에서 가장 큰 값을 리턴\n        \"\"\"</span>\n        <span class=\"token keyword\">while</span> node<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            node <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>right\n        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>val\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">getSmallest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span>Optional<span class=\"token punctuation\">[</span>TreeNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        해당 노드를 루트로 하는 서브트리에서 가장 작은 값을 리턴\n        \"\"\"</span>\n        <span class=\"token keyword\">while</span> node<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            node <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>left\n        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>val</code></pre></div>\n<p><code class=\"language-text\">getMinimumDifference</code>는 어떤 노드를 root로 하는 subtree에서 가장 작은 노드 간의 차이를 리턴하는 함수이다.</p>\n<p>이게 어떻게 최소 차이를 구하냐면,</p>\n<ul>\n<li><strong>자식을 root로 하는 subtree에서의 최소 차이를 구한다</strong> (<code class=\"language-text\">getMinimumDifference(node.right/left)</code>)</li>\n<li>본인 노드와의 최소 차이를 구한다. 이는 위의 Approach에서 언급한 명확한 방법이 있다. (왼쪽자식의 오른쪽 손자, 오른쪽 자식의 왼쪽 손자)</li>\n<li>두 값 중 더 작은 것이 최소 차이이다.</li>\n</ul>\n<p>getMinimumDifference(node.right)를 이용하는게 말이 안되는 것 같지만, 이렇게 <code class=\"language-text\">함수가 역할을 수행한다고 가정하고, 귀납적으로 함수를 구성하는</code> 재귀함수를 구성해볼 수 있다.</p>","frontmatter":{"date":"September 07, 2023","title":"(Alg) LeetCode Top Interview 150 - 530. Minimum Absolute Difference in BST","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-530/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-230/","nextSlug":"/Alg-LC-199&637/","prevSlug":"/Alg-LC-530/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}