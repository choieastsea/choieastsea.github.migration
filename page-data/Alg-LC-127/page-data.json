{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-127/",
    "result": {"data":{"cur":{"id":"79adc579-2fb2-564c-8a24-62a4c576ade5","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>단어에서 한 글자만 바뀐 단어로 바꿀 수 있을 때, 목표 단어까지 도달하는데 최소 얼마나 걸리는지를 구하는 문제이다. <a href=\"https://leetcode.com/problems/word-ladder/\">링크</a></p>\n<p>바뀐 단어 역시 주어진 wordList 안에 있어야하므로, search space를 탐색해야한다고 유추할 수 있다. 참고로, 입력되는 단어의 길이는 모두 같다고 가정한다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>search space에서 root node에서 정답 노드까지의 최단거리를 구해야하므로 <code class=\"language-text\">BFS</code>를 떠올려볼 수 있다.</p>\n<p>한 글자만 다른 단어로 해공간을 확장하는 것이 약간 어렵지만, 나의 경우 단순한 문자열 비교를 통하여 구현하였다. (그래서 그런지 너무 느리다)</p>\n<p>단어마다 visited를 두어, 이미 방문했다면 <code class=\"language-text\">deque</code>에 넣지 않도록 하였고, 거리를 구하기 위하여 큐에 넣을 때, <code class=\"language-text\">(단어, depth)</code>를 넣어주도록 하였다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(w*n^2)</p>\n<p>단어의 길이가 w이고, 갯수가 n개일 때, w개의 글자들을 각각 비교하는 연산(w*n)이 단어마다 존재하므로 <code class=\"language-text\">O(w*n^2)</code>만큼의 시간이 걸린다고 볼 수 있다. 단어의 갯수가 최대 5만개이므로, 간신히 통과한다고 볼 수 있다…ㅎㅎ</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>queue의 크기는 단어의 갯수에 비례할 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">ladderLength</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> beginWord<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> endWord<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> wordList<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        한글자씩 다른 단어들로 search space를 확장하면서 BFS를 수행\n        확장시, 최초 마주치는 단어는 이후에 선택되지 않도록 해야함\n        최단 거리에 위치한 endWord 발견시 len(depth)를 리턴\n        \"\"\"</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>beginWord<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># word, depth</span>\n        visited<span class=\"token punctuation\">[</span>beginWord<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            curWord<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 주변으로 확장</span>\n            <span class=\"token keyword\">for</span> word <span class=\"token keyword\">in</span> wordList<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> word <span class=\"token keyword\">in</span> visited<span class=\"token punctuation\">:</span>\n                    <span class=\"token comment\"># 한 글자만 다른 단어로 공간 확장</span>\n                    diffCnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> curWord<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                            diffCnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                            <span class=\"token keyword\">if</span> diffCnt <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                                <span class=\"token keyword\">break</span>\n                    <span class=\"token keyword\">if</span> diffCnt <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        <span class=\"token comment\"># 답 발견하면 종료</span>\n                        <span class=\"token keyword\">if</span> word <span class=\"token operator\">==</span> endWord<span class=\"token punctuation\">:</span>\n                            <span class=\"token keyword\">return</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        visited<span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span></code></pre></div>\n<p>단어간의 edit distance를 구하는 더 좋은 방법이 있다면 빨라질 것이다. (이 방법은 메모리에서만 96%를 기록하였다) 찾아보니, 단어에서 한 글자씩 *로 대체하여 공간을 탐색하는 방법이 있던데 바로 생각해내기엔 어려운 것 같다.</p>","excerpt":"Intuition 단어에서 한 글자만 바뀐 단어로 바꿀 수 있을 때, 목표 단어까지 도달하는데 최소 얼마나 걸리는지를 구하는 문제이다. 링크 바뀐 단어 역시 주어진 wordList 안에 있어야하므로, search space를 탐색해야한다고 유추할 수 있다. 참고로, 입력되는 단어의 길이는 모두 같다고 가정한다. Approach search space에서 root node에서 정답 노드까지의 최단거리를 구해야하므로 를 떠올려볼 수 있다. 한 글자만 다른 단어로 해공간을 확장하는 것이 약간 어렵지만, 나의 경우 단순한 문자열 비교를 통하여 구현하였다. (그래서 그런지 너무 느리다) 단어마다 visited를 두어, 이미 방문했다면 에 넣지 않도록 하였고, 거리를 구하기 위하여 큐에 넣을 때, 를 넣어주도록 하였다. Complexity Time complexity: O(w*n^2) 단어의 길이가 w이고, 갯수가 n개일 때, w개의 글자들을 각각 비교하는 연산(w*n)이 단어마다 존재하므로…","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 127. Word Ladder","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-127/"}},"next":{"id":"978ac032-18aa-54da-b2a7-1ec04a7419f7","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>graph가 주어졌을 때, <strong>깊은 복사</strong>를 수행한 그래프의 사본을 리턴하는 문제이다. <a href=\"https://leetcode.com/problems/clone-graph/\">링크</a></p>\n<p>python에서는 원시 타입이 아닌 경우 참조형 객체에서 대입연산을 수행하는 경우 얕은 복사가 일어난다. 이는 원본 값이 바뀌면 사본 역시 바뀌게 되는 경우가 생기게 된다. 깊은 복사의 경우, 독립된 객체이므로 원본과 사본이 독립적이다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>깊은 복사를 수행하는 방법은 크게 두가지가 있다.</p>\n<ol>\n<li>\n<p>copy.deepcopy 함수를 이용</p>\n</li>\n<li>\n<p>원본 값의 마지막 depth까지 그래프를 탐색하며 새로운 값을 만들기</p>\n<p>그래프를 탐색하면서, 원본 노드의 값을 이용하여 새로운 노드를 만들고, 그래프의 연결관계를 초기화해주면 된다. 여기서 그래프를 탐색하는 방법에는 여러가지가 있는데 나의 경우 리스트로 간단하게 처리할 수 있는 DFS 탐색을 수행하였다.</p>\n<p>그래프를 탐색하다보면 <strong>같은 값의 노드를 여러번 생성하게 될 수도 있는데</strong>, 이를 방지하기 위해 사본 그래프의 모든 노드를 저장하는 dictionary로 노드의 중복 생성을 방지하였다.</p>\n</li>\n</ol>\n<p>1번은 간단하지만, 출제자의 의도를 생각하면 2번째 방법으로 하는 것이 좋을 것이다.(실제 해보니 성능도 좋다!)</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(V*E)</p>\n<p>그래프를 탐색하기 위해 노드 갯수와 엣지 갯수 만큼의 시간이 걸릴 것이다. 각 노드마다 연결된 간선을 탐색하며 다음 노드로 넘어가기 때문이다.</p>\n</li>\n<li>\n<p>Space complexity: O(V)</p>\n<p>stack의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"</span>\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 그래프를 깊은 복사하여 리턴</span>\n        <span class=\"token comment\"># node에서부터 neighbors DFS 탐색하며 만들자</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\n        root <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 원본</span>\n        copyDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>node<span class=\"token punctuation\">.</span>val <span class=\"token punctuation\">:</span> root<span class=\"token punctuation\">}</span> <span class=\"token comment\"># 사본</span>\n        <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>\n            cur_org <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># print(cur_org.val, 'popped', cur_org == copyDict[cur_org.val])</span>\n            <span class=\"token keyword\">for</span> neighbor <span class=\"token keyword\">in</span> cur_org<span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># print(neighbor.val)</span>\n                <span class=\"token comment\"># stack에 순회할 노드 추가</span>\n                <span class=\"token keyword\">if</span> neighbor<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> copyDict<span class=\"token punctuation\">:</span>\n                    stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">)</span>\n                    <span class=\"token comment\"># 없다면 새로운 노드 만들어줌</span>\n                    copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\"># 현재 노드와 neighbor 연결</span>\n                copyDict<span class=\"token punctuation\">[</span>cur_org<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>neighbors<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>copyDict<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                \n        <span class=\"token keyword\">return</span> root</code></pre></div>\n<p>copyDict라는 사본 노드들을 {‘숫자’ : ‘노드’} 형태의 dictionary로 저장한다.</p>\n<p>원본 노드들을 DFS로 탐색하면서, copyDict에 없다면 만들어주고, 있으면 해당 노드를 현재 노드와 연결(neighbors)해주면 된다.</p>\n<p>추가로, deepcopy 함수를 이용한 pythonic한 방법도 첨부한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> copy <span class=\"token keyword\">import</span> deepcopy\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Optional\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">cloneGraph</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> deepcopy<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span></code></pre></div>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 133. Clone Graph","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-133/"}},"prev":{"id":"b42ec5e0-aae0-562f-9b65-3158bbeffa0d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. <a href=\"https://leetcode.com/problems/snakes-and-ladders/\">링크</a></p>\n<p><a href=\"https://www.acmicpc.net/problem/16928\">백준 16928</a>과 거의 같은 문제이다.</p>\n<p>뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다.</p>\n<p>하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getLocOfBoard</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    row <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n    col <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>row<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n    <span class=\"token keyword\">return</span> row<span class=\"token punctuation\">,</span>col</code></pre></div>\n<p>아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n^2)</p>\n<p>노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사위 최댓값)이하이므로 시간복잡도는 O(n^2)라고 볼 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n^2)</p>\n<p>deque의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">snakesAndLadders</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># [blockNum,time]</span>\n        visited <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q)</span>\n            blockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 목적지 도달한 경우</span>\n            <span class=\"token keyword\">if</span> blockNum <span class=\"token operator\">==</span> n<span class=\"token operator\">*</span>n<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> time\n            <span class=\"token comment\"># 1~6칸 이동</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                nextBlockNum <span class=\"token operator\">=</span> blockNum <span class=\"token operator\">+</span> i\n                nextRow <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n                nextCol <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>nextRow<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n                <span class=\"token comment\"># print(nextBlockNum, nextRow,nextCol)</span>\n                <span class=\"token keyword\">if</span> nextBlockNum <span class=\"token operator\">&lt;=</span> n<span class=\"token operator\">*</span>n <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> time<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></code></pre></div>\n<p>처음에 q에서 popleft를 하여 목적지인지를 판단하고 아니라면 계속하여 BFS를 수행하면 된다. q가 비어있는 상황은 모든 노드를 탐색하여 더 이상 연결된 탐색할 노드가 없는 경우이다. 답이 없는 경우에는 -1을 리턴하라고 했으므로, while 문이 빠져나오면 리턴해주면 된다.</p>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 909. Snakes and Ladders","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-909/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-127/","nextSlug":"/Alg-LC-133/","prevSlug":"/Alg-LC-909/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}