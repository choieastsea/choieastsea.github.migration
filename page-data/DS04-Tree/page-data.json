{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/DS04-Tree/",
    "result": {"data":{"cur":{"id":"19b36e89-13e5-59ef-85e9-e9ac1c6d5531","html":"<p><code class=\"language-text\">Tree</code>(트리)는 계층적인 구조를 나타내기 위한 자료구조이다. 나무를 뒤집어 놓은 듯한 구조로 보통 표현되며, 뿌리인 root node에서부터 자식 노드로 단방향으로 뻗어져 나간다. 파일 디렉토리가 트리의 경로와 같이 표현되어 있으며 (ex C>>Desktop>>Document>>index.md), <code class=\"language-text\">Heap</code>, <code class=\"language-text\">Trie</code>  등에도 사용된다.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/400px-Binary_tree.svg.png\" alt=\"트리 위키백과\"></p>\n<h1 id=\"tree-용어\" style=\"position:relative;\"><a href=\"#tree-%EC%9A%A9%EC%96%B4\" aria-label=\"tree 용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree 용어</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAAB5ElEQVQoz31SXXPaMBD0//8/fe5MQwmBkLT5xsZ8phiwDbZsSzqd7i5jQ0r60h3p5aS93dm7gJlFWDpwB+oqe8M3O/pSPkNEPHFU8sFycJ/xtxWnDXoHxlpjjNYNI+y2yeD6ulZKOVFApw6ICGCJZbiBpPaB9ZwbNs6jA4fIREByl8l0+R6/PKbJ+3PuYyUixCIAYIxpxZ0lj0HluMGzJSJiIlU3T8t93ehY0SbZHfM9k0dqLSOic05ELAAiBr8y/rnl2qLRjdbtHfR+jH8/ZSgzxYeyGvZ7r/P3USYFsEcAABFxznnvg3/yECGidRxFq6RoBdrAoslks0mofeJWt1O+kOVLkvs0TxuoVOmx/WS0rqpKlcp7PHFOZABoyYMdTwo2SAAwDcPeYDRI3MNkFr29VlV1Px6Xx7wuDuPR0BjD3ntnL+R1zX9q1s7rpomn05fHBwSzWi6nYVgW5WIavW2KfpzeDm9sU0clj7dgUNCB99TZlrYjIipVHo9HrQ0RdcshwrTT/Fycl0gBN67dIuccEQVHy5UTRLeYz/M8Z6LVYqGUOoV3mmA75L+5dNGcA+slNEolTbP+1dV8Fltr725HcTiRTzIR+08udYeZtdaXUYnw97gMUy2C0bborXVYChL/Hx8lf+gCgZ9IdAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"용어\"\n        title=\"용어\"\n        src=\"/static/48d4dffdff985717ca8769cf822210d9/0b533/tree_term.png\"\n        srcset=\"/static/48d4dffdff985717ca8769cf822210d9/e9ff0/tree_term.png 180w,\n/static/48d4dffdff985717ca8769cf822210d9/f21e7/tree_term.png 360w,\n/static/48d4dffdff985717ca8769cf822210d9/0b533/tree_term.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>root(루트) : 최상위 계층에 있는 노드. 한 트리에서 루트 노드는 유일하게 존재한다.</p>\n</li>\n<li>\n<p>level(레벨) : 루트에서 특정노드까지의 거리(엣지의 수)</p>\n</li>\n<li>\n<p>parent/child node(부모-자식 노드) : 한 노드와 직접 연결되어 있는 경우, 부모 자식 노드의 관계이다. 가리키는 노드가 부모, 아닌 노드가 자식 노드라고 보면 된다.</p>\n</li>\n<li>\n<p>sibing nodes(형재 노드) : 같은 부모 노드를 갖는 노드</p>\n</li>\n<li>\n<p>height(높이) : 트리의 높이 == <code class=\"language-text\">max(all nodes' level)</code></p>\n</li>\n<li>\n<p>sub tree(서브 트리) : 한 노드를 기준으로 하는 트리. 트리를 재귀적으로 볼 수 있게 해준다.</p>\n</li>\n</ul>\n<h1 id=\"tree의-특징과-종류\" style=\"position:relative;\"><a href=\"#tree%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-label=\"tree의 특징과 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree의 특징과 종류</h1>\n<h2 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h2>\n<ul>\n<li>루트에서 특정 노드까지의 경로가 유일하다.(두 노드를 잇는 경로는 유일하다)</li>\n<li>부모 노드에서 자식노드로 단방향 연결되어 있다.</li>\n</ul>\n<h2 id=\"종류\" style=\"position:relative;\"><a href=\"#%EC%A2%85%EB%A5%98\" aria-label=\"종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>종류</h2>\n<ul>\n<li>이진 트리 : 자식이 최대 2개인 트리. 보통 자식을 왼쪽 오른쪽으로 구분하여 표현</li>\n<li>완전 이진 트리 : 이진 트리 중, 자식 노드가 왼쪽부터 차례대로 채워져 있는 트리. 0번 인덱스를 무시하면 <strong>배열로 편하게 구현 가능하다.</strong></li>\n<li>힙: 부모노드의 값이 항상 자식노드의 값보다 큰(혹은 작은) 완전 이진 트리. 이 경우, **루트 노드의 값은 항상 최댓값(혹은 최솟값)**이 된다.</li>\n<li>Binary Search Tree(BST, 이진 탐색 트리)</li>\n</ul>\n<p>그 중 오늘은 <code class=\"language-text\">Binary Tree</code>를 직접 구현해보자.</p>\n<h1 id=\"binary-tree이진-트리\" style=\"position:relative;\"><a href=\"#binary-tree%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC\" aria-label=\"binary tree이진 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Tree(이진 트리)</h1>\n<p><code class=\"language-text\">Binary Tree</code>(이진트리)는 한 노드의 자식이 최대 2개인 트리이며, 보통 왼쪽 자식과 오른쪽 자식으로 나눈다. n개의 노드가 있을 때, 가능한 레벨은 log(n)~n이라고 볼 수 있다. log(n)은 모든 노드의 자식이 가능할 때까지 2개씩 차있는 경우이며, n일때는 모든 노드가 하나의 자식 노드만을 갖는 경우(skew tree)이다.</p>\n<h1 id=\"이진-트리-구현\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84\" aria-label=\"이진 트리 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리 구현</h1>\n<p>이진트리를 만드는데에는 다양한 방법이 있지만, 데이터를 담고 있는 노드간의 참조(reference)로 계층적인 구조를 구현해보자. 우선 노드는 다음의 properties를 갖고 있어야 한다.</p>\n<ul>\n<li>data</li>\n<li>left child</li>\n<li>right child</li>\n</ul>\n<p>부모 노드는 자식(최대 2개)을 가리키고 있으며, 데이터를 갖고 있도록 한다.</p>\n<p><code class=\"language-text\">Binary Tree</code> class는 root만 갖고 있으면 된다. root에서 그 이하의 노드들까지 모두 접근이 가능하기 때문이다. 따라서 나는 아래와 같이 루트 노드를 만들어 트리 관계를 만들어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">BT_Node</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token comment\">//이진 트리의 노드</span>\n    value<span class=\"token punctuation\">;</span>\n    leftChild <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    rightChild <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BinaryTree</span> <span class=\"token punctuation\">{</span>\n    root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> node_1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_5 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_6 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_7 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> node_8 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BT_Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nnode_1<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_2<span class=\"token punctuation\">;</span>\nnode_1<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_3<span class=\"token punctuation\">;</span>\nnode_2<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_4<span class=\"token punctuation\">;</span>\nnode_2<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_5<span class=\"token punctuation\">;</span>\nnode_3<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_8<span class=\"token punctuation\">;</span>\nnode_3<span class=\"token punctuation\">.</span>rightChild <span class=\"token operator\">=</span> node_7<span class=\"token punctuation\">;</span>\nnode_7<span class=\"token punctuation\">.</span>leftChild <span class=\"token operator\">=</span> node_6<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> bt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BinaryTree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbt<span class=\"token punctuation\">.</span>root <span class=\"token operator\">=</span> node_1<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 아래와 같은 트리 구조를 보이게 될 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 540px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxUlEQVQ4y5VUXW/iMBDM//9L91FdpQpIK/Xh2j5wgIBCC01wSDaOHex4Ki9NsZJcpVpaOVnPjteza0dN06BvlmdrLYDm05w7+9q1odgo/PGgMMA5izw32GxOmP7TyLITE4eYLnEU7mZtCHLwY7dXuLnZ4c/1K4TQ7AvJfEzIEYXZ+aO2AKUUDgcBIRJoXaLWhMMhgRACWmt0T/afDC3rlOc50jSBlBX7nXNs/ltKyWtEhG4sE7ape23y/IQ4Jvz4KfD3QcGYvrbe9/io8Ou3wGhMEOKiq7foEuBnh5cXgdlsiyyr4BxgjO1pm6YlY/b7I8eEG0aX1nAgEpDyyNXNsjfUtfwowlkKj1GKUBQpY4pCgChjf5tl5IFU+taoMJsdkaSG9UpTjfk8w3qtobWBUhZJUmM6zbBYKMYQWcwXR6zXFR/dc0WeebvVmMSEyaTEcqV4t6cnidvbEuNxAaUM9+D9fcmYuztizPNGYzQqEMcFrzNh9za0qYf/50oPYQApC1QV8XenKPajAJc2MJ/NO2x+KFVCKckS9Ai7V+9rsgarlWJJrq5yLJdnqaLhx+Fray8AkcHrTmO3r1GWpv84fJd06CV6B7XqkF28bbv4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tree\" title=\"tree\" src=\"/static/6b5b77574a5c815ed3aafe575d2e2117/07484/tree.png\" srcset=\"/static/6b5b77574a5c815ed3aafe575d2e2117/e9ff0/tree.png 180w,\n/static/6b5b77574a5c815ed3aafe575d2e2117/f21e7/tree.png 360w,\n/static/6b5b77574a5c815ed3aafe575d2e2117/07484/tree.png 540w\" sizes=\"(max-width: 540px) 100vw, 540px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<h1 id=\"이진-트리의-탐색\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%83%90%EC%83%89\" aria-label=\"이진 트리의 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리의 탐색</h1>\n<p>위의 트리 구조를 직접 확인하기 위해서는 <u>트리 탐색(<code class=\"language-text\">traverse</code>)</u>가 필요하다. <u>트리의 <strong>모든 노드를 일정한 순서로 한번씩 탐색</strong></u>해야 하며 루트 노드를 기준으로 시작한다. (탐색은 출력과 같은 의미로 해석 가능)</p>\n<p>탐색에는 크게 두가지 방법이 있으며 <code class=\"language-text\">recursion</code>(재귀)을 이용하여 구현해볼 수 있다.</p>\n<h2 id=\"1-pre-order-traverse\" style=\"position:relative;\"><a href=\"#1-pre-order-traverse\" aria-label=\"1 pre order traverse permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Pre order traverse</h2>\n<p>이진트리를 탐색하는 방법으로 후위, 중위, 전위 순회가 있다. 한 노드를 기준으로 트리를 보면 현재 노드, 왼쪽 서브 트리, 오른쪽 서브 트리로 볼 수도 있다. 각각을 1,2,3번이라고 했을 때 1-2-3의 순서로 탐색을 하는 것이 <code class=\"language-text\">pre-order-traverse</code>방식이다. 2-3-1로 서브 트리를 먼저 탐색한 후 현재 노드를 탐색하는 <code class=\"language-text\">post-order</code>, 2-1-3의 순서로 서브 트리 사이에 현재 노드를 탐색하는 <code class=\"language-text\">in-order</code>방식이 존재한다. 여기서는 그 중 하나인 <code class=\"language-text\">pre-order-traverse</code>를 구현해보도록 하자.</p>\n<p>위의 그림을 탐색한 결과를 예상해보면 아래와 같다.</p>\n<ol>\n<li>node1을 탐색(출력)</li>\n<li>node2를 root로 하는 sub-tree 탐색\n<ol>\n<li>node2를 탐색(출력)</li>\n<li>node4를 root로 하는 sub-tree 탐색\n<ul>\n<li>node4 탐색(출력)</li>\n</ul>\n</li>\n<li>node5를 root로 하는 sub-tree 탐색\n<ul>\n<li>node5 탐색(출력)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>node3을 root로 하는 sub-tree 탐색\n<ol>\n<li>node3을 탐색(출력)</li>\n<li>node8을 root로 하는 sub-tree 탐색\n<ul>\n<li>node8 탐색(출력)</li>\n</ul>\n</li>\n<li>node7을 root로 하는 sub-tree 탐색\n<ul>\n<li>node7 탐색(출력)</li>\n<li>node6을 root로 하는 sub-tree 탐색\n<ul>\n<li>node6 탐색(출력)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>위의 순서로 재귀적으로 탐색할 것이므로 1-2-4-5-3-8-7-6의 순서로 출력될 것이다.</p>\n<p>BinaryTree class의 traverse 메서드의 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">traverse</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//pre-order-traverse : 부모-왼쪽-오른쪽 탐색</span>\n  \t<span class=\"token comment\">//탐색은 출력과 같은 의미</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"2-bfs-algorithm을-이용한-트리-탐색\" style=\"position:relative;\"><a href=\"#2-bfs-algorithm%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8A%B8%EB%A6%AC-%ED%83%90%EC%83%89\" aria-label=\"2 bfs algorithm을 이용한 트리 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. BFS Algorithm을 이용한 트리 탐색</h2>\n<p>그래프에서 사용하는 <code class=\"language-text\">BFS</code> 알고리즘을 통하여 트리에서 사용해보자. 결국 트리도 그래프이므로 그래프 탐색 알고리즘을 사용할 수 있으며, 이진 트리일 필요는 없다.</p>\n<p>Breadth First Search(BFS, 너비 우선 탐색)은 그래프에서 인접한 노드를 먼저 탐색하는 방법이다. 트리에서는 루트에서부터 떨어진 거리(level)에 따라 탐색한다고 보면 될 것같다. 즉 루트, 루트에서부터 거리가 1인 노드들, 거리가 2인 노드들… 순으로 말이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 540px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVQ4y5WT61KjQBCFef9H8m90dU2CkVTIxUAwgaBAkAxm5P5tMcQY13Jr7apTPd1zpqsv01pVVdR1TavPUdedhvqEpqk/3X1w65PWvgtYlhVNU5EkBRs3Z7HIiONC+dq7bwOeG+/SNKcjYZhzfR1weRmQJOUXTtM0p/enDFtnmqaYpslsNmM+n2MYBsOhzmDwm/FYV+j3b5VvPB4rTst3XVcF/lJynuckSUKaCrZbD8dZEYYhQgiESI8QBEGg7p6efPb7PWn6+ql0rTO6cosCDKOkdylZLvlWLBuufklGowopOWbYtU71sChKLMtiMpnS6w24uOhx279X5U8mJqY5PcJkOp1xczNSnKurIaY5Y7FYkGX5e4a1mpyUKZ73yPOzixAvrNcWYfiEPOxJkheF19c9QbDF81YIkeB5a7bbNVIKFeM45Yo0LdluM+yVII678uO4ZOXscd2ComjI84bdrmRp7XGcXHEOssFxBK6XsYtzFVSDhuegYqi/MRhmuG73NeaLHP0uYzCQlCUI0WCMO87d6E1xfL/iti/RdUmatv+oQWunZFkLHGepsFoteXh4UPrctqwPX4u2b47T9t3ANMfYtoWUEi3LMqIoIop2J+x2u3/aHSKSJMb3XXzfU5z262nnG/JTCQK4vy+5vinUuRXt7x3+H7RJSHnAnNoMhja6bjOd2kRR2GX4E7yv6uFwYLN5xPc3Cuu1ozbrD3DNdMUsjujrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tree\" title=\"tree\" src=\"/static/e16884cb66aa9302adbaf47a1ac7d9b2/07484/tree_bfs.png\" srcset=\"/static/e16884cb66aa9302adbaf47a1ac7d9b2/e9ff0/tree_bfs.png 180w,\n/static/e16884cb66aa9302adbaf47a1ac7d9b2/f21e7/tree_bfs.png 360w,\n/static/e16884cb66aa9302adbaf47a1ac7d9b2/07484/tree_bfs.png 540w\" sizes=\"(max-width: 540px) 100vw, 540px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>위의 그림을 BFS방식으로 루트부터 탐색하면, 1-2-3-4-5-8-7-6의 순서로 될 것이다. 어쩌면 BFS알고리즘으로 트리를 탐색하는 것이 pre-order-traverse보다 우리의 직관으로 이해하기 쉽다. BFS는 FIFO의 특성을 갖는 <code class=\"language-text\">queue</code>를 이용하여 구현가능하다.</p>\n<p>이하는 큐를 이용한 BFS 알고리즘(tree ver)이다.</p>\n<ol>\n<li>현재 노드를 탐색한 후, 큐에 넣는다(enqueue)</li>\n<li>큐에 노드가 없을 때까지\n<ol>\n<li>큐 가장 앞 노드를 꺼낸다.(dequeue)</li>\n<li>꺼낸 노드의 자식 노드들을 탐색 후 큐에 넣는다(enqueue)</li>\n</ol>\n</li>\n</ol>\n<p>코드는 다음과 같다. 인자로 root node를 넣어주면 트리 순회를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">bfsTraverse</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> current_node <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>leftChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>current_node<span class=\"token punctuation\">.</span>rightChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>전체 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS04_BinaryTree.js\">깃허브에</a> 업로드 해놓았다~</p>\n<p>힙과 Binary Search Tree(BST, 이진 탐색 트리)는 다음에 알아보도록 하자.</p>","excerpt":"(트리)는 계층적인 구조를 나타내기 위한 자료구조이다. 나무를 뒤집어 놓은 듯한 구조로 보통 표현되며, 뿌리인 root node에서부터 자식 노드로 단방향으로 뻗어져 나간다. 파일 디렉토리가 트리의 경로와 같이 표현되어 있으며 (ex C>>Desktop>>Document>>index.md), ,   등에도 사용된다. 트리 위키백과 Tree 용어  root(루트) : 최상위 계층에 있는 노드. 한 트리에서 루트 노드는 유일하게 존재한다. level(레벨) : 루트에서 특정노드까지의 거리(엣지의 수) parent/child node(부모-자식 노드) : 한 노드와 직접 연결되어 있는 경우, 부모 자식 노드의 관계이다. 가리키는 노드가 부모, 아닌 노드가 자식 노드라고 보면 된다. sibing nodes(형재 노드) : 같은 부모 노드를 갖는 노드 height(높이) : 트리의 높이 ==  sub tree(서브 트리) : 한 노드를 기준으로 하는 트리. 트리를 재귀적으로 볼 수 있게 해…","frontmatter":{"date":"November 05, 2021","title":"(자료구조 JS)트리와 이진트리 탐색 Tree & Binary Tree traverse","categories":"Alg","author":"choieastsea","emoji":"🏄‍♂️"},"fields":{"slug":"/DS04-Tree/"}},"next":{"id":"8b6696db-6098-577e-8a21-f90d144ae266","html":"<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<h2 id=\"복사\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC\" aria-label=\"복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사</h2>\n<p><code class=\"language-text\">복사</code>: 내용은 완전히 같지만, 주소는 완전히 다른 사본을 만들어내는 것</p>\n<p><code class=\"language-text\">얕은 복사</code>: <strong>원본과 참조 공유가 있어</strong> 상황에 따라 문제가 생길 수 있는 복사, depth가 1인 복사</p>\n<p><code class=\"language-text\">깊은 복사</code>: 내용만 같고 모든 원소의 주소는 달라 <strong>원본과 완전히 독립</strong>된 복사</p>\n<h2 id=\"복사-판단방법\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC-%ED%8C%90%EB%8B%A8%EB%B0%A9%EB%B2%95\" aria-label=\"복사 판단방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사 판단방법</h2>\n<p>즉, 모든 원소의 내용은 같으면서 ===의 결과가 false가 나와야(<strong>다른 주소를 참조, 원본과 독립되어있다</strong>는 의미) 깊은 복사가 된 것이다.</p>\n<p>같은 방법을 통하여 복사를 했더라도 <strong>객체의 깊이에 따라 얕은 복사가 될 수도, 깊은 복사가 될 수도</strong> 있다!</p>\n<hr>\n<h1 id=\"계기\" style=\"position:relative;\"><a href=\"#%EA%B3%84%EA%B8%B0\" aria-label=\"계기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계기</h1>\n<p>React.js에서 state(상태)를 다루다보면 <code class=\"language-text\">불변성</code>이라는 속성이 굉장히 중요 하게 여겨진다. 리액트에서 불변성이란, 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 의미한다. 새로운 값이라는 것은 <strong>원본과는 완전히 독립된 사본</strong>에서 변형이 이루어진 데이터이며, 이를 위해 깊은 복사의 개념을 익힐 필요를 느끼게 되었다.</p>\n<h1 id=\"사전-지식\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%A0%84-%EC%A7%80%EC%8B%9D\" aria-label=\"사전 지식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사전 지식</h1>\n<h2 id=\"primitive-type과-reference-type\" style=\"position:relative;\"><a href=\"#primitive-type%EA%B3%BC-reference-type\" aria-label=\"primitive type과 reference type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primitive type과 Reference type</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">자바스크립트의 자료형</a></p>\n<p>자바스크립트에는 <code class=\"language-text\">원시타입</code>(primitive type)과 <code class=\"language-text\">참조타입</code>(reference type)이 존재한다. 원시타입은 값 자체이며 메모리에 바로 저장된다. 참조타입은 원시타입을 제외한 나머지를 저장하는 방식으로, 메모리에 실제 값들이 저장되어 있는 주소가 저장되어있다. 참조타입에서 실제 값들은 Heap 메모리에 저장되어있다.</p>\n<h2 id=\"객체의-깊이depth\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B9%8A%EC%9D%B4depth\" aria-label=\"객체의 깊이depth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체의 깊이(depth)</h2>\n<p><code class=\"language-text\">{abc: 'xyz'}</code>의 깊이는 1이다.</p>\n<p><code class=\"language-text\">{foo:{bar:{baz : 'baa'}}}</code>의 깊이는 3이다.</p>\n<h2 id=\"대입연산자를-통한-복사--aliasing\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%9E%85%EC%97%B0%EC%82%B0%EC%9E%90%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%B3%B5%EC%82%AC--aliasing\" aria-label=\"대입연산자를 통한 복사  aliasing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대입연산자를 통한 복사 ↔ Aliasing</h2>\n<p>원시타입에서 다음 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> num2 <span class=\"token operator\">=</span> num1<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnum2 <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num1 <span class=\"token operator\">===</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//2</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/798584e8-7421-4ced-8479-aa6a432fae77/Untitled.png\" alt=\"\"><img src=\"https://images.velog.io/images/choieastsea/post/da95333d-b559-4df9-a728-3c29f9bb2442/Untitled%201.png\" alt=\"\"></p>\n<p><strong>원시 타입</strong>에서는 대입연산자를 통하여 할당이 된다. 위의 예시처럼 num2의 값을 바꾼다면, num2가 새로운 값을 갖도록 재할당한다고 볼 수 있다. num2의 값이 바뀌었다고 num1의 값도 바뀌지는 않는다.</p>\n<p>그렇다면 참조타입에서는 어떨까? 다음 코드의 결과를 예상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">===</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">**</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token operator\">**</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//true</span>\n<span class=\"token comment\">//[1,4,[1,2,3]]</span>\n<span class=\"token comment\">//true</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/df74b351-8d27-4261-99e1-e98e36b5eae7/Untitled%202.png\" alt=\"\">\n<img src=\"https://images.velog.io/images/choieastsea/post/a88e5715-2902-47b6-ba2e-d65ff10c7a70/Untitled%203.png\" alt=\"\">\n하지만, <strong>참조 타입에서는 참조 공유</strong>가 된다. 위에서도 b는 새로운 메모리 공간이 아닌 a와 같은 주소를 공유하게 된다. 그렇게되면 사본인 b를 수정했는데 원본인 a도 바뀌는 것이다.</p>\n<p>원시 타입에서는 대입연산자를 통한 복사(깊은 복사)라고 볼 수 있지만, <em>참조 타입에서 대입연산은 복사라고 볼 수 없다</em>. 참조타입에서의 대입연산(=)은 copy가 아닌 <code class=\"language-text\">aliasing</code>이다. alias란 <code class=\"language-text\">별명</code>이라는 뜻으로, A와 B가 같은 객체를 가리키는 것을 의미한다. 예컨데, 손흥민과 우리흥은 말(내용)은 다르지만 같은 본질(사람)을 가리킨다. 이때 ‘우리흥’은 ‘손흥민’의 alias라고 볼 수 있다.</p>\n<h1 id=\"복사란\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%82%AC%EB%9E%80\" aria-label=\"복사란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⭐복사란?</h1>\n<p>이 페이지에서 말하는 <code class=\"language-text\">복사</code>란, aliasing(참조공유)과는 완전 다른 개념이다.(‘손흥민’과 ‘우리흥’처럼 같은 객체를 가리키는 것이 아님!) <strong><em>외형은(내용은) 완전히 같지만, 본질은(주소는) 완전히 다른 사본</em>을 만들어내는 것</strong>이 여기서 말하는 복사이다.</p>\n<p>참조타입에는 <strong>복사되는 depth(깊이)에 따라</strong> 얕은 복사와 깊은 복사가 존재한다. 각 방법을 익히고 적재적소에 사용하도록 해보자!</p>\n<h2 id=\"얕은복사\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC\" aria-label=\"얕은복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은복사</h2>\n<p>하나의 depth까지만 복사한다. 따라서 참조공유의 문제가 발생할 수 있다.</p>\n<p>객체나 배열의 깊이를 생각하지 않고 1차원적으로 원소들을 복사하여 새로운 변수에 넣어주면 얕은복사이다. 이는 일차원 객체에서는 깊은복사이지만, 깊이가 2 이상인 경우에는 위에서 본 참조공유의 문제(aliasing)을 일으킨다.</p>\n<p>js에서는 이를 위해 반복문을 이용한 직접 대입, slice 함수, ES6의 spread 연산자 등을 이용할 수 있다.</p>\n<ol>\n<li>\n<p>for문</p>\n<p>일일이 객체의 value(배열이라면 원소)를 넣어준다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">shallow_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends <span class=\"token operator\">=</span> <span class=\"token function\">shallow_copy</span><span class=\"token punctuation\">(</span>friends<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"2\">\n<li>spread 연산자(전개구문, …)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Anthony'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Eastsea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shallow_friends_2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>friends<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>직관적이며 기존의 함수들을 포함한 기능들을 사용할 수 있기에 최근에 많이 사용되는 것 같다.</p>\n<ol start=\"3\">\n<li>\n<p>assign 함수, slice 함수</p>\n<p>전개연산자가 있는데 굳이 해볼 필요는 없을 것 같으니 인터넷에서 찾아보도록 하자.</p>\n</li>\n</ol>\n<p>위 코드의 결과로 복사가 잘 되어있을 것이다. 깊이가 1인 객체에 대하여 위 방법은 깊은 복사가 된다고 볼 수 있다!</p>\n<p>이제 일차원 배열 말고 다음과 같이 <strong>깊이가 2이상인 객체</strong>에 대하여 위의 복사를 진행해보자. 이름, 나이, 가족 구성원 배열을 갖고 있는 객체를 복사하려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> shallow_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token operator\">===</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> shallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">//사본의 값을 바꿔보자.</span>\nshallow_copy<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'another_name'</span><span class=\"token punctuation\">;</span>\nshallow_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//참조 공유로 인해 원본도 수정된다.</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>shallow_copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/d4c1c9b7-ecf0-46dd-91d4-599f15a39040/Untitled%204.png\" alt=\"\">얕은 복사 직후의 상황\n얕은 복사를 하면 1차원적으로는 복사가 이루어졌지만, 깊이가 2인 family배열은 공유하고 있는 상태가 된다. 이 경우 문제 있는 <code class=\"language-text\">origin.family===shallow_copy.family</code>를 하면 true가 나온다.\n<img src=\"https://images.velog.io/images/choieastsea/post/21b6cf6f-66bc-4566-b0cd-eef19968d35f/Untitled%205.png\" alt=\"\">이는 참조공유의 문제가 생긴다. 배열의 원소단위로 값만 가져왔지만, <em>원소가 만약 또 참조 타입인 경우</em>에 다시 참조를 공유하는 문제가 생기게 되는 것이다. 이와 같이 <strong>참조의 문제가 여전히 남아있는 복사가 얕은 복사이다</strong>.  우리는 이를 떼어내서 완벽하게 독립된 사본을 만들어줄 필요가 있다. 위에서는 간단하게 push해주는 부분을  <code class=\"language-text\">shallow_copy.family = shallow_copy.family.concat('cat');</code>으로 바꿔 새로운 객체를 할당함으로써 문제를 해결할 수 있다.</p>\n<p>하지만 이렇게 문제가 생겨 수정하는 것보다, 복사를 할때부터 이러한 참조의 문제를 일으키지 않도록 하고 싶을 때 <code class=\"language-text\">깊은복사</code>를 이용할 수 있다.</p>\n<h2 id=\"깊은-복사\" style=\"position:relative;\"><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깊은 복사</h2>\n<p>깊은 복사를 위해서는 구조적으로 제일 깊숙한 참조타입까지 복사를 진행해주면 되는데, 깊이마다 얕은복사, 재귀함수, 라이브러리, JSON 함수와 같은 방법들이 존재한다.</p>\n<p>아래와 같이 바꾸면 깊은 복사에 성공한 것이다. family를 ===한 결과 false가 나올 것이다.\n<img src=\"https://images.velog.io/images/choieastsea/post/6bca52a9-8858-4455-a729-d9e126aaa506/Untitled%206.png\" alt=\"\"></p>\n<ol>\n<li>\n<p>깊이마다 얕은 복사 진행</p>\n<p>얕은 복사를 객체의 깊이별로 진행해주면 된다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> origin <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name <span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> age <span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> family <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'father'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'mother'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> deep_copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>origin<span class=\"token punctuation\">,</span> family<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>origin<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> deep_copy<span class=\"token punctuation\">.</span>family<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//false</span></code></pre></div>\n<p>하지만 위의 경우는 깊이가 깊어지면 매우 귀찮아진다. 아래의 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              num<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            name<span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          something<span class=\"token operator\">:</span> <span class=\"token string\">'something'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      last<span class=\"token operator\">:</span> <span class=\"token string\">'dance'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//얕은 복사</span>\n    <span class=\"token keyword\">const</span> shallow_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//깊이마다 얕은 복사 진행</span>\n    <span class=\"token keyword\">const</span> deep_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>object<span class=\"token punctuation\">,</span>\n      somewhere<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">,</span>\n        over<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">,</span>\n          the<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">,</span>\n            rainbow<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token operator\">...</span>object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow<span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n        object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> shallow_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//true -> 참조 공유</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>위는 너무 귀찮으므로, 깊이가 깊어질때에는 아래의 방법을 사용하자.</p>\n<ol start=\"2\">\n<li>\n<p>재귀함수</p>\n<p>재귀적으로 객체의 깊이까지 모두 복사를 해주면 된다. 이는 어느 객체에나 사용할 수 있는 범용적인 방법이 될 것이다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">deep_copy</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">object</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> new_object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\">//if element is object</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//not object => primitive type</span>\n          new_object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> new_object<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> deep_object_recursion <span class=\"token operator\">=</span> <span class=\"token function\">deep_copy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_recursion<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span>\n</code></pre></div>\n<p>위의 deep_copy 함수를 사용하면 깊이에 제한 없이 깊은 복사를 진행할 수 있다. 재귀적으로 원소의 type이 object이면 한단계 들어가서 복사를 진행하는 방법이다.</p>\n<ol start=\"3\">\n<li>\n<p>라이브러리</p>\n<p>깊은 복사를 해주도록 도와주는 자바스크립트 라이브러리가 있다. lodash, immutable을 찾아보도록 하자.</p>\n</li>\n<li>\n<p>JSON.stringfy, parse 함수</p>\n<p>이는 일종의 hack으로, 성능은 느리지만 간단하게 깊은 복사를 할 수 있는 방법이기도 하다. 원래 <code class=\"language-text\">JSON.stringify</code>는 JSON객체를 string으로 변환시켜주고, <code class=\"language-text\">JSON.parse</code>는 string을 JSON으로 변환시켜주는 메서드이다. 여기서 (객체 → string → 객체)의 방법으로 새로운 복사본을 만들어주면 된다. 아까의 object 예시에 이어서 해보겠다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">const</span> deep_object_json <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      object<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow <span class=\"token operator\">===</span> deep_object_json<span class=\"token punctuation\">.</span>somewhere<span class=\"token punctuation\">.</span>over<span class=\"token punctuation\">.</span>the<span class=\"token punctuation\">.</span>rainbow\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//false -> 깊은 복사 성공</span></code></pre></div>\n<p>이 방법이 외부 라이브러리를 사용하지 않는다면 가장 간단한 방법이겠으나, 문자열로 바꾼 객체를 다시 객체로 만드는 시간이 많이 든다는 것을 알고 있어야 한다.</p>\n<h1 id=\"마무리복사alias복습\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%EB%B3%B5%EC%82%ACalias%EB%B3%B5%EC%8A%B5\" aria-label=\"마무리복사alias복습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리(복사,alias복습)</h1>\n<p><img src=\"https://images.velog.io/images/choieastsea/post/a3fad05e-6882-4ab8-8cb4-20be79ad1dd0/Untitled%207.png\" alt=\"\"></p>\n<p>위의 사진에서 a와 b는 같은 객체를 공유하고 있고(참조공유), 이는 <strong>alias의 관계</strong>이다. 반면 c는 a의 2번 인덱스를 공유하고 나머지는 복사가 되었다. 이 경우 c는 a에서 <strong>얕은 복사</strong>가 이루어졌다고 볼 수 있다.(이차원 배열인 a에서 1차원선에서만 복사가 이루어졌기 때문) d는 a와 완전히 데이터는 일치하지만, 그 어느 것도 주소를 공유하지 않는다. 이는 <strong>깊은 복사</strong>가 이루어졌다고 볼 수 있다!</p>\n<p>JS에서 <em>타입이나 객체의 구조에 따라서 같은 방법으로 복사를 하더라도 어떤 것은 얕은 복사일수도 있고, 깊은 복사일 수 있다</em>. 이를 판단하는 것은 값 비교와 주소비교이다. A를 원본으로 하는 사본 B가 있을때, B의 모든 원소는 A의 모든 원소와 값이 같아야하며 주소는 달라야(===의 결과 false) 깊은복사라고 한다.</p>\n<h2 id=\"리액트에서-이를-알아야-하는-이유\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"리액트에서 이를 알아야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+리액트에서 이를 알아야 하는 이유</h2>\n<p>React.js에서는 상태의 불변성을 유지시켜줘야하는 이유에 대해서 알아보자. 리액트에서 상태가 변하면 re-rendering을 해줘야하므로, 상태가 변했음을 판단할 수 있어야 한다. 하지만 하나의 상태를 변형해가며 사용한다면(불변성 x) 같은 객체이며 값만 바뀐 것이므로, <strong>상태가 바뀌었는지 확인하는데 더 많은 자원을 소비해야한다</strong>. <em>따라서 아예 다른 객체를 할당해줌으로써 상태가 바뀌었다고 인식하여 리렌더링</em>한다*.* 불변성을 유지하며 상태를 변경하는 방법으로는, 깊은 복사를 해준 후 바꿀 부분만 추가로 바꿔주면 된다! 객체의 깊이에 따라 다양한 방법을 사용할 수 있다.</p>","frontmatter":{"date":"October 24, 2021","title":"(JS) 얕은복사와 깊은복사(shallow and deep copy) & aliasing","categories":"FE","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/FE-JS-copy/"}},"prev":{"id":"f83049d2-462d-55ec-b98f-2ddec347a1a4","html":"<p>Tree의 종류인 Heap에 대하여 알아보도록 하자.</p>\n<h1 id=\"heap\" style=\"position:relative;\"><a href=\"#heap\" aria-label=\"heap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heap</h1>\n<p><code class=\"language-text\">Heap</code>(힙)이란  <u>부모노드가 자식노드보다 큰(혹은 작은) 완전 이진 트리</u>를 의미한다. 형제 노드간의 대소관계는 상관없이 오직 부모와 자식관의 대소관계만 보면 된다. 완전이진트리는 마지막 레벨을 제외한 모든 노드가 가득차있고, 마지막 레벨은 왼쪽부터 순서대로 채워져 있는 이진트리이다.</p>\n<p>부모가 자식보다 큰 힙을 <code class=\"language-text\">최대힙(max heap)</code>, 부모가 자식보다 작은 힙을 <code class=\"language-text\">최소힙(min heap)</code>이라고 한다. 최대힙의 경우 모든 노드의 값 중 <strong>최댓값이 루트 노드로 오게 되며, 최소힙은 최솟값이 루트노드</strong>로 오게 되는 것이 자명하다. 이러한 힙의 속성을 이용하여 루트 노드를 반복적으로 <code class=\"language-text\">unshift</code>하는 <code class=\"language-text\">heap sort</code>(힙 정렬)을 구현할 수 있다. 또한 우선순위에 따라 선순선출(?)이 되는<code class=\"language-text\">Priority Queue</code>(우선순위 큐) 추상자료형을 구현할 수 있다.</p>\n<h1 id=\"완전-이진-트리-구현\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84\" aria-label=\"완전 이진 트리 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전 이진 트리 구현</h1>\n<p>우선 힙의 구조적인 형태는 Complete Binary Tree(완전 이진 트리)이다. 이는 이전 게시글과 같이 노드간의 레퍼런스로 구현할 수도 있지만, <u>배열로 편하게 구현 가능</u>하다! 아래의 트리를 보도록 하자. 아래는 완전 이진 트리이며 동시에 최대 힙이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVQ4y4WSuWsUYRiHt9HGItnNzj3zzX3sJmbX3RwmJngWoniCBjUQC/FAvDAmpJA0QhQUBI+g4lHYKIiKYqWIQiy08T8QRUSws7R5ZGaSGA+w+PHON+/7Pe/1FSzLYqFM0/ztLCwLVdMRqo6mavwvvvDPAGEhhMAyTSRJYaC/ybs3txnetYHWYhuWZeZ+8Te0sBCUybLQFBW9JOGHIa7r09PdyesX0+zYvg5NN6lUq6glCV1WMWZhc9DfgI5jUyqVOXJoJ8+fXaJe68DzfDRNo1QsI8sqvucRRRF3b01y4dxxJFnBtsU8o5CWby7I0tJS4uTxPcy8ukESB7SV5XyWQmRSFC1L8ODeFJcvnqJcltF04xdwDqYZBrUwoKteIwgjVEVhaa1OX2cHrhBZa2lsdyWmuayBoRsI26ar0aCeRNn9+ZbTYGGZvH97h5vXTyPLSrbZwRUNvn1+wuiJYRYtXsKWTav49OEpw7s3ZssqFstMjI3w9eNjero6s+rnZyhLCufPHuPwgaEsMK0mDnyuXR5nw/pBWlvb6O2uce3qBCsHu1FVLZtpmuTKxZPEUYCuGzlQ1XXW9jTpaXaxenkvy9oTVE1j82A/1aRKsVTGtu2s6nTG6oL3mELTf/rsHAu6YeC5Nl8+POTm9DgzL6d5dH+KlQNNfnx/wdHDQ7QWc2B6IbXpcsxsCfmy5nwZMG3NMAzGRkfYumUtB/dtY+/wRgLf5czkfgb6G1kV+Wswchmz1jT/sEYOdBwHR5UQqoSk6EiqiSkcimUN3XKwHRfheggnlYvjh/m3nfpy67gejutSSKtLH+qaukdfrBMnFaKkgh8lJNUOgspSfD8gTNrxwyhT3F7DD2PCMMys5/sEcZUgivkJAx+RoMwxz+QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Heap\"\n        title=\"Heap\"\n        src=\"/static/4c1eea6ed142b6ed6d8bdd62370544de/37523/CBT.png\"\n        srcset=\"/static/4c1eea6ed142b6ed6d8bdd62370544de/e9ff0/CBT.png 180w,\n/static/4c1eea6ed142b6ed6d8bdd62370544de/f21e7/CBT.png 360w,\n/static/4c1eea6ed142b6ed6d8bdd62370544de/37523/CBT.png 720w,\n/static/4c1eea6ed142b6ed6d8bdd62370544de/302a4/CBT.png 1080w,\n/static/4c1eea6ed142b6ed6d8bdd62370544de/289dd/CBT.png 1409w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>루트 노드에서부터 <em>BFS의 탐색순서</em>로 (그림의 빨간 글씨처럼) 노드에 숫자를 붙혀줄 수 있다. 완전 이진 트리이므로 마지막 레벨이 아니라면 노드가 채워져서 들어오므로, <strong>노드의 숫자는 그대로 배열의 인덱스로 표현 가능</strong>하다! 배열의 첫 인덱스는 보통 비워두는데, 이유는 이후에 접근을 쉽게 하기 위해서다. 위의 배열에서 10번 인덱스의 원소는 10번 노드인 1이 되는 것이다.</p>\n<p>배열로 완전 이진트리를 구현하면 노드의 번호만 안다면 접근을 <code class=\"language-text\">O(1)</code>로 가능하게 해준다. 또한 부모-자식간의 관계를 표현할 수도 있는데, 이 역시 인덱스를 이용할 수 있다.</p>\n<blockquote>\n<ul>\n<li>현재 노드의 인덱스 * 2 == 현재 노드의 왼쪽 자식 노드</li>\n<li>현재 노드의 인덱스 * 2 + 1 == 현재 노드의 오른쪽 자식 노드</li>\n<li>int(현재 노드의 인덱스 /2) == 현재 노드의 부모 노드</li>\n</ul>\n</blockquote>\n<p>10번 노드의 부모는 5번 노드가 되며, 2번 노드의 오른쪽 자식은 5(2*2+1)번 노드가 되는 것이다. 6번 노드의 왼쪽 자식은 존재하지 않는 다는 사실도 알 수 있다.(배열의 12번은 out of array index이므로)</p>\n<h1 id=\"heapify--배열을-힙을-만족하도록-변형sift-down\" style=\"position:relative;\"><a href=\"#heapify--%EB%B0%B0%EC%97%B4%EC%9D%84-%ED%9E%99%EC%9D%84-%EB%A7%8C%EC%A1%B1%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B3%80%ED%98%95sift-down\" aria-label=\"heapify  배열을 힙을 만족하도록 변형sift down permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heapify : 배열을 힙을 만족하도록 변형(sift down)</h1>\n<p>여기서 힙을 다루는 경우는 크게 <code class=\"language-text\">heap sort</code>를 하기 위해, <code class=\"language-text\">Priority Queue</code>를 구현하기 위해서 정도이다. 한 배열을 Heap속성을 만족시키도록 변형할 수도 있고, 처음부터 Heap속성을 만족시키도록 노드를 하나씩 힙에 추가할 수도 있다. 전자에 필요한 것이 <code class=\"language-text\">Heapify</code>이고, 후자의 경우에 필요한 것이 <code class=\"language-text\">Reverse Heapify</code>라고 하겠다. 일단 Heapify부터 구현해보도록 하자!</p>\n<p>Heapify(sift down)는 한 노드를 해당 서브트리에서 힙 속성을 만족시키는 곳에 위치하도록 하는 것이라고 볼 수 있다. 모든 인덱스에 Heapify를 해준다면 일반 배열을 Heap으로 바꿔줄 수 있다.  최소 힙에서의 Heapify의 재귀적인 알고리즘은 다음과 같다.</p>\n<p><strong>Alg Heapify</strong> : 아래로 내려가며 compare &#x26; swap</p>\n<ol start=\"0\">\n<li>해당 인덱스(인덱스가 유효하다면)를 루트로하는 서브트리를 관찰한다.</li>\n<li>해당 노드, 그 자식들을 비교하여 최솟값을 갖는 노드를 고른다.</li>\n<li>최솟값을 갖는 노드를 서브트리의 루트(부모노드 위치)와 바꿔준다.</li>\n<li>바뀐 노드에서 다시 heapify 해준다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">heapify</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>        \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//재귀 탈출 조건 : 자식 노드가 없는 아예 경우(한쪽만 있는 경우 처리 필요)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//왼쪽 자식만 있는 경우</span>\n        <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> leftChild <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">[</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;=</span> leftChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//왼쪽 자식이 더 작은 경우</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> index <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//heapify해주지 않아도됨. (인덱스 벗어나게 되므로)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> leftChild <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">[</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> rightChild <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">[</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;=</span> leftChild <span class=\"token operator\">&amp;&amp;</span> current <span class=\"token operator\">&lt;=</span> rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\">//current node가 가장 작은 경우</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftChild <span class=\"token operator\">&lt;=</span> current <span class=\"token operator\">&amp;&amp;</span> leftChild <span class=\"token operator\">&lt;=</span> rightChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">//leftChild node가 가장 작은 경우</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> index <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>                                                   \n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\">//그 외의 경우(rightChild node가 가장 작거나, 모두 같거나 등)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> index <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>heapify는 root node부터가 아닌 <strong>leaf node부터 올라와야한다</strong>!(엄밀히 말하면 leaf node의 부모부터 올라와야함) 루트에서 heapify가 되면 자식들이 이미 힙을 만족시키지 않는 상태이므로, 한 노드만 자리를 찾아가더라도 원하는 곳으로 가지 않게 된다. 따라서 아래의 서브트리부터 heap을 만족시켜가며 올라가는 devide&#x26;conquer의 형식으로 가야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">heap_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> heap_list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">heapified Arr: [null</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>heap_list<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">]\\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// heapified Arr: [null,-2,2,1,4,10,6]</span></code></pre></div>\n<h2 id=\"시간복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도</h2>\n<p>자 이제 <strong>배열을 힙으로</strong> 바꾸는 것까지는 구현했다. heapify 1회에 걸리는 시간은 평균적으로 트리의 높이에 비례한다고 볼 수 있다. 힙의 높이는 완전 이진 트리이므로 대략 <code class=\"language-text\">log2(n)</code>에 비례한다. 따라서 시간 복잡도는 <code class=\"language-text\">n*log(n)</code>이라고 볼 수 있다.</p>\n<p>이제는 Heap class를 구현해보도록 하자!</p>\n<h1 id=\"heap-구현-요구-사항\" style=\"position:relative;\"><a href=\"#heap-%EA%B5%AC%ED%98%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD\" aria-label=\"heap 구현 요구 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heap 구현 요구 사항</h1>\n<p>이제 힙 클래스를 구현해보도록 하자. 최솟값이 루트 노드로 오는 최소힙으로, 트리의 각 노드는 단순히 값만 갖고 있다고 가정하고 배열로 구현한다.(이후 Prim algorithm을 구현하면서 여러 값이 있는 노드 또한 배열로 처리 가능) 배열의 0번째 인덱스는 <code class=\"language-text\">null</code>을 넣어주며, 추가적으로 힙의 크기를 측정하는 count라는 optional property를 두었다.(지금 생각해보니 count는 아무 필요 없다)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MinHeap</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//1. 완전 이진 트리는 노드클래스 없이 배열로 구현 가능</span>\n    <span class=\"token comment\">//index n의 자식 노드: 2n,2n+1</span>\n    <span class=\"token comment\">//i의 부모 노드: parseInt(n/2)</span>\n    <span class=\"token comment\">//2. 부모 노드의 키 값은 항상 자식 노드의 키 값보다 작다</span>\n    heap_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//[null, 1, 2, 3]의 경우 count는 3</span>\n    count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol>\n<li>\n<p>reverseHeapify : 위로 올라가며 compare &#x26; swap <strong>(sift up)</strong></p>\n<p>한 트리가 Heap을 만족한다고 가정하였을 때, heap 성질을 만족하지 않을 것 같은 부분이 있다면 다음과 같은 일을 해줄 수 있다.</p>\n<ol>\n<li>\n<p>의심되는 노드와 부모 노드를 비교한다. (힙성질을 만족하는지 확인)</p>\n<p>그림에서는 3이 의심된다고 판단되어 부모노드인 11과 비교한다.</p>\n<p><img src=\"http://www.mathcs.emory.edu/~cheung/Courses/171/Syllabus/9-BinTree/FIGS/Heap03a.gif\" alt=\"\"></p>\n</li>\n<li>\n<p>부모가 더 크다면(힙 성질 위배) 의심되는 노드와 부모 노드를 바꿔준다.</p>\n<p><img src=\"http://www.mathcs.emory.edu/~cheung/Courses/171/Syllabus/9-BinTree/FIGS/Heap03b.gif\" alt=\"\"></p>\n</li>\n<li>\n<p>바뀐 노드는 다시 heap 성질을 만족하지 않을 수 있으므로 <strong>재귀적으로 수행</strong>한다.</p>\n<p>그림에서는 바뀐 3이 의심되므로 3의 부모인 5와 비교하여 수행하는 것이다.</p>\n<p><img src=\"http://www.mathcs.emory.edu/~cheung/Courses/171/Syllabus/9-BinTree/FIGS/Heap03d.gif\" alt=\"\"></p>\n</li>\n</ol>\n<p>이는 insert시 사용되는 핵심 개념이다. <strong>heapify는 해당 노드와 그 자식들을 비교했다면, 이는 해당 노드와 그 부모를 비교하므로 reverseHeapify라고 부르겠다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">reverseHeapify</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//하나씩 삽입할 때, 끝에서부터 올라오면서 힙의 조건을 만족시키도록(min heap에서는 부모가 더 크다면) 재귀적으로 스왑해주도록 한다</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> parentIndex <span class=\"token operator\">=</span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> parentIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverseHeapify</span><span class=\"token punctuation\">(</span>parentIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>swap</p>\n<p>힙에서 스왑은 매우 자주 일어나므로, 메서드로 만들어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">swap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">index_a<span class=\"token punctuation\">,</span> index_b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//swap은 재활용 많이 되므로</span>\n    <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>index_a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>index_a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>index_b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">[</span>index_b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>insert : 힙 성질을 유지하도록 노드 추가</p>\n<p>힙성질을 만족하는 트리에서 한 노드를 추가할때는 아래와 같은 순서를 따른다.</p>\n<ol>\n<li>일단 노드를 힙의 맨 끝에 추가한다.</li>\n<li>맨 끝 부분은 <u>힙 성질에 위배될 수 있는 의심점</u>이므로, reverseHeapify를 통하여 힙성질을 만족하는 곳으로 위치하도록 한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">insert</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//일단 Complete Binary Tree의 말단에 값을 삽입하고, 해당 인덱스에서 reverseHeapify 수행</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverseHeapify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>unshift : 삭제하기</p>\n<p>힙에서 맨 끝 노드를 삭제하는 것은 단순히 pop해주면 되므로 어려운 문제가 아니다. heap에서 가장 unique한(최소/대값이므로) root node를 추출하는 것은 단순하지는 않다. 이는 아래와 같이 해준다.</p>\n<ol>\n<li>루트 노드와 가장 마지막 노드를 swap한다.</li>\n<li>루트였던 마지막 노드를 pop해준다. 그러면 추출은 완료 되었다.</li>\n<li>하지만 현재 바뀐 루트 노드로 인해 heap 성질에 위배될 수 있다. <strong>이를 맞춰주기 위해 내려가면서 compare&#x26;swap하는 heapify를 진행한다</strong>(reverse heapify와 방향이 다르다!)</li>\n</ol>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">unshift</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//루트 노드를 삭제</span>\n    <span class=\"token comment\">//루트 노드와 마지막 노드의 위치를 바꾸고 루트였던 노드를 삭제한다. 그리고 heap 조건을 맞추도록 heapify 수행</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> returnValue <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap_list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> returnValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>​\tunshift 연산은 남아있는 최솟값(루트 노드)을 계속 추출하여 정렬된 상태로 만드는 <code class=\"language-text\">heap sort</code>에 사용된다!</p>\n<p>전체 코드는 <a href=\"https://github.com/choieastsea/DataStructureJS/blob/main/DS05_Heap.js\">깃허브에</a> 올려놓았다.</p>","frontmatter":{"date":"November 15, 2021","title":"(자료구조 JS) Heap","categories":"Alg","author":"choieastsea","emoji":"🙄"},"fields":{"slug":"/DS05-Heap/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/DS04-Tree/","nextSlug":"/FE-JS-copy/","prevSlug":"/DS05-Heap/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}