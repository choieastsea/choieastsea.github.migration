{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-75/",
    "result": {"data":{"cur":{"id":"197d0970-745b-5468-a9c2-1ef755c1599d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>0,1,2 로 구성된 정수형 배열을 오름차순으로 정렬하는 문제이다. <a href=\"https://leetcode.com/problems/sort-colors/\">링크</a></p>\n<p>문제에서는 라이브러리를 사용하지 않고, O(1)의 공간 복잡도로 문제를 해결하는 것을 제안하고 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ul>\n<li>\n<p>sol1</p>\n<p>0,1,2의 숫자를 세고 이후에 nums 배열에 값을 대입하는 방법을 생각해보았다.</p>\n</li>\n<li>\n<p>sol2</p>\n<p>sol1로 제출하고 속도가 느려 다른 풀이를 봤는데, <code class=\"language-text\">Dutch Flag Algorithm(DFA)</code>에 대한 언급이 많아 해당 알고리즘을 찾아보았다. <a href=\"https://medium.com/quick-code/dutch-flag-algorithm-3669af2b14fd\">출처</a></p>\n<p>DFA는 left, right, pointer(네이밍은 조금씩 다를 수 있으나, 의미는 유사하다) 3개의 포인터를 갖고 배열을 탐색한다.</p>\n<ul>\n<li>left : 가장 앞에 있어야 하는 값(여기서는 0)이 들어올 위치를 가리키는 포인터</li>\n<li>right : 가장 뒤에 있어야 하는 값(여기서는 2)가 들어올 위치를 가리키는 포인터</li>\n<li>pointer : 현재 위치를 가리키는 포인터</li>\n</ul>\n<p>0 ~ left, right ~ n-1의 구간은 각각 0,2로 확정되는 구간으로 만들고, left~right 사이를 순회하는 pointer를 두어 범위를 줄여나가는 것이 이 알고리즘의 핵심이다.</p>\n<p>배열의 pointer 위치를 보면서…</p>\n<ul>\n<li>2인 경우: right와 pointer를 swap 한다(보낼 수 있는 가장 뒤로 2를 보낸다). 이후 바뀐 pointer의 값을 다시 봐야할 것이므로 pointer는 옮기지 않는다. right는 앞으로 한칸 당겨 다음 2의 위치를 가리키도록 한다.</li>\n<li>1인 경우: pointer를 다음 칸으로 옮긴다.</li>\n<li>0인 경우: left와 pointer를 swap 한다(보낼 수 있는 가장 앞으로 0을 보낸다). left를 뒤로 당겨 다음 0의 위치를 가리키도록 한다. 여기서는 strt의 값이 <strong>무조건 0 아님 1이므로</strong> pointer를 다음칸으로 옮겨도 된다. <u>1의 위치는 0과 2를 양끝으로 보내기만 하면 알아서 가운데에 자리잡기 때문</u>이다.</li>\n</ul>\n<p>이를 <strong>pointer가 end보다 크지 않을 동안</strong> (pointer와 end가 겹치면 0<del>1</del>2 순으로 정렬이 완료되어 더 이상 보지 않아도 됨)탐색하면 된다.</p>\n</li>\n</ul>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity</p>\n<ul>\n<li>\n<p>sol1 : O(n), 하지만 sol2에 비하여 느리다 (심지어 python list sort 함수보다 느렸다) 배열을 두번 순회하므로 2*n의 시간이 걸리기 때문일 것이다.</p>\n</li>\n<li>\n<p>sol2 : O(n)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>두 방법 모두 공간 복잡도는 배열의 크기와 상관없이 일정할 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>첫번째 방법의 코드이다. 배열을 두번 순회하며 원소들의 갯수를 세어 값을 정렬한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        배열을 순회하며 0,1,2의 갯수를 센 이후,\n        배열을 다시 순회하며 값을 넣어줌\n        \"\"\"</span>\n        cnt0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        cnt2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> num <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                cnt0 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">pass</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                cnt2 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        cnt1 <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>cnt0<span class=\"token operator\">-</span>cnt2\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> cnt0 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                cnt0 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> cnt1 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n                cnt1 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n                cnt2 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>값은 단 3개로 정해져있으므로, <code class=\"language-text\">elif num == 2</code>가 아닌 <code class=\"language-text\">else</code>로 하니까 속도가 좀 더 빨라지긴 했다.</p>\n<p>두번째 코드는 <code class=\"language-text\">Dutch National Flag Algorithm</code>을 적용한 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Dutch National Flag Algorithm\n        pointer 위치에 있는 값을 확인하며,,,\n        2를 만나면 현재까지의 맨 뒤(right)로 스왑하여 보낸다 &amp; --left\n        1을 만나면 ++pointer\n        0을 만나면 현재까지의 맨 앞과 스왑하여 보낸다 &amp; ++strt &amp; ++pointer\n        \"\"\"</span>\n        left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> pointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">while</span> pointer <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># swap pointer ~ right</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move right to forward</span>\n                right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 0</span>\n                <span class=\"token comment\"># swap pointer ~ left</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token comment\"># move left to backward</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>맨 뒤로 보내는 경우에는 right에 어떤 값이 있는지 모르므로, swap 이후에 pointer를 업데이트 하지 않아야 한다. 반대로 맨 앞으로 보내야 하는 경우에는 left에 무조건 0또는 1만 존재하므로 swap하고 pointer를 뒤로 업데이트 한다!</p>","excerpt":"Intuition 0,1,2 로 구성된 정수형 배열을 오름차순으로 정렬하는 문제이다. 링크 문제에서는 라이브러리를 사용하지 않고, O(1)의 공간 복잡도로 문제를 해결하는 것을 제안하고 있다. Approach sol1 0,1,2의 숫자를 세고 이후에 nums 배열에 값을 대입하는 방법을 생각해보았다. sol2 sol1로 제출하고 속도가 느려 다른 풀이를 봤는데, 에 대한 언급이 많아 해당 알고리즘을 찾아보았다. 출처 DFA는 left, right, pointer(네이밍은 조금씩 다를 수 있으나, 의미는 유사하다) 3개의 포인터를 갖고 배열을 탐색한다. left : 가장 앞에 있어야 하는 값(여기서는 0)이 들어올 위치를 가리키는 포인터 right : 가장 뒤에 있어야 하는 값(여기서는 2)가 들어올 위치를 가리키는 포인터 pointer : 현재 위치를 가리키는 포인터 0 ~ left, right ~ n-1의 구간은 각각 0,2로 확정되는 구간으로 만들고, left~right 사이를…","frontmatter":{"date":"September 18, 2023","title":"(Alg) LeetCode Top Interview 150 - 75. sort colors (Dutch National Flag Algorithm)","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-75/"}},"next":{"id":"222f2675-aa22-52b5-b6a3-1e530a03e240","html":"<h2 id=\"orm\" style=\"position:relative;\"><a href=\"#orm\" aria-label=\"orm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM</h2>\n<p>ORM은 Object Relational Mapping의 약자.</p>\n<p>RDB의 테이블을 Object와 연결시켜 표현하고, SQL없이 해당 프레임워크의 언어로 데이터를 조작할 수 있도록 인터페이스 및 함수를 제공해준다. 이는 객체 지향 프로그래밍을 일관적으로 구성하는데 유용하다.</p>\n<p>또한, 여러 DB에 대하여 라이브러리가 존재하므로, DB를 변경할 때 생기는 DB의 문법적인 변경사항 등을 고려하지 않을 수 있다. (이식성이 높다)</p>\n<h2 id=\"n1-문제\" style=\"position:relative;\"><a href=\"#n1-%EB%AC%B8%EC%A0%9C\" aria-label=\"n1 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>n+1 문제</h2>\n<p>ORM을 사용하는 경우, 데이터에 접근하는 경우에 SQL 쿼리를 실행하게 된다.</p>\n<p>프레임워크마다 SQL을 실행하는 시점은 조금씩 다른데, 기본적으로는 <code class=\"language-text\">Lazy Loading</code>을 하게 될 것이다.</p>\n<blockquote>\n<p>장고에서는, Pages.objects.all() 등을 실행하면 쿼리셋이 생성되는데, 이때는 DB에 접근하지 않는다.</p>\n<p>쿼리셋 안의 데이터에 접근할 때, DB에 접근하게 된다. 이를 Lazy Loading(지연 로딩)이라고 한다.</p>\n<p>Lazy Loading과 반대되는 것은 Eager Loading(즉시 로딩)이다.</p>\n</blockquote>\n<p>하지만 참조된 테이블이 존재하는 경우, 1번의 쿼리로 가능한 구문이, <strong>참조되는 n개의 행에 접근하기 위해 쿼리를 n번 더 실행하는 경우</strong>가 생기는데, 이를 n+1 problem 이라고 한다.</p>\n<p>예를 들어, 학생과 학교 테이블이 있다고 생각해보자.</p>\n<p>학생들의 학교 이름을 출력한다고 할 때, 장고에서는 다음과 같이 짜볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students <span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># not yet query executed</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token comment\"># n+1 queries</span></code></pre></div>\n<p>이는 원래 SQL로 실행한다면 <code class=\"language-text\">SELECT school.name FROM student WHERE student.school_id = school.id;</code> 로 가능하다.</p>\n<p>하지만, ORM의 lazy loading의 경우 다음과 같은 순서로 실행 될 것이다.</p>\n<p><code class=\"language-text\">SELECT school_id FROM student;</code>하여 얻은 school_id를 각각 <code class=\"language-text\">sid</code>라고 했을 때,</p>\n<p><code class=\"language-text\">SELECT school.name FROM school WHERE school.id = {sid};</code> 를 <strong>추가적으로 n번(학생의 수만큼) 수행하게 되는 것이다</strong>.</p>\n<p>DB 쿼리를 실행하여 값을 가져오는 것은 (컴퓨터 기준으로 IO를 발생시키는) 오래걸리는 일이므로, 최소화 할 필요가 있다!</p>\n<p>장고에서는 EAGER loading (즉시 로딩)을 통하여 미리 참조된 데이터를 가져와 놓을 수 있는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">students<span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span>selected_related<span class=\"token punctuation\">(</span><span class=\"token string\">'school'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># selected_related</span>\n<span class=\"token keyword\">for</span> student <span class=\"token keyword\">in</span> students<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span>school<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\t<span class=\"token comment\"># 1 query</span></code></pre></div>\n<p>selected_related를 통하여 미리 학교에 대한 정보를 JOIN하여 가져오는 쿼리셋을 만들고, 이후에 값을 가져와 n+1 문제를 해결할 수 있다.</p>\n<p>추가적으로 <code class=\"language-text\">prefetch_related</code>를 이용하여 모든 relationship에 대하여 사용 가능한 방법도 있다.</p>\n<p><a href=\"https://hckcksrl.medium.com/django-n-1-problem-d986b93f5d3e\">참고</a></p>\n<h2 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시</h2>\n<p>n+1 문제를 시각화하기 위하여 query의 수행 횟수를 출력해보자.</p>\n<p>django에서는 connection.queries에 수행한 쿼리들이 배열의 형태로 저장된다. 이를 api단에서 출력하는 테스트를 만들 수 있다.</p>\n<p>우선, DB 스키마는 다음과 같다.</p>\n<p><img src=\"https://github.com/choieastsea/notion-be/blob/master/schema.png?raw=true\" alt=\"schema\"></p>\n<p>트리 형태의 page를 저장하기 위한 데이터 베이스 구조로, page_id는 각각 page_trees의 ancestor과 descendant가 될 수 있다.</p>\n<p>page_trees 테이블에서 page_id가 1인 page를 ancestor로 하는 page_id를 출력하는 예시를 보자. Lazy Loading 방식과 Eager Loading 방식으로 구현해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryTest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># LAZY LOADING</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token decorator annotation punctuation\">@api_view</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">queryImproved</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1 page를 부모로 갖는 페이지들의 title을 출력</span>\n    reset_queries<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># EAGER LOADING (참조된 Page table도 가져옴)</span>\n    querysets <span class=\"token operator\">=</span> PageTree<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>select_related<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    return_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> queryset <span class=\"token keyword\">in</span> querysets<span class=\"token punctuation\">:</span>\n        return_list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">.</span>descendant<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> query <span class=\"token keyword\">in</span> connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> Response<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"query count\"</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>connection<span class=\"token punctuation\">.</span>queries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"detail\"</span><span class=\"token punctuation\">:</span> return_list<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>두 api의 결과는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"query count\"</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"detail\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"6\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>detail(쿼리의 결과)는 같지만, 쿼리의 실행횟수가 LazyLoading 방식은 5번(해당하는 page의 수인 n만큼) 더 일어난 것을 확인해볼 수 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>이와 같이, <strong>참조된 테이블의 값을 지연 로딩을 통하여 가져오는 경우에는 n+1 문제가 발생</strong>할 수 있다. 관찰하다가 해당 쿼리가 불필요하게 많이 실행된다면, 해당 부분에 즉시 로딩을 도입하는 방법이 좋을 것이다. 그렇다고 모든 쿼리를 즉시 로딩을 한다면 역시 불필요한 쿼리가 실행되므로 로깅 등으로 기록하고 관찰하는 것이 좋을 것이다!</p>","frontmatter":{"date":"September 14, 2023","title":"(DB) n+1 문제와 해결책 (Django)","categories":"BE","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/BE-n+1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-75/","nextSlug":"/BE-n+1/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}