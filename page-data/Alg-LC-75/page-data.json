{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Alg-LC-75/",
    "result": {"data":{"cur":{"id":"197d0970-745b-5468-a9c2-1ef755c1599d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>0,1,2 로 구성된 정수형 배열을 오름차순으로 정렬하는 문제이다. <a href=\"https://leetcode.com/problems/sort-colors/\">링크</a></p>\n<p>문제에서는 라이브러리를 사용하지 않고, O(1)의 공간 복잡도로 문제를 해결하는 것을 제안하고 있다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<ul>\n<li>\n<p>sol1</p>\n<p>0,1,2의 숫자를 세고 이후에 nums 배열에 값을 대입하는 방법을 생각해보았다.</p>\n</li>\n<li>\n<p>sol2</p>\n<p>sol1로 제출하고 속도가 느려 다른 풀이를 봤는데, <code class=\"language-text\">Dutch Flag Algorithm(DFA)</code>에 대한 언급이 많아 해당 알고리즘을 찾아보았다. <a href=\"https://medium.com/quick-code/dutch-flag-algorithm-3669af2b14fd\">출처</a></p>\n<p>DFA는 left, right, pointer(네이밍은 조금씩 다를 수 있으나, 의미는 유사하다) 3개의 포인터를 갖고 배열을 탐색한다.</p>\n<ul>\n<li>left : 가장 앞에 있어야 하는 값(여기서는 0)이 들어올 위치를 가리키는 포인터</li>\n<li>right : 가장 뒤에 있어야 하는 값(여기서는 2)가 들어올 위치를 가리키는 포인터</li>\n<li>pointer : 현재 위치를 가리키는 포인터</li>\n</ul>\n<p>0 ~ left, right ~ n-1의 구간은 각각 0,2로 확정되는 구간으로 만들고, left~right 사이를 순회하는 pointer를 두어 범위를 줄여나가는 것이 이 알고리즘의 핵심이다.</p>\n<p>배열의 pointer 위치를 보면서…</p>\n<ul>\n<li>2인 경우: right와 pointer를 swap 한다(보낼 수 있는 가장 뒤로 2를 보낸다). 이후 바뀐 pointer의 값을 다시 봐야할 것이므로 pointer는 옮기지 않는다. right는 앞으로 한칸 당겨 다음 2의 위치를 가리키도록 한다.</li>\n<li>1인 경우: pointer를 다음 칸으로 옮긴다.</li>\n<li>0인 경우: left와 pointer를 swap 한다(보낼 수 있는 가장 앞으로 0을 보낸다). left를 뒤로 당겨 다음 0의 위치를 가리키도록 한다. 여기서는 strt의 값이 <strong>무조건 0 아님 1이므로</strong> pointer를 다음칸으로 옮겨도 된다. <u>1의 위치는 0과 2를 양끝으로 보내기만 하면 알아서 가운데에 자리잡기 때문</u>이다.</li>\n</ul>\n<p>이를 <strong>pointer가 end보다 크지 않을 동안</strong> (pointer와 end가 겹치면 0<del>1</del>2 순으로 정렬이 완료되어 더 이상 보지 않아도 됨)탐색하면 된다.</p>\n</li>\n</ul>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity</p>\n<ul>\n<li>\n<p>sol1 : O(n), 하지만 sol2에 비하여 느리다 (심지어 python list sort 함수보다 느렸다) 배열을 두번 순회하므로 2*n의 시간이 걸리기 때문일 것이다.</p>\n</li>\n<li>\n<p>sol2 : O(n)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>두 방법 모두 공간 복잡도는 배열의 크기와 상관없이 일정할 것이다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>첫번째 방법의 코드이다. 배열을 두번 순회하며 원소들의 갯수를 세어 값을 정렬한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        배열을 순회하며 0,1,2의 갯수를 센 이후,\n        배열을 다시 순회하며 값을 넣어줌\n        \"\"\"</span>\n        cnt0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        cnt2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> num <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                cnt0 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">pass</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                cnt2 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        cnt1 <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>cnt0<span class=\"token operator\">-</span>cnt2\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> cnt0 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                cnt0 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> cnt1 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n                cnt1 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n                cnt2 <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>값은 단 3개로 정해져있으므로, <code class=\"language-text\">elif num == 2</code>가 아닌 <code class=\"language-text\">else</code>로 하니까 속도가 좀 더 빨라지긴 했다.</p>\n<p>두번째 코드는 <code class=\"language-text\">Dutch National Flag Algorithm</code>을 적용한 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Dutch National Flag Algorithm\n        pointer 위치에 있는 값을 확인하며,,,\n        2를 만나면 현재까지의 맨 뒤(right)로 스왑하여 보낸다 &amp; --left\n        1을 만나면 ++pointer\n        0을 만나면 현재까지의 맨 앞과 스왑하여 보낸다 &amp; ++strt &amp; ++pointer\n        \"\"\"</span>\n        left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> pointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">while</span> pointer <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># swap pointer ~ right</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move right to forward</span>\n                right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">elif</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 0</span>\n                <span class=\"token comment\"># swap pointer ~ left</span>\n                nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>pointer<span class=\"token punctuation\">]</span>\n                <span class=\"token comment\"># move pointer</span>\n                pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token comment\"># move left to backward</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>맨 뒤로 보내는 경우에는 right에 어떤 값이 있는지 모르므로, swap 이후에 pointer를 업데이트 하지 않아야 한다. 반대로 맨 앞으로 보내야 하는 경우에는 left에 무조건 0또는 1만 존재하므로 swap하고 pointer를 뒤로 업데이트 한다!</p>","excerpt":"Intuition 0,1,2 로 구성된 정수형 배열을 오름차순으로 정렬하는 문제이다. 링크 문제에서는 라이브러리를 사용하지 않고, O(1)의 공간 복잡도로 문제를 해결하는 것을 제안하고 있다. Approach sol1 0,1,2의 숫자를 세고 이후에 nums 배열에 값을 대입하는 방법을 생각해보았다. sol2 sol1로 제출하고 속도가 느려 다른 풀이를 봤는데, 에 대한 언급이 많아 해당 알고리즘을 찾아보았다. 출처 DFA는 left, right, pointer(네이밍은 조금씩 다를 수 있으나, 의미는 유사하다) 3개의 포인터를 갖고 배열을 탐색한다. left : 가장 앞에 있어야 하는 값(여기서는 0)이 들어올 위치를 가리키는 포인터 right : 가장 뒤에 있어야 하는 값(여기서는 2)가 들어올 위치를 가리키는 포인터 pointer : 현재 위치를 가리키는 포인터 0 ~ left, right ~ n-1의 구간은 각각 0,2로 확정되는 구간으로 만들고, left~right 사이를…","frontmatter":{"date":"September 18, 2023","title":"(Alg) LeetCode Top Interview 150 - 75. sort colors (Dutch National Flag Algorithm)","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-75/"}},"next":{"id":"b42ec5e0-aae0-562f-9b65-3158bbeffa0d","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p>뱀과 사다리 게임에서 목적지까지의 최소 이동 횟수를 구하는 문제이다. <a href=\"https://leetcode.com/problems/snakes-and-ladders/\">링크</a></p>\n<p><a href=\"https://www.acmicpc.net/problem/16928\">백준 16928</a>과 거의 같은 문제이다.</p>\n<p>뱀과 사다리를 만나면 특정 칸으로 이동해야하는데, 칸이 앞에 있을수도 있고 뒤에 있을수도 있으므로, DP로 구현하기에는 무리가 있어보인다.</p>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>방문할 노드와 방문 시각을 같이 기록하여 최단 경로를 보장하는 BFS를 고려해볼 수 있다. BFS의 경우, 방문했던 곳을 기록하므로 cycle이 생기지 않으며, depth가 작은 순부터 모든 노드들을 탐색하므로 경로를 의미하는 depth의 최솟값을 보장할 수 있다.</p>\n<p>하지만, 이 문제의 경우, 주어지는 좌표와 board의 칸 번호가 다른 규칙을 갖고 있어 칸 번호를 행렬 표현으로 바꿔주는 함수가 필요하다고 생각하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getLocOfBoard</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    row <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n    col <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>row<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n    <span class=\"token keyword\">return</span> row<span class=\"token punctuation\">,</span>col</code></pre></div>\n<p>아니면 주어지는 2차원 배열을 변형하는 방법도 존재할 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>\n<p>Time complexity: O(n^2)</p>\n<p>노드의 갯수가 n^2개이고, 인접한 노드의 갯수는 6개(주사위 최댓값)이하이므로 시간복잡도는 O(n^2)라고 볼 수 있다.</p>\n</li>\n<li>\n<p>Space complexity: O(n^2)</p>\n<p>deque의 크기는 노드의 갯수에 비례한다.</p>\n</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">snakesAndLadders</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span>\n        q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># [blockNum,time]</span>\n        visited <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># print(q)</span>\n            blockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 목적지 도달한 경우</span>\n            <span class=\"token keyword\">if</span> blockNum <span class=\"token operator\">==</span> n<span class=\"token operator\">*</span>n<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> time\n            <span class=\"token comment\"># 1~6칸 이동</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                nextBlockNum <span class=\"token operator\">=</span> blockNum <span class=\"token operator\">+</span> i\n                nextRow <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">//</span>n\n                nextCol <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>nextRow<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">else</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>nextBlockNum<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>n\n                <span class=\"token comment\"># print(nextBlockNum, nextRow,nextCol)</span>\n                <span class=\"token keyword\">if</span> nextBlockNum <span class=\"token operator\">&lt;=</span> n<span class=\"token operator\">*</span>n <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    visited<span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                    <span class=\"token keyword\">if</span> board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>board<span class=\"token punctuation\">[</span>nextRow<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextCol<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> time<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                        q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nextBlockNum<span class=\"token punctuation\">,</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></code></pre></div>\n<p>처음에 q에서 popleft를 하여 목적지인지를 판단하고 아니라면 계속하여 BFS를 수행하면 된다. q가 비어있는 상황은 모든 노드를 탐색하여 더 이상 연결된 탐색할 노드가 없는 경우이다. 답이 없는 경우에는 -1을 리턴하라고 했으므로, while 문이 빠져나오면 리턴해주면 된다.</p>","frontmatter":{"date":"September 14, 2023","title":"(Alg) LeetCode Top Interview 150 - 909. Snakes and Ladders","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-909/"}},"prev":{"id":"1a10fb82-bb73-5a84-a9e0-959856b67ec6","html":"<h1 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h1>\n<p><code class=\"language-text\">NestedInteger</code> 자료형이 주어지고 NestedInteger의 List가 들어올 때, 이를 1차원 vector로 flatten한 배열을 만들어주는 <code class=\"language-text\">NestedIterator</code> 클래스를 구현하는 문제이다. <a href=\"https://leetcode.com/problems/flatten-nested-list-iterator/\">링크</a></p>\n<p>NestedInteger 는 아래와 인터페이스만 제공된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NestedInteger</span><span class=\"token punctuation\">:</span>\n   <span class=\"token keyword\">def</span> <span class=\"token function\">isInteger</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n       <span class=\"token triple-quoted-string string\">\"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"</span>\n\n   <span class=\"token keyword\">def</span> <span class=\"token function\">getInteger</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n       <span class=\"token triple-quoted-string string\">\"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"</span>\n\n   <span class=\"token keyword\">def</span> <span class=\"token function\">getList</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span>NestedInteger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n       <span class=\"token triple-quoted-string string\">\"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"</span></code></pre></div>\n<p>구현해야할 NestedIterator의 함수는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NestedIterator</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nestedList<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NestedInteger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        \n    <span class=\"token keyword\">def</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n       \n    <span class=\"token keyword\">def</span> <span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        \n\n<span class=\"token comment\"># Your NestedIterator object will be instantiated and called as such:</span>\n<span class=\"token comment\"># i, v = NestedIterator(nestedList), []</span>\n<span class=\"token comment\"># while i.hasNext(): v.append(i.next())      </span></code></pre></div>\n<h1 id=\"approach\" style=\"position:relative;\"><a href=\"#approach\" aria-label=\"approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Approach</h1>\n<p>init 함수에서 nestedList를 이용하여 <code class=\"language-text\">flattenList</code>를 만들어주고, next index를 가리키는 <code class=\"language-text\">pointer</code>를 구현하는 방법으로 생각해보았다. 그러면 next에서는 pointer의 값을 리턴하고, hasNext는 pointer의 범위를 확인하면 될 것이다.</p>\n<p>flattenList를 만들어주는 과정은 <code class=\"language-text\">DFS</code>를 이용하였다. <code class=\"language-text\">[[1,2,3],[4,[5],6,[7,8],9],[10]]</code>이 들어온다면 <code class=\"language-text\">[1,2,3,4,5,6,7,8,9,10] </code>으로 만들어줘야 하므로 배열인 경우에는 더 깊이 들어가고, 숫자인 경우에는 flattenList에 추가해주면 된다.</p>\n<p>주의할 점으로는 stack을 이용한 DFS의 경우, 역순으로 탐색하게 되므로 reverse를 해주어 스택에 넣어주면 될 것이다.</p>\n<h1 id=\"complexity\" style=\"position:relative;\"><a href=\"#complexity\" aria-label=\"complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexity</h1>\n<ul>\n<li>Time complexity : O(n)</li>\n<li>Space complexity: O(n)</li>\n</ul>\n<h1 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h1>\n<p>첫번째 방법의 코드이다. 배열을 두번 순회하며 원소들의 갯수를 세어 값을 정렬한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># \"\"\"</span>\n<span class=\"token comment\"># This is the interface that allows for creating nested lists.</span>\n<span class=\"token comment\"># You should not implement it, or speculate about its implementation</span>\n<span class=\"token comment\"># \"\"\"</span>\n<span class=\"token comment\"># class NestedInteger:</span>\n<span class=\"token comment\">#    def isInteger(self) -> bool:</span>\n<span class=\"token comment\">#        \"\"\"</span>\n<span class=\"token comment\">#        @return True if this NestedInteger holds a single integer, rather than a nested list.</span>\n<span class=\"token comment\">#        \"\"\"</span>\n\n<span class=\"token comment\">#    def getInteger(self) -> int:</span>\n<span class=\"token comment\">#        \"\"\"</span>\n<span class=\"token comment\">#        @return the single integer that this NestedInteger holds, if it holds a single integer</span>\n<span class=\"token comment\">#        Return None if this NestedInteger holds a nested list</span>\n<span class=\"token comment\">#        \"\"\"</span>\n\n<span class=\"token comment\">#    def getList(self) -> [NestedInteger]:</span>\n<span class=\"token comment\">#        \"\"\"</span>\n<span class=\"token comment\">#        @return the nested list that this NestedInteger holds, if it holds a nested list</span>\n<span class=\"token comment\">#        Return None if this NestedInteger holds a single integer</span>\n<span class=\"token comment\">#        \"\"\"</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">NestedIterator</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nestedList<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NestedInteger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># flatten nestedList</span>\n        self<span class=\"token punctuation\">.</span>flattenList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> nestedInteger <span class=\"token keyword\">in</span> nestedList<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nestedInteger<span class=\"token punctuation\">.</span>isInteger<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>flattenList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>nestedInteger<span class=\"token punctuation\">.</span>getInteger<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># depth first search</span>\n                stack <span class=\"token operator\">=</span> nestedInteger<span class=\"token punctuation\">.</span>getList<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>\n                    currentNestedInteger <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">if</span> currentNestedInteger<span class=\"token punctuation\">.</span>isInteger<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                        self<span class=\"token punctuation\">.</span>flattenList<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>currentNestedInteger<span class=\"token punctuation\">.</span>getInteger<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                        stack<span class=\"token punctuation\">.</span>extend<span class=\"token punctuation\">(</span>currentNestedInteger<span class=\"token punctuation\">.</span>getList<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>pointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        \n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        nextVal <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>flattenList<span class=\"token punctuation\">[</span>self<span class=\"token punctuation\">.</span>pointer<span class=\"token punctuation\">]</span>\n        self<span class=\"token punctuation\">.</span>pointer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> nextVal\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>pointer <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>flattenList<span class=\"token punctuation\">)</span>\n        \n\n            \n\n<span class=\"token comment\"># Your NestedIterator object will be instantiated and called as such:</span>\n<span class=\"token comment\"># i, v = NestedIterator(nestedList), []</span>\n<span class=\"token comment\"># while i.hasNext(): v.append(i.next())</span></code></pre></div>\n<p>nestedList를 순회하면서, nestedInteger가 integer인지 list인지에 따라 DFS를 수행하거나 flattenList에 넣어주면 된다.</p>","frontmatter":{"date":"September 19, 2023","title":"(Alg) LeetCode Top Interview 150 - 341. Flatten Nested List Iterator","categories":"Alg","author":"choieastsea","emoji":"🫠"},"fields":{"slug":"/Alg-LC-341/"}},"site":{"siteMetadata":{"siteUrl":"https://choieastsea.github.io","comments":{"utterances":{"repo":"choieastsea/choieastsea.github.io"}}}}},"pageContext":{"slug":"/Alg-LC-75/","nextSlug":"/Alg-LC-909/","prevSlug":"/Alg-LC-341/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}