---
emoji: 😬
title: (DS) 자료구조 정리 01- 수학적 귀납법, 배열, 재귀, merge sort
date: '2022-07-01 00:00:00'
author: choieastsea
tags: DS, Algorithm, array, recursion, merge sort
categories: Alg

---



자료구조를 다시 공부하면서 정리하고 있다. 코드보다는 아이디어를 위주로 작성할 예정이다! 언어와 문법에 큰 신경을 쓰지 않지만, c++을 중심으로 코딩할 예정이다.

# 수학적 귀납법

컴퓨터에서 많은 알고리즘들은 수학적 귀납법과 귀류법 등을 이용하여 정확하다고 증명할 수 있는데, 수학적 귀납법은 다음과 같다.

> BASE : P(1)이 참이다.
>
> STEP : P(n-1) -> P(n)이 참이다.
>
> 따라서, 모든 자연수 n에 대하여 P(n)은 참이다.

BASE와 STEP이 참임을 보이면 해당 함수는 모든 자연수에서 성립한다고 볼 수 있다. step에서의 핵심은 **P(n-1)이 참이라고 믿는 것**인데, 이유는 무엇일까.

## P->Q의 의미

예를 들어, 100점을 맞으면(P) 치킨을 사준다(Q)는 약속이 있고, 경우에 따라 이 약속이 참인지 거짓인지(약속을 지켰는지 안지켰는지) 생각해보자.

- 100점을 맞고, 치킨을 사주었다. => 참
- 100점을 맞고, 치킨을 안사주었다. => 거짓
- 100점을 안맞았고, 치킨을 안사주었다. => 참
- 100점을 안맞았는데, 치킨을 사주었다. => **참**

마지막 경우가 참인 이유는 100점을 안맞았을때의 약속에는 아무 내용도 없기 때문에 판단할 수 없고, 약속을 어긴 것은 아니기 때문이다. 이를 `vacuously true`라고 부르는 사람도 있고, 어쨌든 약속은 100점을 안맞았을때는 신경쓸 필요가 없이 참이고, **100점을 맞았을 때 치킨을 사주는지 여부에 따라서 약속의 참거짓이 결정**된다.

이를 위의 step에 대입시켜보자. P(n-1) -> P(n)이 참인 것을 보이려면, P(n-1)이 거짓인 경우에는 항상 참이므로(vacuously true), 굳이 무언가를 증명할 필요가 없다. 따라서, P(n-1)이 참인 것을 가정하고, P(n)이 참임을 보이면 되는 것이다. 주로, 귀납법에서는 해당 함수, 수식이 항상 성립함을 증명하므로 이와 같이 생각하면 편할 것이다.

# 배열(Array)

이제 본격적으로 자료구조에 대하여 공부해보자. 가장 기본적인 자료구조는 배열이다. 

## 정의

배열은 연속된 주소에 동일한 type의 자료형들이 모여있는 것들을 말한다. C에서의 배열은 연속된 주소에 같은 타입의 데이터가 저장되어 있고, python과 같은 언어에서는 array가 아닌 list를 사용하는데, 이는 연속된 주소에 데이터를 가리키는 reference가 저장되어 있다. 따라서, list에는 여러가지 자료형을 넣을 수 있는 것이다.

## 장점

배열의 가장 큰 장점은 배열의 연속된 공간에서 오는 특징에서 기인하는데, 바로 Access Time 이다. 보통 선형 자료구조에서는 처음부터 끝까지 가리키기 위해 index가 존재하는데, 배열에서는 연속된 공간에 같은 type이 모여있으므로, **특정 인덱스에 대하여 상수시간에 접근이 가능하다**. 

예를 들어, 배열에서 k번째의 data에 접근하려고 한다고 해보자. 이는 `배열의 시작주소 + (k-1)*(type size)`로 접근이 가능하며, 이는 배열의 크기가 크거나 k의 크기가 커도 항상 같은 시간(`O(1)`)에 접근할 수 있게 된다. LinkedList 등은 시작부터 k-1번 인덱스까지 차례대로 접근해야하므로, 이는 상수시간이 아니다. 

또한, 정렬된 배열(sorted array)의 경우 `search`가 빠르다. 이는 `Binary Search`(이분탐색)을 통해 `O(log n)`시간에 탐색이 가능하다. 참고로, 접근과 탐색은 특정 값을 찾는지 특정 위치의 값을 찾는지 이므로 완전히 다른 것이다.! 

정렬되지 않은 배열의 경우에는 탐색에는 일일이 탐색하는 `Linear Search`(선형탐색)을 통해 `O(n)` 시간이 걸리므로 느리다.

## 단점

 배열의 단점으로는 크기 변화에 대한 비용이 크다는 것이 있다. 배열은 선언시 정해진 크기만큼 메모리 공간을 차지하므로, 해당 크기를 넘어가게 되면 새로운 빈 공간을 찾아서 할당하고 이전의 값들을 복사하여 옮기는 작업이 필요하다! 우리가 사용하는 동적배열도 내부적으로는 정적배열로 구현되어있고, 크기 변화시 이러한 오버헤드가 발생함을 알 수 있다. 배열의 크기가 줄이는 경우에도 마찬가지.

## 결론

배열은 크기의 변화가 적고, 같은 자료형인 data들로 구성하는 것이 적합하다. 만약, 정렬이 되어있거나 정렬에 대하여 오래걸리지 않는다면 배열은 탐색 또한 빠른 자료구조이다!



# 재귀 (Recursion)

재귀는 보통 함수에서 많이 사용되는 개념으로, 함수 안에 해당 함수를 호출하는 것을 재귀함수라고 한다. loop를 사용하는 것을 재귀를 사용하면 더 직관적이고 코드가 짧아지는 경우가 많으므로 잘 알아두자.

## 재귀함수의 구성

재귀는 위에서 공부한 `수학적 귀납법`과 매우 유사한 구조를 갖는다. 재귀 자체가 귀납적으로 구성되어 있기 때문이다. 재귀함수는 보통 base case와 recursion case로 나뉜다.

1. base case

   재귀함수를 탈출(return)하는 조건. 귀납법에서의 base 에 해당

2. recursion case

   재귀적으로 실행되는 조건. 귀납법에서의 step에 해당

## 재귀함수의 해석

재귀적으로 생각하기 위해, 재귀함수를 n부터 1까지 따라 내려가는 것은 오히려 이해에 방해가 될 수 있다. 귀납법과 같이, 해당 함수가 정답이 return된다고 생각하고 재귀함수를 구성하면 된다!

이에 대한 예시로, 정렬 중 하나인 merge sort를 구현해보도록 하자.

## merge sort

`merge sort`는 `merge algorithm`을 이용한 정렬이다. 머지 알고리즘은, 두 정렬된 배열을 합쳐 하나의 정렬된 배열을 만드는 알고리즘이다. 두 정렬된 배열 first, second가 있을 때, 각 배열의 <u>제일 앞 요소만을 비교하여 더 작은 것을 새로운 배열에 차례대로 빼서 넣어주</u>면 된다. c++로 코드를 다음과 같이 짜보았다. (인자는 순서대로 정렬된 결과 배열, 정렬된 첫번째 배열, 정렬된 두번째 배열, 결과 배열의 크기, 첫번째 배열의 크기, 두번째 배열의 크기를 의미한다)

### merge algorithm

```c++
void merge(int ret[], int first[], int second[], int n, int first_size, int second_size)
{
    // 정렬된 두 배열을 합쳐 하나의 정렬된 배열로 만든다.
    int firstcnt = 0, secondcnt = 0;
    for (int i = 0; i < n; i++)
    {
        if (*first < *second)
        {
            ret[i] = *first;
            first++;
            firstcnt++;
        }
        else
        {
            ret[i] = *second;
            second++;
            secondcnt++;
        }
        if (firstcnt >= first_size)
        {
            //1. first 배열에 남은 값이 없는 경우 -> 새로운 배열에 second를 순서대로 넣는다.
            for (int j = i + 1; j < n; j++)
            {
                ret[j] = *second;
                second++;
            }
            break;
        }
        if (secondcnt >= second_size)
        {
          	//2. second 배열에 남은 값이 없는 경우
            for (int j = i + 1; j < n; j++)
            {
                ret[j] = *first;
                first++;
            }
            break;
        }
    }
}
```

C++에서는 배열의 이름이 배열의 주소를 의미하고, 이를 하나씩 증가시킬때마다 배열의 인덱스 한칸만큼 증가하는 것을 이용하였다. 살짝 골치아픈 것은 두 배열의 크기가 다를 수도 있고, 두 배열의 크기가 같더라도 한 배열이 값이 더 작은 것들이 많아 먼저 소진된다면, 결과 배열에 나머지 값들을 차례대로 넣어줘야하는데, 다른 방법이 생각나지 않아 단순하게 차례대로 넣어주도록 처리하였다.

이제, merge sort를 재귀적으로 구현해보자! 핵심은 재귀적으로 생각하는 방법이다.

```c++
void merge_sort(int arr[], int n)
{
    int i;
    if (n <= 1)
    // base case
    {
        return;
    }
    int m = n / 2;
    int new_arr[n]; // 결과를 저장할 새로운 배열
    for (i = 0; i < n; i++)
    {
        new_arr[i] = arr[i];
    }
    // 절반씩 나누어서 merge_sort & 합치기
    if (n % 2 == 1)
    // n이 홀수인 경우 step
    {
        merge_sort(new_arr, m);
        merge_sort(new_arr + m, m + 1);
        merge(arr, new_arr, new_arr + m, n, m, m + 1);
    }
    else
    // n이 짝수인 경우 step
    {
        merge_sort(new_arr, m);
        merge_sort(new_arr + m, m);
        merge(arr, new_arr, new_arr + m, n, m, m);
    }
}
```

### merge sort algorithm

합병 정렬의 인자로는 정렬되지 않은 배열이 주어질 것이고, 이 함수를 통하여 배열을 정렬하는 것을 기대한다.

1. base case

   배열의 크기가 1보다 작다면, **(정렬이 완료된 것이므로)** 종료한다.

2. step

   1. 배열의 크기가 1보다 크다면, 배열을 앞부분 배열과 뒷부분 배열로 나누어서 각각 `merge sort` 해준다.
   2. 정렬된 두 배열을 merge 알고리즘을 통하여 하나의 정렬된 배열로 합쳐준다.

잘 와닿지 않지만, 2-1은 수학적 귀납법에서 P(n-1)이 참이라고 가정하는 부분과 유사하다! 나누어서 각각 merge sort 해주는데, 여기서 그 안을 생각하지 말자!! **merge sort의 결과로 정렬된 배열이 나온다고 가정하는 것이 핵심**이다. base case가 잘 되어있다면, 이 함수는 정렬을 완벽하게 수행하여 리턴될 것이다!



